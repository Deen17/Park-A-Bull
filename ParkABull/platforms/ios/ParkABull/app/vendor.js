(global["webpackJsonp"] = global["webpackJsonp"] || []).push([[4],{

/***/ "../node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("../node_modules/base64-js/index.js")
var ieee754 = __webpack_require__("../node_modules/ieee754/index.js")
var isArray = __webpack_require__("../node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/charenc/charenc.js":
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ "../node_modules/crypt/crypt.js":
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js?!../node_modules/nativescript-theme-core/css/forest.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "/*!\r\n * NativeScript Theme v0.1.0 (https://nativescript.org)\r\n * Copyright 2016-2016 The Theme Authors\r\n * Copyright 2016-2016 Telerik\r\n * Licensed under MIT (https://github.com/NativeScript/theme/blob/master/LICENSE)\r\n */.c-white{color:#fff}.c-bg-white{background-color:#fff}.c-black{color:#000}.c-bg-black{background-color:#000}.c-aqua{color:#00caab}.c-bg-aqua{background-color:#00caab}.c-blue{color:#3d5afe}.c-bg-blue{background-color:#3d5afe}.c-charcoal{color:#303030}.c-bg-charcoal{background-color:#303030}.c-brown{color:#795548}.c-bg-brown{background-color:#795548}.c-forest{color:#006968}.c-bg-forest{background-color:#006968}.c-grey{color:#e0e0e0}.c-bg-grey{background-color:#e0e0e0}.c-grey-light{color:#bababa}.c-bg-grey-light{background-color:#bababa}.c-grey-dark{color:#5c687c}.c-bg-grey-dark{background-color:#5c687c}.c-purple{color:#8130ff}.c-bg-purple{background-color:#8130ff}.c-lemon{color:#ffea00}.c-bg-lemon{background-color:#ffea00}.c-lime{color:#aee406}.c-bg-lime{background-color:#aee406}.c-orange{color:#f57c00}.c-bg-orange{background-color:#f57c00}.c-ruby{color:#ff1744}.c-bg-ruby{background-color:#ff1744}.c-sky{color:#30bcff}.c-bg-sky{background-color:#30bcff}.w-full{width:100%}.w-100{width:100}.h-full{height:100%}.h-100{height:100}.m-0{margin:0}.m-t-0{margin-top:0}.m-r-0{margin-right:0}.m-b-0{margin-bottom:0}.m-l-0{margin-left:0}.m-x-0{margin-right:0;margin-left:0}.m-y-0{margin-top:0;margin-bottom:0}.m-2{margin:2}.m-t-2{margin-top:2}.m-r-2{margin-right:2}.m-b-2{margin-bottom:2}.m-l-2{margin-left:2}.m-x-2{margin-right:2;margin-left:2}.m-y-2{margin-top:2;margin-bottom:2}.m-4{margin:4}.m-t-4{margin-top:4}.m-r-4{margin-right:4}.m-b-4{margin-bottom:4}.m-l-4{margin-left:4}.m-x-4{margin-right:4;margin-left:4}.m-y-4{margin-top:4;margin-bottom:4}.m-5{margin:5}.m-t-5{margin-top:5}.m-r-5{margin-right:5}.m-b-5{margin-bottom:5}.m-l-5{margin-left:5}.m-x-5{margin-right:5;margin-left:5}.m-y-5{margin-top:5;margin-bottom:5}.m-8{margin:8}.m-t-8{margin-top:8}.m-r-8{margin-right:8}.m-b-8{margin-bottom:8}.m-l-8{margin-left:8}.m-x-8{margin-right:8;margin-left:8}.m-y-8{margin-top:8;margin-bottom:8}.m-10{margin:10}.m-t-10{margin-top:10}.m-r-10{margin-right:10}.m-b-10{margin-bottom:10}.m-l-10{margin-left:10}.m-x-10{margin-right:10;margin-left:10}.m-y-10{margin-top:10;margin-bottom:10}.m-12{margin:12}.m-t-12{margin-top:12}.m-r-12{margin-right:12}.m-b-12{margin-bottom:12}.m-l-12{margin-left:12}.m-x-12{margin-right:12;margin-left:12}.m-y-12{margin-top:12;margin-bottom:12}.m-15{margin:15}.m-t-15{margin-top:15}.m-r-15{margin-right:15}.m-b-15{margin-bottom:15}.m-l-15{margin-left:15}.m-x-15{margin-right:15;margin-left:15}.m-y-15{margin-top:15;margin-bottom:15}.m-16{margin:16}.m-t-16{margin-top:16}.m-r-16{margin-right:16}.m-b-16{margin-bottom:16}.m-l-16{margin-left:16}.m-x-16{margin-right:16;margin-left:16}.m-y-16{margin-top:16;margin-bottom:16}.m-20{margin:20}.m-t-20{margin-top:20}.m-r-20{margin-right:20}.m-b-20{margin-bottom:20}.m-l-20{margin-left:20}.m-x-20{margin-right:20;margin-left:20}.m-y-20{margin-top:20;margin-bottom:20}.m-24{margin:24}.m-t-24{margin-top:24}.m-r-24{margin-right:24}.m-b-24{margin-bottom:24}.m-l-24{margin-left:24}.m-x-24{margin-right:24;margin-left:24}.m-y-24{margin-top:24;margin-bottom:24}.m-25{margin:25}.m-t-25{margin-top:25}.m-r-25{margin-right:25}.m-b-25{margin-bottom:25}.m-l-25{margin-left:25}.m-x-25{margin-right:25;margin-left:25}.m-y-25{margin-top:25;margin-bottom:25}.m-28{margin:28}.m-t-28{margin-top:28}.m-r-28{margin-right:28}.m-b-28{margin-bottom:28}.m-l-28{margin-left:28}.m-x-28{margin-right:28;margin-left:28}.m-y-28{margin-top:28;margin-bottom:28}.m-30{margin:30}.m-t-30{margin-top:30}.m-r-30{margin-right:30}.m-b-30{margin-bottom:30}.m-l-30{margin-left:30}.m-x-30{margin-right:30;margin-left:30}.m-y-30{margin-top:30;margin-bottom:30}.p-0{padding:0}.p-t-0{padding-top:0}.p-r-0{padding-right:0}.p-b-0{padding-bottom:0}.p-l-0{padding-left:0}.p-x-0{padding-right:0;padding-left:0}.p-y-0{padding-top:0;padding-bottom:0}.p-2{padding:2}.p-t-2{padding-top:2}.p-r-2{padding-right:2}.p-b-2{padding-bottom:2}.p-l-2{padding-left:2}.p-x-2{padding-right:2;padding-left:2}.p-y-2{padding-top:2;padding-bottom:2}.p-4{padding:4}.p-t-4{padding-top:4}.p-r-4{padding-right:4}.p-b-4{padding-bottom:4}.p-l-4{padding-left:4}.p-x-4{padding-right:4;padding-left:4}.p-y-4{padding-top:4;padding-bottom:4}.p-5{padding:5}.p-t-5{padding-top:5}.p-r-5{padding-right:5}.p-b-5{padding-bottom:5}.p-l-5{padding-left:5}.p-x-5{padding-right:5;padding-left:5}.p-y-5{padding-top:5;padding-bottom:5}.p-8{padding:8}.p-t-8{padding-top:8}.p-r-8{padding-right:8}.p-b-8{padding-bottom:8}.p-l-8{padding-left:8}.p-x-8{padding-right:8;padding-left:8}.p-y-8{padding-top:8;padding-bottom:8}.p-10{padding:10}.p-t-10{padding-top:10}.p-r-10{padding-right:10}.p-b-10{padding-bottom:10}.p-l-10{padding-left:10}.p-x-10{padding-right:10;padding-left:10}.p-y-10{padding-top:10;padding-bottom:10}.p-12{padding:12}.p-t-12{padding-top:12}.p-r-12{padding-right:12}.p-b-12{padding-bottom:12}.p-l-12{padding-left:12}.p-x-12{padding-right:12;padding-left:12}.p-y-12{padding-top:12;padding-bottom:12}.p-15{padding:15}.p-t-15{padding-top:15}.p-r-15{padding-right:15}.p-b-15{padding-bottom:15}.p-l-15{padding-left:15}.p-x-15{padding-right:15;padding-left:15}.p-y-15{padding-top:15;padding-bottom:15}.p-16{padding:16}.p-t-16{padding-top:16}.p-r-16{padding-right:16}.p-b-16{padding-bottom:16}.p-l-16{padding-left:16}.p-x-16{padding-right:16;padding-left:16}.p-y-16{padding-top:16;padding-bottom:16}.p-20{padding:20}.p-t-20{padding-top:20}.p-r-20{padding-right:20}.p-b-20{padding-bottom:20}.p-l-20{padding-left:20}.p-x-20{padding-right:20;padding-left:20}.p-y-20{padding-top:20;padding-bottom:20}.p-24{padding:24}.p-t-24{padding-top:24}.p-r-24{padding-right:24}.p-b-24{padding-bottom:24}.p-l-24{padding-left:24}.p-x-24{padding-right:24;padding-left:24}.p-y-24{padding-top:24;padding-bottom:24}.p-25{padding:25}.p-t-25{padding-top:25}.p-r-25{padding-right:25}.p-b-25{padding-bottom:25}.p-l-25{padding-left:25}.p-x-25{padding-right:25;padding-left:25}.p-y-25{padding-top:25;padding-bottom:25}.p-28{padding:28}.p-t-28{padding-top:28}.p-r-28{padding-right:28}.p-b-28{padding-bottom:28}.p-l-28{padding-left:28}.p-x-28{padding-right:28;padding-left:28}.p-y-28{padding-top:28;padding-bottom:28}.p-30{padding:30}.p-t-30{padding-top:30}.p-r-30{padding-right:30}.p-b-30{padding-bottom:30}.p-l-30{padding-left:30}.p-x-30{padding-right:30;padding-left:30}.p-y-30{padding-top:30;padding-bottom:30}.hr-light{height:1;background-color:#e0e0e0;width:100%}.hr-dark{height:1;background-color:#303030;width:100%}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.font-weight-normal{font-weight:normal}.font-weight-bold{font-weight:bold}.font-italic{font-style:italic}.t-10{font-size:10}.t-12{font-size:12}.t-14{font-size:14}.t-15{font-size:15}.t-16{font-size:16}.t-17{font-size:17}.t-18{font-size:18}.t-19{font-size:19}.t-20{font-size:20}.t-25{font-size:25}.t-30{font-size:30}.img-rounded{border-radius:5}.img-circle{border-radius:20}.img-thumbnail{border-radius:0}.invisible{visibility:collapse}.pull-left{horizontal-align:left}.pull-right{horizontal-align:right}.m-x-auto{horizontal-align:center}.m-y-auto{vertical-align:center}.text-primary{color:#00caab}.text-danger{color:#d50000}.text-muted{color:#9e9e9e}.bg-primary{background-color:#00caab;color:#fff}.bg-danger{background-color:#d50000;color:#fff}.action-bar{background-color:#006968;color:#fff}.action-bar .action-bar-title{font-weight:bold;font-size:17;vertical-align:center}.action-bar .action-item{font-weight:normal}.activity-indicator{color:#00caab;width:30;height:30}.btn{color:#00caab;background-color:transparent;min-height:36;min-width:64;padding:10 10 10 10;font-size:18;margin:8 16 8 16}.btn.btn-active:highlighted{color:#fff;background-color:#00fdd6}.btn-primary{background-color:#00caab;border-color:#00caab;color:#fff}.btn-primary.btn-active:highlighted{background-color:#009780;border-color:#009780}.btn-primary.btn-aqua{background-color:#00caab}.btn-primary.btn-blue{background-color:#3d5afe}.btn-primary.btn-brown{background-color:#795548}.btn-primary.btn-forest{background-color:#006968}.btn-primary.btn-grey{background-color:#5c687c}.btn-primary.btn-lemon{background-color:#ffea00;color:#000}.btn-primary.btn-lime{background-color:#aee406;color:#000}.btn-primary.btn-orange{background-color:#f57c00}.btn-primary.btn-purple{background-color:#8130ff}.btn-primary.btn-ruby{background-color:#ff1744}.btn-primary.btn-sky{background-color:#30bcff}.btn-outline{background-color:transparent;border-color:#00caab;color:#00caab}.btn-outline.btn-active:highlighted{background-color:#00fdd6}.btn[isEnabled=false]{color:#a4a4a4;background-color:#e0e0e0;border-color:#e0e0e0}.fa{font-family:FontAwesome, fontawesome-webfont}.form .input{padding:16 8 16 8;background-color:transparent}.form .input.input-border{border-width:1;border-color:#e0e0e0;border-radius:2;padding:16}.form .input.input-rounded{border-width:1;border-color:#e0e0e0;border-radius:28;padding:16}.form .input[isEnabled='false']{background-color:#fafafa}.form .input-field{margin:8}.form .input-field .label{font-size:12;color:#bababa}.form .input-field .input{padding:0;margin:0 0 8 0}.form .input-field .hr-light.active,.form .input-field .hr-dark.active{background-color:#00caab}.form .input-field.input-sides .label{font-size:18;margin:0 0 8 0}.h1,.h2,.h3,.h4,.h5,.h6{margin-bottom:4;font-weight:normal;color:#212121}.body,.body2,.footnote{font-weight:normal;color:#757575}.h1{font-size:32}.h2{font-size:22}.h3{font-size:15}.h4{font-size:12}.h5{font-size:11}.h6{font-size:10}.body{font-size:14}.body2{font-size:17}.footnote{font-size:13}.list-group .list-group-item{color:#212121;font-size:16;margin:0;padding:16}.list-group .list-group-item Label{vertical-align:center}.list-group .list-group-item .thumb{stretch:fill;width:40;height:40;margin-right:16}.list-group .list-group-item.active{background-color:#e0e0e0}.list-group .list-group-item .list-group-item-text{color:#757575;font-size:14}.page{background-color:#fff}.progress{color:#00caab;background-color:#bababa}.segmented-bar{font-size:13;background-color:#fff;color:#212121;selected-background-color:#00caab}.sidedrawer-left,.sidedrawer-center{background-color:#fafafa}.sidedrawer-header{background-color:#fafafa;height:148;width:100%}.sidedrawer-left .sidedrawer-header{padding:16 16 0 16}.sidedrawer-center .sidedrawer-header{padding:20 15 0 15}.sidedrawer-header-image{background-color:#e0e0e0}.sidedrawer-left .sidedrawer-header-image{height:64;width:64;border-radius:32;horizontal-align:left;margin-bottom:36}.sidedrawer-center .sidedrawer-header-image{height:74;width:74;border-radius:37;horizontal-align:center;margin-bottom:24}.sidedrawer-header-brand{color:#737373}.sidedrawer-left .sidedrawer-header-brand{horizontal-align:left;font-size:14}.sidedrawer-center .sidedrawer-header-brand{horizontal-align:center;font-size:15}.sidedrawer-list-item{height:48;horizontal-align:left;width:100%;orientation:horizontal}.sidedrawer-list-item .sidedrawer-list-item-icon{width:24;text-align:center;font-size:20;height:48;vertical-align:center}.sidedrawer-list-item.active{color:#fff;background-color:#00caab}.sidedrawer-list-item.active .sidedrawer-list-item-icon{color:#fff}.sidedrawer-left .sidedrawer-list-item-icon{margin:0 16 0 16}.sidedrawer-center .sidedrawer-list-item-icon{margin:0 0 0 15}.sidedrawer-list-item-text{horizontal-align:left;text-align:left;font-size:15;background-color:transparent;border-width:0.1;width:80%;vertical-align:center}.sidedrawer-left .sidedrawer-list-item-text{padding-left:16}.sidedrawer-center .sidedrawer-list-item-text{padding-left:15}.slider{background-color:#00caab}.slider[isEnabled=false]{background-color:#e0e0e0;color:#e0e0e0}.switch[checked=true]{background-color:#00caab;color:#00caab}.switch[checked=true][isEnabled=false]{background-color:#e0e0e0;color:#fff}.switch[isEnabled=false]{background-color:#e0e0e0;color:#e0e0e0}.tab-view{selected-color:#30bcff;tabs-background-color:#fff}.tab-view .tab-view-item{background-color:#fff;tabs-background-color:#fff}#login-background{margin-top:-20;background-size:cover;background-position:center}.login-wrap{padding:0 40}.logo-wrap{margin:60 0 10 0;padding:20 0}.logo-wrap .login-logo{text-align:center;font-size:30;font-weight:bold;margin-bottom:10;opacity:1;color:#212121;opacity:.9}.logo-wrap .login-logo-sub{color:#212121;opacity:.8;text-align:center}.login-wrapper{padding:20;background-color:#fff;border-radius:3}.login-wrapper TextField{padding:10 10;margin:10 0 0 0}.go-back{font-size:14;text-align:center;color:#212121;margin-top:10}.btn{border-width:0;font-family:'SF UI Text Medium';font-size:15}.btn-outline{border-width:1}.btn-rounded-sm{border-radius:4}.btn-rounded-lg{border-radius:19}.form{font-family:'SF UI Text Regular'}.form .input{font-size:15}.form .input.input-rounded{border-radius:27}.h1{font-size:32}.slider{margin:10 15}.sidedrawer-list-item-icon,.sidedrawer-list-item{color:#949494}.switch{margin:8 15}.list-group .list-group-item{padding:16 15 16 15}.list-group .list-group-item .thumb{margin-right:15}.list-group .list-group-item .list-group-item-heading{margin-bottom:5}.segmented-bar{margin:0 15;color:#00caab}\n", ""]);



/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "../node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../node_modules/is-buffer/index.js":
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "../node_modules/isarray/index.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../node_modules/md5/md5.js":
/***/ (function(module, exports, __webpack_require__) {

(function(){
  var crypt = __webpack_require__("../node_modules/crypt/crypt.js"),
      utf8 = __webpack_require__("../node_modules/charenc/charenc.js").utf8,
      isBuffer = __webpack_require__("../node_modules/is-buffer/index.js"),
      bin = __webpack_require__("../node_modules/charenc/charenc.js").bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/hmr/hmr-update.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = () => {
    const update = __webpack_require__("../node_modules/nativescript-dev-webpack/hot.js");
    const fileSystemModule = __webpack_require__("tns-core-modules/file-system");
    const applicationFiles = fileSystemModule.knownFolders.currentApp();
    const latestHash = __webpack_require__["h"]();
    return update(latestHash, filename => applicationFiles.getFile(filename));
}

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/hmr/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports.hmrUpdate = __webpack_require__("../node_modules/nativescript-dev-webpack/hmr/hmr-update.js");

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/hot.js":
/***/ (function(module, exports, __webpack_require__) {

const hmrPrefix = 'HMR:';
const log = {
    info: (message) => console.info(`${hmrPrefix} ${message}`),
    warn: (message) => console.warn(`${hmrPrefix} ${message}`),
    error: (message) => console.error(`${hmrPrefix} ${message}`),
};
const refresh = 'Application needs to be restarted in order to apply the changes.';
const hotOptions = {
    ignoreUnaccepted: false,
    ignoreDeclined: false,
    ignoreErrored: false,
    onUnaccepted(data) {
        const chain = [].concat(data.chain);
        const last = chain[chain.length - 1];

        if (last === 0) {
            chain.pop();
        }

        log.warn(`Ignored an update to unaccepted module: `);
        chain.forEach(mod => log.warn(`         ➭ ${mod}`));
    },
    onDeclined(data) {
        log.warn(`Ignored an update to declined module:`);
        data.chain.forEach(mod => log.warn(`         ➭ ${mod}`));
    },
    onErrored(data) {
        log.warn(
            `Ignored an error while updating module ${data.moduleId} <${data.type}>`
        );
        log.warn(data.error);
    },
};

let nextHash;
let currentHash;

function upToDate() {
    return nextHash.indexOf(__webpack_require__.h()) >= 0;
}

function result(modules, appliedModules) {
    const unaccepted = modules.filter(
        (moduleId) => appliedModules && appliedModules.indexOf(moduleId) < 0
    );

    if (unaccepted.length > 0) {
        log.warn('The following modules could not be updated:');

        for (const moduleId of unaccepted) {
            log.warn(`          ⦻ ${moduleId}`);
        }
    }

    if (!(appliedModules || []).length) {
        log.info('No Modules Updated.');
    } else {
        log.info('The following modules were updated:');

        for (const moduleId of appliedModules) {
            log.info(`         ↻ ${moduleId}`);
        }

        const numberIds = appliedModules.every(
            (moduleId) => typeof moduleId === 'number'
        );
        if (numberIds) {
            log.info(
                'Please consider using the NamedModulesPlugin for module names.'
            );
        }
    }
}

function check(options) {
    return module.hot
        .check()
        .then((modules) => {
            if (!modules) {
                log.warn(
                    `Cannot find update. ${refresh}`
                );
                return null;
            }

            return module.hot
                .apply(hotOptions)
                .then((appliedModules) => {
                    let nextCheck;
                    if (!upToDate()) {
                        nextCheck = check(options);
                    }

                    result(modules, appliedModules);

                    if (upToDate()) {
                        // Do not modify message - CLI depends on this exact content to determine hmr operation status.
                        log.info(`Successfully applied update with hmr hash ${currentHash}. App is up to date.`);
                    }

                    return nextCheck || null;
                })
                .catch((err) => {
                    const status = module.hot.status();
                    if (['abort', 'fail'].indexOf(status) >= 0) {
                        // Do not modify message - CLI depends on this exact content to determine hmr operation status.
                        log.error(`Cannot apply update with hmr hash ${currentHash}.`);
                        log.error(err.message || err.stack);
                    } else {
                        log.error(`Update failed: ${err.message || err.stack}`);
                    }
                });
        })
        .catch((err) => {
            const status = module.hot.status();
            if (['abort', 'fail'].indexOf(status) >= 0) {
                log.error(`Cannot check for update. ${refresh}`);
                log.error(err.message || err.stack);
            } else {
                log.error(`Update check failed: ${err.message || err.stack}`);
            }
        });
}

if (true) {
    log.info('Hot Module Replacement Enabled. Waiting for signal.');
} else {}

function update(latestHash, options) {
    nextHash = latestHash;
    if (!upToDate()) {
        const status = module.hot.status();

        if (status === 'idle') {
            //Do not modify message - CLI depends on this exact content to determine hmr operation status.
            log.info(`Checking for updates to the bundle with hmr hash ${currentHash}.`);
            return check(options);
        } else if (['abort', 'fail'].indexOf(status) >= 0) {
            log.warn(
                `Cannot apply update. A previous update ${status}ed. ${refresh}`
            );
        }
    }
};

function getNextHash(hash, getFileContent) {
    const file = getFileContent(`${hash}.hot-update.json`);
    return file.readText().then(hotUpdateContent => {
        if (hotUpdateContent) {
            const manifest = JSON.parse(hotUpdateContent);
            const newHash = manifest.h;
            return getNextHash(newHash, getFileContent);
        } else {
            return Promise.resolve(hash);
        }
    }).catch(error => Promise.reject(error));
}

module.exports = function checkState(initialHash, getFileContent) {
    currentHash = initialHash;
    return getNextHash(initialHash, getFileContent).then(nextHash => {
        if (nextHash != initialHash) {
            return update(nextHash, {});
        }
    })
}


/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/load-application-css-angular.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const loadCss = __webpack_require__("../node_modules/nativescript-dev-webpack/load-application-css.js");

module.exports = function() {
    loadCss(function() {
        global.registerModule("./app.css", () => __webpack_require__("./app.css"));
    });
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/load-application-css.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = function (loadModuleFn) {
    const application = __webpack_require__("tns-core-modules/application");
    __webpack_require__("tns-core-modules/ui/styling/style-scope");

    loadModuleFn();

    application.loadAppCss();
}


/***/ }),

/***/ "../node_modules/nativescript-nodeify/nodeify.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// this xhr patch may move to {N} core some day and can be removed
__webpack_require__("../node_modules/tns-core-modules/xhr/xhr.js");

var xhrAddEventListenerOrig = XMLHttpRequest.prototype.addEventListener;
XMLHttpRequest.prototype.addEventListener = function(eventName, callback) {
  if (eventName === "readystatechange") {
    this.onreadystatechange = callback;
  } else if (eventName === "progress") {
    this.onprogress = callback;
  } else if (eventName === "abort") {
    this.abort = callback;
  } else if (eventName === "timeout") {
    this.ontimeout = callback;
  } else {
    xhrAddEventListenerOrig.call(this, eventName, callback);
  }
};
if (!XMLHttpRequest.prototype.upload) {
  XMLHttpRequest.prototype['upload'] = {
    addEventListener: function() {}
  };
}

// a few global properties node modules may rely on
global.process = __webpack_require__("../node_modules/process/browser.js");
global.Buffer = __webpack_require__("../node_modules/buffer/index.js").Buffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/tns-core-modules/application/application-common.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("../node_modules/tns-core-modules/globals/globals.js");
var observable_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
exports.Observable = observable_1.Observable;
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var events = new observable_1.Observable();
var launched = false;
function setLaunched() {
    launched = true;
    events.off("launch", setLaunched);
}
events.on("launch", setLaunched);
if (profiling_1.level() > 0) {
    events.on("displayed", function () {
        var duration = profiling_1.uptime();
        var end = profiling_1.time();
        var start = end - duration;
        profiling_1.trace("Displayed in " + duration.toFixed(2) + "ms", start, end);
    });
}
function hasLaunched() {
    return launched;
}
exports.hasLaunched = hasLaunched;
exports.launchEvent = "launch";
exports.suspendEvent = "suspend";
exports.displayedEvent = "displayed";
exports.resumeEvent = "resume";
exports.exitEvent = "exit";
exports.lowMemoryEvent = "lowMemory";
exports.uncaughtErrorEvent = "uncaughtError";
exports.discardedErrorEvent = "discardedError";
exports.orientationChangedEvent = "orientationChanged";
var cssFile = "./app.css";
var resources = {};
function getResources() {
    return resources;
}
exports.getResources = getResources;
function setResources(res) {
    resources = res;
}
exports.setResources = setResources;
exports.android = undefined;
exports.ios = undefined;
exports.on = events.on.bind(events);
exports.off = events.off.bind(events);
exports.notify = events.notify.bind(events);
exports.hasListeners = events.hasListeners.bind(events);
var app;
function setApplication(instance) {
    app = instance;
}
exports.setApplication = setApplication;
function livesync(rootView, context) {
    events.notify({ eventName: "livesync", object: app });
    var liveSyncCore = global.__onLiveSyncCore;
    var reapplyAppStyles = false;
    if (context && context.path) {
        var styleExtensions = ["css", "scss"];
        var appStylesFullFileName = getCssFileName();
        var appStylesFileName_1 = appStylesFullFileName.substring(0, appStylesFullFileName.lastIndexOf(".") + 1);
        reapplyAppStyles = styleExtensions.some(function (ext) { return context.path === appStylesFileName_1.concat(ext); });
    }
    if (reapplyAppStyles && rootView) {
        rootView._onCssStateChange();
    }
    else if (liveSyncCore) {
        liveSyncCore(context);
    }
}
exports.livesync = livesync;
function setCssFileName(cssFileName) {
    cssFile = cssFileName;
    events.notify({ eventName: "cssChanged", object: app, cssFile: cssFileName });
}
exports.setCssFileName = setCssFileName;
function getCssFileName() {
    return cssFile;
}
exports.getCssFileName = getCssFileName;
function loadAppCss() {
    try {
        events.notify({ eventName: "loadAppCss", object: app, cssFile: getCssFileName() });
    }
    catch (e) {
        throw new Error("The file " + getCssFileName() + " couldn't be loaded! " +
            "You may need to register it inside ./app/vendor.ts.");
    }
}
exports.loadAppCss = loadAppCss;
function addCss(cssText) {
    events.notify({ eventName: "cssChanged", object: app, cssText: cssText });
}
exports.addCss = addCss;
global.__onUncaughtError = function (error) {
    events.notify({ eventName: exports.uncaughtErrorEvent, object: app, android: error, ios: error, error: error });
};
global.__onDiscardedError = function (error) {
    events.notify({ eventName: exports.discardedErrorEvent, object: app, error: error });
};
//# sourceMappingURL=application-common.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/application/application.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var application_common_1 = __webpack_require__("../node_modules/tns-core-modules/application/application-common.js");
__export(__webpack_require__("../node_modules/tns-core-modules/application/application-common.js"));
var builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/builder.js");
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var frame_1 = __webpack_require__("../node_modules/tns-core-modules/ui/frame/frame.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var getVisibleViewController = utils_1.ios.getVisibleViewController;
var Responder = UIResponder.extend({
    get window() {
        return iosApp ? iosApp.window : undefined;
    },
    set window(setWindow) {
    }
}, {
    protocols: [UIApplicationDelegate]
});
var NotificationObserver = (function (_super) {
    __extends(NotificationObserver, _super);
    function NotificationObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NotificationObserver.initWithCallback = function (onReceiveCallback) {
        var observer = _super.new.call(this);
        observer._onReceiveCallback = onReceiveCallback;
        return observer;
    };
    NotificationObserver.prototype.onReceive = function (notification) {
        this._onReceiveCallback(notification);
    };
    NotificationObserver.ObjCExposedMethods = {
        "onReceive": { returns: interop.types.void, params: [NSNotification] }
    };
    return NotificationObserver;
}(NSObject));
var displayedOnce = false;
var displayedLinkTarget;
var displayedLink;
var CADisplayLinkTarget = (function (_super) {
    __extends(CADisplayLinkTarget, _super);
    function CADisplayLinkTarget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CADisplayLinkTarget.prototype.onDisplayed = function (link) {
        link.invalidate();
        var ios = UIApplication.sharedApplication;
        var object = iosApp;
        displayedOnce = true;
        application_common_1.notify({ eventName: application_common_1.displayedEvent, object: object, ios: ios });
        displayedLinkTarget = null;
        displayedLink = null;
    };
    CADisplayLinkTarget.ObjCExposedMethods = {
        "onDisplayed": { returns: interop.types.void, params: [CADisplayLink] }
    };
    return CADisplayLinkTarget;
}(NSObject));
var IOSApplication = (function () {
    function IOSApplication() {
        this._currentOrientation = UIDevice.currentDevice.orientation;
        this._observers = new Array();
        this.addNotificationObserver(UIApplicationDidFinishLaunchingNotification, this.didFinishLaunchingWithOptions.bind(this));
        this.addNotificationObserver(UIApplicationDidBecomeActiveNotification, this.didBecomeActive.bind(this));
        this.addNotificationObserver(UIApplicationDidEnterBackgroundNotification, this.didEnterBackground.bind(this));
        this.addNotificationObserver(UIApplicationWillTerminateNotification, this.willTerminate.bind(this));
        this.addNotificationObserver(UIApplicationDidReceiveMemoryWarningNotification, this.didReceiveMemoryWarning.bind(this));
        this.addNotificationObserver(UIDeviceOrientationDidChangeNotification, this.orientationDidChange.bind(this));
    }
    Object.defineProperty(IOSApplication.prototype, "rootController", {
        get: function () {
            return this._window.rootViewController;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IOSApplication.prototype, "nativeApp", {
        get: function () {
            return UIApplication.sharedApplication;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IOSApplication.prototype, "window", {
        get: function () {
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IOSApplication.prototype, "delegate", {
        get: function () {
            return this._delegate;
        },
        set: function (value) {
            if (this._delegate !== value) {
                this._delegate = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IOSApplication.prototype, "rootView", {
        get: function () {
            return this._rootView;
        },
        enumerable: true,
        configurable: true
    });
    IOSApplication.prototype.addNotificationObserver = function (notificationName, onReceiveCallback) {
        var observer = NotificationObserver.initWithCallback(onReceiveCallback);
        NSNotificationCenter.defaultCenter.addObserverSelectorNameObject(observer, "onReceive", notificationName, null);
        this._observers.push(observer);
        return observer;
    };
    IOSApplication.prototype.removeNotificationObserver = function (observer, notificationName) {
        var index = this._observers.indexOf(observer);
        if (index >= 0) {
            this._observers.splice(index, 1);
            NSNotificationCenter.defaultCenter.removeObserverNameObject(observer, notificationName, null);
        }
    };
    IOSApplication.prototype.didFinishLaunchingWithOptions = function (notification) {
        if (!displayedOnce) {
            displayedLinkTarget = CADisplayLinkTarget.new();
            displayedLink = CADisplayLink.displayLinkWithTargetSelector(displayedLinkTarget, "onDisplayed");
            displayedLink.addToRunLoopForMode(NSRunLoop.mainRunLoop, NSDefaultRunLoopMode);
            displayedLink.addToRunLoopForMode(NSRunLoop.mainRunLoop, UITrackingRunLoopMode);
        }
        this._window = UIWindow.alloc().initWithFrame(UIScreen.mainScreen.bounds);
        this._window.backgroundColor = UIColor.whiteColor;
        this.notifyAppStarted(notification);
    };
    IOSApplication.prototype.notifyAppStarted = function (notification) {
        var args = {
            eventName: application_common_1.launchEvent,
            object: this,
            ios: notification && notification.userInfo && notification.userInfo.objectForKey("UIApplicationLaunchOptionsLocalNotificationKey") || null
        };
        application_common_1.notify(args);
        application_common_1.notify({ eventName: "loadAppCss", object: this, cssFile: application_common_1.getCssFileName() });
        if (this._window) {
            this.setWindowContent(args.root);
        }
        else {
            this._window = UIApplication.sharedApplication.delegate.window;
        }
    };
    IOSApplication.prototype.didBecomeActive = function (notification) {
        var ios = UIApplication.sharedApplication;
        var object = this;
        application_common_1.notify({ eventName: application_common_1.resumeEvent, object: object, ios: ios });
        var rootView = this._rootView;
        if (rootView && !rootView.isLoaded) {
            rootView.callLoaded();
        }
    };
    IOSApplication.prototype.didEnterBackground = function (notification) {
        application_common_1.notify({ eventName: application_common_1.suspendEvent, object: this, ios: UIApplication.sharedApplication });
        var rootView = this._rootView;
        if (rootView && rootView.isLoaded) {
            rootView.callUnloaded();
        }
    };
    IOSApplication.prototype.willTerminate = function (notification) {
        application_common_1.notify({ eventName: application_common_1.exitEvent, object: this, ios: UIApplication.sharedApplication });
        var rootView = this._rootView;
        if (rootView && rootView.isLoaded) {
            rootView.callUnloaded();
        }
    };
    IOSApplication.prototype.didReceiveMemoryWarning = function (notification) {
        application_common_1.notify({ eventName: application_common_1.lowMemoryEvent, object: this, ios: UIApplication.sharedApplication });
    };
    IOSApplication.prototype.orientationDidChange = function (notification) {
        var orientation = UIDevice.currentDevice.orientation;
        if (this._currentOrientation !== orientation) {
            this._currentOrientation = orientation;
            var newValue = void 0;
            switch (orientation) {
                case 4:
                case 3:
                    newValue = "landscape";
                    break;
                case 1:
                case 2:
                    newValue = "portrait";
                    break;
                default:
                    newValue = "unknown";
                    break;
            }
            application_common_1.notify({
                eventName: application_common_1.orientationChangedEvent,
                ios: this,
                newValue: newValue,
                object: this
            });
        }
    };
    IOSApplication.prototype._onLivesync = function (context) {
        var isAppRootModuleChanged = context && context.path && context.path.includes(getMainEntry().moduleName) && context.type !== "style";
        if (isAppRootModuleChanged || (this._rootView && !this._rootView._onLivesync(context))) {
            this.setWindowContent();
        }
    };
    IOSApplication.prototype.setWindowContent = function (view) {
        if (this._rootView) {
            this._rootView._onRootViewReset();
        }
        var rootView = createRootView(view);
        var controller = getViewController(rootView);
        this._rootView = rootView;
        if (createRootFrame.value) {
            rootView._setupUI({});
        }
        else {
            rootView._setupAsRootView({});
        }
        setViewControllerView(rootView);
        var haveController = this._window.rootViewController !== null;
        this._window.rootViewController = controller;
        if (!haveController) {
            this._window.makeKeyAndVisible();
        }
    };
    __decorate([
        profiling_1.profile
    ], IOSApplication.prototype, "didFinishLaunchingWithOptions", null);
    __decorate([
        profiling_1.profile
    ], IOSApplication.prototype, "didBecomeActive", null);
    return IOSApplication;
}());
var iosApp = new IOSApplication();
exports.ios = iosApp;
application_common_1.setApplication(iosApp);
global.__onLiveSyncCore = function (context) {
    iosApp._onLivesync(context);
};
var mainEntry;
function createRootView(v) {
    var rootView = v;
    if (!rootView) {
        if (!mainEntry) {
            throw new Error("Main entry is missing. App cannot be started. Verify app bootstrap.");
        }
        else {
            if (createRootFrame.value) {
                var frame = rootView = new frame_1.Frame();
                frame.navigate(mainEntry);
            }
            else {
                rootView = builder_1.createViewFromEntry(mainEntry);
            }
        }
    }
    return rootView;
}
function getMainEntry() {
    return mainEntry;
}
exports.getMainEntry = getMainEntry;
function getRootView() {
    return iosApp.rootView;
}
exports.getRootView = getRootView;
var createRootFrame = { value: true };
var started = false;
function _start(entry) {
    mainEntry = typeof entry === "string" ? { moduleName: entry } : entry;
    started = true;
    if (!iosApp.nativeApp) {
        UIApplicationMain(0, null, null, iosApp && iosApp.delegate ? NSStringFromClass(iosApp.delegate) : NSStringFromClass(Responder));
    }
    else {
        var rootView = createRootView();
        if (rootView) {
            var window_1 = iosApp.nativeApp.keyWindow || (iosApp.nativeApp.windows.count > 0 && iosApp.nativeApp.windows[0]);
            if (window_1) {
                var rootController = window_1.rootViewController;
                if (rootController) {
                    var controller = getViewController(rootView);
                    rootView._setupAsRootView({});
                    var embedderDelegate = NativeScriptEmbedder.sharedInstance().delegate;
                    if (embedderDelegate) {
                        embedderDelegate.presentNativeScriptApp(controller);
                    }
                    else {
                        var visibleVC = getVisibleViewController(rootController);
                        visibleVC.presentViewControllerAnimatedCompletion(controller, true, null);
                    }
                    iosApp.notifyAppStarted();
                }
            }
        }
    }
}
function start(entry) {
    console.log("application.start() is deprecated; use application.run() instead");
    _start(entry);
}
exports.start = start;
function run(entry) {
    createRootFrame.value = false;
    _start(entry);
}
exports.run = run;
function _resetRootView(entry) {
    createRootFrame.value = false;
    mainEntry = typeof entry === "string" ? { moduleName: entry } : entry;
    iosApp.setWindowContent();
}
exports._resetRootView = _resetRootView;
function getNativeApplication() {
    return iosApp.nativeApp;
}
exports.getNativeApplication = getNativeApplication;
function getViewController(view) {
    var viewController = view.viewController || view.ios;
    if (viewController instanceof UIViewController) {
        return viewController;
    }
    else {
        viewController = view_1.ios.UILayoutViewController.initWithOwner(new WeakRef(view));
        view.viewController = viewController;
        return viewController;
    }
}
function setViewControllerView(view) {
    var viewController = view.viewController || view.ios;
    var nativeView = view.ios || view.nativeViewProtected;
    if (!nativeView || !viewController) {
        throw new Error("Root should be either UIViewController or UIView");
    }
    if (viewController instanceof view_1.ios.UILayoutViewController) {
        viewController.view.addSubview(nativeView);
    }
}
global.__onLiveSync = function __onLiveSync(context) {
    if (!started) {
        return;
    }
    var rootView = getRootView();
    application_common_1.livesync(rootView, context);
};
//# sourceMappingURL=application.ios.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/color/color-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var knownColors = __webpack_require__("../node_modules/tns-core-modules/color/known-colors.js");
var SHARP = "#";
var HEX_REGEX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i;
var Color = (function () {
    function Color() {
        if (arguments.length === 1) {
            var arg = arguments[0];
            if (types.isString(arg)) {
                if (isRgbOrRgba(arg)) {
                    this._argb = argbFromRgbOrRgba(arg);
                }
                else if (knownColors.isKnownName(arg)) {
                    var hex = knownColors.getKnownColor(arg);
                    this._name = arg;
                    this._argb = this._argbFromString(hex);
                }
                else if (HEX_REGEX.test(arg)) {
                    var hex = this._normalizeHex(arg);
                    this._argb = this._argbFromString(hex);
                }
                else {
                    throw new Error("Invalid color: " + arg);
                }
            }
            else if (types.isNumber(arg)) {
                this._argb = arg >>> 0;
            }
            else {
                throw new Error("Expected 1 or 4 constructor parameters.");
            }
        }
        else if (arguments.length === 4) {
            this._argb = (arguments[0] & 0xFF) * 0x01000000
                + (arguments[1] & 0xFF) * 0x00010000
                + (arguments[2] & 0xFF) * 0x00000100
                + (arguments[3] & 0xFF) * 0x00000001;
        }
        else {
            throw new Error("Expected 1 or 4 constructor parameters.");
        }
    }
    Object.defineProperty(Color.prototype, "a", {
        get: function () { return (this._argb / 0x01000000) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "r", {
        get: function () { return (this._argb / 0x00010000) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        get: function () { return (this._argb / 0x00000100) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        get: function () { return (this._argb / 0x00000001) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "argb", {
        get: function () {
            return this._argb;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hex", {
        get: function () {
            if (this.a === 0xFF) {
                return ("#" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b)).toUpperCase();
            }
            else {
                return ("#" + this._componentToHex(this.a) + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b)).toUpperCase();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "ios", {
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "android", {
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Color.prototype._argbFromString = function (hex) {
        if (hex.charAt(0) === "#") {
            hex = hex.substr(1);
        }
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        else if (hex.length === 4) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
        }
        var intVal = parseInt(hex, 16);
        if (hex.length === 6) {
            intVal = (intVal & 0x00FFFFFF) + 0xFF000000;
        }
        return intVal;
    };
    Color.prototype.equals = function (value) {
        return value && this.argb === value.argb;
    };
    Color.equals = function (value1, value2) {
        if (!value1 && !value2) {
            return true;
        }
        if (!value1 || !value2) {
            return false;
        }
        return value1.equals(value2);
    };
    Color.isValid = function (value) {
        if (types.isNullOrUndefined(value) || value instanceof Color) {
            return true;
        }
        if (!types.isString(value)) {
            return false;
        }
        if (knownColors.isKnownName(value)) {
            return true;
        }
        return HEX_REGEX.test(value) || isRgbOrRgba(value);
    };
    Color.prototype._componentToHex = function (component) {
        var hex = component.toString(16);
        if (hex.length === 1) {
            hex = "0" + hex;
        }
        return hex;
    };
    Color.prototype._normalizeHex = function (hexStr) {
        if (hexStr.charAt(0) === SHARP && hexStr.length === 4) {
            hexStr = hexStr.charAt(0)
                + hexStr.charAt(1) + hexStr.charAt(1)
                + hexStr.charAt(2) + hexStr.charAt(2)
                + hexStr.charAt(3) + hexStr.charAt(3);
        }
        return hexStr;
    };
    Color.prototype.toString = function () {
        return this.hex;
    };
    return Color;
}());
exports.Color = Color;
function isRgbOrRgba(value) {
    var toLower = value.toLowerCase();
    return (toLower.indexOf("rgb(") === 0 || toLower.indexOf("rgba(") === 0) && toLower.indexOf(")") === (toLower.length - 1);
}
function argbFromRgbOrRgba(value) {
    var toLower = value.toLowerCase();
    var parts = toLower.replace("rgba(", "").replace("rgb(", "").replace(")", "").trim().split(",");
    var r = 255;
    var g = 255;
    var b = 255;
    var a = 255;
    if (parts[0]) {
        r = parseInt(parts[0].trim());
    }
    if (parts[1]) {
        g = parseInt(parts[1].trim());
    }
    if (parts[2]) {
        b = parseInt(parts[2].trim());
    }
    if (parts[3]) {
        a = Math.round(parseFloat(parts[3].trim()) * 255);
    }
    return (a & 0xFF) * 0x01000000
        + (r & 0xFF) * 0x00010000
        + (g & 0xFF) * 0x00000100
        + (b & 0xFF) * 0x00000001;
}
//# sourceMappingURL=color-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/color/color.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var common = __webpack_require__("../node_modules/tns-core-modules/color/color-common.js");
var Color = (function (_super) {
    __extends(Color, _super);
    function Color() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Color.prototype, "ios", {
        get: function () {
            if (!this._ios) {
                this._ios = UIColor.alloc().initWithRedGreenBlueAlpha(this.r / 255, this.g / 255, this.b / 255, this.a / 255);
            }
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    return Color;
}(common.Color));
exports.Color = Color;
//# sourceMappingURL=color.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/color/known-colors.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transparent = "#00000000";
exports.AliceBlue = "#F0F8FF";
exports.AntiqueWhite = "#FAEBD7";
exports.Aqua = "#00FFFF";
exports.Aquamarine = "#7FFFD4";
exports.Azure = "#F0FFFF";
exports.Beige = "#F5F5DC";
exports.Bisque = "#FFE4C4";
exports.Black = "#000000";
exports.BlanchedAlmond = "#FFEBCD";
exports.Blue = "#0000FF";
exports.BlueViolet = "#8A2BE2";
exports.Brown = "#A52A2A";
exports.BurlyWood = "#DEB887";
exports.CadetBlue = "#5F9EA0";
exports.Chartreuse = "#7FFF00";
exports.Chocolate = "#D2691E";
exports.Coral = "#FF7F50";
exports.CornflowerBlue = "#6495ED";
exports.Cornsilk = "#FFF8DC";
exports.Crimson = "#DC143C";
exports.Cyan = "#00FFFF";
exports.DarkBlue = "#00008B";
exports.DarkCyan = "#008B8B";
exports.DarkGoldenRod = "#B8860B";
exports.DarkGray = "#A9A9A9";
exports.DarkGreen = "#006400";
exports.DarkKhaki = "#BDB76B";
exports.DarkMagenta = "#8B008B";
exports.DarkOliveGreen = "#556B2F";
exports.DarkOrange = "#FF8C00";
exports.DarkOrchid = "#9932CC";
exports.DarkRed = "#8B0000";
exports.DarkSalmon = "#E9967A";
exports.DarkSeaGreen = "#8FBC8F";
exports.DarkSlateBlue = "#483D8B";
exports.DarkSlateGray = "#2F4F4F";
exports.DarkTurquoise = "#00CED1";
exports.DarkViolet = "#9400D3";
exports.DeepPink = "#FF1493";
exports.DeepSkyBlue = "#00BFFF";
exports.DimGray = "#696969";
exports.DodgerBlue = "#1E90FF";
exports.FireBrick = "#B22222";
exports.FloralWhite = "#FFFAF0";
exports.ForestGreen = "#228B22";
exports.Fuchsia = "#FF00FF";
exports.Gainsboro = "#DCDCDC";
exports.GhostWhite = "#F8F8FF";
exports.Gold = "#FFD700";
exports.GoldenRod = "#DAA520";
exports.Gray = "#808080";
exports.Green = "#008000";
exports.GreenYellow = "#ADFF2F";
exports.HoneyDew = "#F0FFF0";
exports.HotPink = "#FF69B4";
exports.IndianRed = "#CD5C5C";
exports.Indigo = "#4B0082";
exports.Ivory = "#FFFFF0";
exports.Khaki = "#F0E68C";
exports.Lavender = "#E6E6FA";
exports.LavenderBlush = "#FFF0F5";
exports.LawnGreen = "#7CFC00";
exports.LemonChiffon = "#FFFACD";
exports.LightBlue = "#ADD8E6";
exports.LightCoral = "#F08080";
exports.LightCyan = "#E0FFFF";
exports.LightGoldenRodYellow = "#FAFAD2";
exports.LightGray = "#D3D3D3";
exports.LightGreen = "#90EE90";
exports.LightPink = "#FFB6C1";
exports.LightSalmon = "#FFA07A";
exports.LightSeaGreen = "#20B2AA";
exports.LightSkyBlue = "#87CEFA";
exports.LightSlateGray = "#778899";
exports.LightSteelBlue = "#B0C4DE";
exports.LightYellow = "#FFFFE0";
exports.Lime = "#00FF00";
exports.LimeGreen = "#32CD32";
exports.Linen = "#FAF0E6";
exports.Magenta = "#FF00FF";
exports.Maroon = "#800000";
exports.MediumAquaMarine = "#66CDAA";
exports.MediumBlue = "#0000CD";
exports.MediumOrchid = "#BA55D3";
exports.MediumPurple = "#9370DB";
exports.MediumSeaGreen = "#3CB371";
exports.MediumSlateBlue = "#7B68EE";
exports.MediumSpringGreen = "#00FA9A";
exports.MediumTurquoise = "#48D1CC";
exports.MediumVioletRed = "#C71585";
exports.MidnightBlue = "#191970";
exports.MintCream = "#F5FFFA";
exports.MistyRose = "#FFE4E1";
exports.Moccasin = "#FFE4B5";
exports.NavajoWhite = "#FFDEAD";
exports.Navy = "#000080";
exports.OldLace = "#FDF5E6";
exports.Olive = "#808000";
exports.OliveDrab = "#6B8E23";
exports.Orange = "#FFA500";
exports.OrangeRed = "#FF4500";
exports.Orchid = "#DA70D6";
exports.PaleGoldenRod = "#EEE8AA";
exports.PaleGreen = "#98FB98";
exports.PaleTurquoise = "#AFEEEE";
exports.PaleVioletRed = "#DB7093";
exports.PapayaWhip = "#FFEFD5";
exports.PeachPuff = "#FFDAB9";
exports.Peru = "#CD853F";
exports.Pink = "#FFC0CB";
exports.Plum = "#DDA0DD";
exports.PowderBlue = "#B0E0E6";
exports.Purple = "#800080";
exports.RebeccaPurple = "#663399";
exports.Red = "#FF0000";
exports.RosyBrown = "#BC8F8F";
exports.RoyalBlue = "#4169E1";
exports.SaddleBrown = "#8B4513";
exports.Salmon = "#FA8072";
exports.SandyBrown = "#F4A460";
exports.SeaGreen = "#2E8B57";
exports.SeaShell = "#FFF5EE";
exports.Sienna = "#A0522D";
exports.Silver = "#C0C0C0";
exports.SkyBlue = "#87CEEB";
exports.SlateBlue = "#6A5ACD";
exports.SlateGray = "#708090";
exports.Snow = "#FFFAFA";
exports.SpringGreen = "#00FF7F";
exports.SteelBlue = "#4682B4";
exports.Tan = "#D2B48C";
exports.Teal = "#008080";
exports.Thistle = "#D8BFD8";
exports.Tomato = "#FF6347";
exports.Turquoise = "#40E0D0";
exports.Violet = "#EE82EE";
exports.Wheat = "#F5DEB3";
exports.White = "#FFFFFF";
exports.WhiteSmoke = "#F5F5F5";
exports.Yellow = "#FFFF00";
exports.YellowGreen = "#9ACD32";
var _allColors = {};
(function () {
    var name;
    var underscore = "_";
    for (var p in exports) {
        name = p;
        if (name.charAt(0) !== underscore) {
            _allColors[name.toLowerCase()] = exports[p];
        }
    }
})();
function isKnownName(name) {
    if (!name) {
        return undefined;
    }
    return name.toLowerCase() in _allColors;
}
exports.isKnownName = isKnownName;
function getKnownColor(name) {
    if (!name) {
        return undefined;
    }
    return _allColors[name.toLowerCase()];
}
exports.getKnownColor = getKnownColor;
//# sourceMappingURL=known-colors.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/console/console.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Console = (function () {
    function Console() {
    }
    Console.prototype.time = function (reportName) {
    };
    Console.prototype.timeEnd = function (reportName) {
    };
    Console.prototype.assert = function (test, message) {
    };
    Console.prototype.info = function (message) {
    };
    Console.prototype.warn = function (message) {
    };
    Console.prototype.error = function (message) {
    };
    Console.prototype.log = function (message) {
    };
    Console.prototype.trace = function () {
    };
    Console.prototype.dir = function (obj) {
    };
    return Console;
}());
exports.Console = Console;
//# sourceMappingURL=console.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/css-value/index.js":
/***/ (function(module, exports) {


exports.parse = parse;

function parse(str) {
  return new Parser(str).parse();
}

function Parser(str) {
  this.str = str;
}

Parser.prototype.skip = function(m){
  this.str = this.str.slice(m[0].length);
};

Parser.prototype.comma = function(){
  var m = /^, */.exec(this.str);
  if (!m) return;
  this.skip(m);
  return { type: 'comma', string: ',' };
};

Parser.prototype.ident = function(){
  var m = /^([\w-]+) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  return {
    type: 'ident',
    string: m[1]
  }
};

Parser.prototype.int = function(){
  var m = /^(([-\+]?\d+)(\S+)?) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  var n = ~~m[2];
  var u = m[3];

  return {
    type: 'number',
    string: m[1],
    unit: u || '',
    value: n
  }
};

Parser.prototype.float = function(){
  var m = /^(((?:[-\+]?\d+)?\.\d+)(\S+)?) */.exec(this.str);
  if (!m) return;
  this.skip(m);
  var n = parseFloat(m[2]);
  var u = m[3];

  return {
    type: 'number',
    string: m[1],
    unit: u || '',
    value: n
  }
};

Parser.prototype.number = function(){
  return this.float() || this.int();
};

Parser.prototype.double = function(){
  var m = /^"([^"]*)" */.exec(this.str);
  if (!m) return m;
  this.skip(m);
  return {
    type: 'string',
    quote: '"',
    string: '"' + m[1] + '"',
    value: m[1]
  }
};

Parser.prototype.single = function(){
  var m = /^'([^']*)' */.exec(this.str);
  if (!m) return m;
  this.skip(m);
  return {
    type: 'string',
    quote: "'",
    string: "'" + m[1] + "'",
    value: m[1]
  }
};

Parser.prototype.string = function(){
  return this.single() || this.double();
};


Parser.prototype.value = function(){
  return this.number()
    || this.ident()
    || this.string()
    || this.comma();
};

Parser.prototype.parse = function(){
  var vals = [];

  while (this.str.length) {
    var obj = this.value();
    if (!obj) throw new Error('failed to parse near `' + this.str.slice(0, 10) + '...`');
    vals.push(obj);
  }

  return vals;
};


/***/ }),

/***/ "../node_modules/tns-core-modules/css/index.js":
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__("../node_modules/tns-core-modules/css/lib/parse/index.js");


/***/ }),

/***/ "../node_modules/tns-core-modules/css/lib/parse/index.js":
/***/ (function(module, exports) {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g

module.exports = function(css, options){
  options = options || {};

  /**
   * Positional.
   */

  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    var lines = str.match(/\n/g);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf('\n');
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   */

  function position() {
    var start = { line: lineno, column: column };
    return function(node){
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node
   */

  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string
   */

  Position.prototype.content = css;

  /**
   * Error `msg`.
   */

  var errorsList = [];

  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Parse stylesheet.
   */

  function stylesheet() {
    var rulesList = rules();

    return {
      type: 'stylesheet',
      stylesheet: {
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }

  /**
   * Opening brace.
   */

  function open() {
    return match(/^{\s*/);
  }

  /**
   * Closing brace.
   */

  function close() {
    return match(/^}/);
  }

  /**
   * Parse ruleset.
   */

  function rules() {
    var node;
    var rules = [];
    whitespace();
    comments(rules);
    while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
      if (node !== false) {
        rules.push(node);
        comments(rules);
      }
    }
    return rules;
  }

  /**
   * Match `re` and return captures.
   */

  function match(re) {
    var m = re.exec(css);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */

  function whitespace() {
    match(/^\s*/);
  }

  /**
   * Parse comments;
   */

  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   */

  function comment() {
    var pos = position();
    if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;

    var i = 2;
    while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
    i += 2;

    if ("" === css.charAt(i-1)) {
      return error('End of comment missing');
    }

    var str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;

    return pos({
      type: 'comment',
      comment: str
    });
  }

  /**
   * Parse selector.
   */

  function selector() {
    var m = match(/^([^{]+)/);
    if (!m) return;
    /* @fix Remove all comments from selectors
     * http://ostermiller.org/findcomment.html */
    return trim(m[0])
      .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
      .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m) {
        return m.replace(/,/g, '\u200C');
      })
      .split(/\s*(?![^(]*\)),\s*/)
      .map(function(s) {
        return s.replace(/\u200C/g, ',');
      });
  }

  /**
   * Parse declaration.
   */

  function declaration() {
    var pos = position();

    // prop
    var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop) return;
    prop = trim(prop[0]);

    // :
    if (!match(/^:\s*/)) return error("property missing ':'");

    // val
    var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);

    var ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    });

    // ;
    match(/^[;\s]*/);

    return ret;
  }

  /**
   * Parse declarations.
   */

  function declarations() {
    var decls = [];

    if (!open()) return error("missing '{'");
    comments(decls);

    // declarations
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) return error("missing '}'");
    return decls;
  }

  /**
   * Parse keyframe.
   */

  function keyframe() {
    var m;
    var vals = [];
    var pos = position();

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) return;

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }

  /**
   * Parse keyframes.
   */

  function atkeyframes() {
    var pos = position();
    var m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) return;
    var vendor = m[1];

    // identifier
    var m = match(/^([-\w]+)\s*/);
    if (!m) return error("@keyframes missing name");
    var name = m[1];

    if (!open()) return error("@keyframes missing '{'");

    var frame;
    var frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) return error("@keyframes missing '}'");

    return pos({
      type: 'keyframes',
      name: name,
      vendor: vendor,
      keyframes: frames
    });
  }

  /**
   * Parse supports.
   */

  function atsupports() {
    var pos = position();
    var m = match(/^@supports *([^{]+)/);

    if (!m) return;
    var supports = trim(m[1]);

    if (!open()) return error("@supports missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@supports missing '}'");

    return pos({
      type: 'supports',
      supports: supports,
      rules: style
    });
  }

  /**
   * Parse host.
   */

  function athost() {
    var pos = position();
    var m = match(/^@host\s*/);

    if (!m) return;

    if (!open()) return error("@host missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@host missing '}'");

    return pos({
      type: 'host',
      rules: style
    });
  }

  /**
   * Parse media.
   */

  function atmedia() {
    var pos = position();
    var m = match(/^@media *([^{]+)/);

    if (!m) return;
    var media = trim(m[1]);

    if (!open()) return error("@media missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@media missing '}'");

    return pos({
      type: 'media',
      media: media,
      rules: style
    });
  }


  /**
   * Parse custom-media.
   */

  function atcustommedia() {
    var pos = position();
    var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (!m) return;

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }

  /**
   * Parse paged media.
   */

  function atpage() {
    var pos = position();
    var m = match(/^@page */);
    if (!m) return;

    var sel = selector() || [];

    if (!open()) return error("@page missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@page missing '}'");

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }

  /**
   * Parse document.
   */

  function atdocument() {
    var pos = position();
    var m = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m) return;

    var vendor = trim(m[1]);
    var doc = trim(m[2]);

    if (!open()) return error("@document missing '{'");

    var style = comments().concat(rules());

    if (!close()) return error("@document missing '}'");

    return pos({
      type: 'document',
      document: doc,
      vendor: vendor,
      rules: style
    });
  }

  /**
   * Parse font-face.
   */

  function atfontface() {
    var pos = position();
    var m = match(/^@font-face\s*/);
    if (!m) return;

    if (!open()) return error("@font-face missing '{'");
    var decls = comments();

    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) return error("@font-face missing '}'");

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }

  /**
   * Parse import
   */

  var atimport = _compileAtrule('import');

  /**
   * Parse charset
   */

  var atcharset = _compileAtrule('charset');

  /**
   * Parse namespace
   */

  var atnamespace = _compileAtrule('namespace');

  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    var re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function() {
      var pos = position();
      var m = match(re);
      if (!m) return;
      var ret = { type: name };
      ret[name] = m[1].trim();
      return pos(ret);
    }
  }

  /**
   * Parse at rule.
   */

  function atrule() {
    if (css[0] != '@') return;

    return atkeyframes()
      || atmedia()
      || atcustommedia()
      || atsupports()
      || atimport()
      || atcharset()
      || atnamespace()
      || atdocument()
      || atpage()
      || athost()
      || atfontface();
  }

  /**
   * Parse rule.
   */

  function rule() {
    var pos = position();
    var sel = selector();

    if (!sel) return error('selector missing');
    comments();

    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
};

/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}

/**
 * Adds non-enumerable parent node reference to each node.
 */

function addParent(obj, parent) {
  var isNode = obj && typeof obj.type === 'string';
  var childParent = isNode ? obj : parent;

  for (var k in obj) {
    var value = obj[k];
    if (Array.isArray(value)) {
      value.forEach(function(v) { addParent(v, childParent); });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}


/***/ }),

/***/ "../node_modules/tns-core-modules/css/parser.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var urlRegEx = /\s*url\((?:('|")([^\1]*)\1|([^\)]*))\)\s*/gy;
function parseURL(text, start) {
    if (start === void 0) { start = 0; }
    urlRegEx.lastIndex = start;
    var result = urlRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = urlRegEx.lastIndex;
    var value = result[2] || result[3];
    return { start: start, end: end, value: value };
}
exports.parseURL = parseURL;
var hexColorRegEx = /\s*#((?:[0-9A-F]{8})|(?:[0-9A-F]{6})|(?:[0-9A-F]{3}))\s*/giy;
function parseHexColor(text, start) {
    if (start === void 0) { start = 0; }
    hexColorRegEx.lastIndex = start;
    var result = hexColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = hexColorRegEx.lastIndex;
    var hex = result[1];
    var argb;
    if (hex.length === 8) {
        argb = parseInt("0x" + hex);
    }
    else if (hex.length === 6) {
        argb = parseInt("0xFF" + hex);
    }
    else if (hex.length === 3) {
        argb = parseInt("0xFF" + hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]);
    }
    return { start: start, end: end, value: argb };
}
exports.parseHexColor = parseHexColor;
function rgbaToArgbNumber(r, g, b, a) {
    if (a === void 0) { a = 1; }
    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
        return (Math.round(a * 0xFF) * 0x01000000) + (r * 0x010000) + (g * 0x000100) + (b * 0x000001);
    }
    else {
        return null;
    }
}
var rgbColorRegEx = /\s*(rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\))/gy;
function parseRGBColor(text, start) {
    if (start === void 0) { start = 0; }
    rgbColorRegEx.lastIndex = start;
    var result = rgbColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = rgbColorRegEx.lastIndex;
    var value = result[1] && rgbaToArgbNumber(parseInt(result[2]), parseInt(result[3]), parseInt(result[4]));
    return { start: start, end: end, value: value };
}
exports.parseRGBColor = parseRGBColor;
var rgbaColorRegEx = /\s*(rgba\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*,\s*([01]?\.?\d*)\s*\))/gy;
function parseRGBAColor(text, start) {
    if (start === void 0) { start = 0; }
    rgbaColorRegEx.lastIndex = start;
    var result = rgbaColorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = rgbaColorRegEx.lastIndex;
    var value = rgbaToArgbNumber(parseInt(result[2]), parseInt(result[3]), parseInt(result[4]), parseFloat(result[5]));
    return { start: start, end: end, value: value };
}
exports.parseRGBAColor = parseRGBAColor;
var colors;
(function (colors) {
    colors[colors["transparent"] = 0] = "transparent";
    colors[colors["aliceblue"] = 4293982463] = "aliceblue";
    colors[colors["antiquewhite"] = 4294634455] = "antiquewhite";
    colors[colors["aqua"] = 4278255615] = "aqua";
    colors[colors["aquamarine"] = 4286578644] = "aquamarine";
    colors[colors["azure"] = 4293984255] = "azure";
    colors[colors["beige"] = 4294309340] = "beige";
    colors[colors["bisque"] = 4294960324] = "bisque";
    colors[colors["black"] = 4278190080] = "black";
    colors[colors["blanchedalmond"] = 4294962125] = "blanchedalmond";
    colors[colors["blue"] = 4278190335] = "blue";
    colors[colors["blueviolet"] = 4287245282] = "blueviolet";
    colors[colors["brown"] = 4289014314] = "brown";
    colors[colors["burlywood"] = 4292786311] = "burlywood";
    colors[colors["cadetblue"] = 4284456608] = "cadetblue";
    colors[colors["chartreuse"] = 4286578432] = "chartreuse";
    colors[colors["chocolate"] = 4291979550] = "chocolate";
    colors[colors["coral"] = 4294934352] = "coral";
    colors[colors["cornflowerblue"] = 4284782061] = "cornflowerblue";
    colors[colors["cornsilk"] = 4294965468] = "cornsilk";
    colors[colors["crimson"] = 4292613180] = "crimson";
    colors[colors["cyan"] = 4278255615] = "cyan";
    colors[colors["darkblue"] = 4278190219] = "darkblue";
    colors[colors["darkcyan"] = 4278225803] = "darkcyan";
    colors[colors["darkgoldenrod"] = 4290283019] = "darkgoldenrod";
    colors[colors["darkgray"] = 4289309097] = "darkgray";
    colors[colors["darkgreen"] = 4278215680] = "darkgreen";
    colors[colors["darkgrey"] = 4289309097] = "darkgrey";
    colors[colors["darkkhaki"] = 4290623339] = "darkkhaki";
    colors[colors["darkmagenta"] = 4287299723] = "darkmagenta";
    colors[colors["darkolivegreen"] = 4283788079] = "darkolivegreen";
    colors[colors["darkorange"] = 4294937600] = "darkorange";
    colors[colors["darkorchid"] = 4288230092] = "darkorchid";
    colors[colors["darkred"] = 4287299584] = "darkred";
    colors[colors["darksalmon"] = 4293498490] = "darksalmon";
    colors[colors["darkseagreen"] = 4287609999] = "darkseagreen";
    colors[colors["darkslateblue"] = 4282924427] = "darkslateblue";
    colors[colors["darkslategray"] = 4281290575] = "darkslategray";
    colors[colors["darkslategrey"] = 4281290575] = "darkslategrey";
    colors[colors["darkturquoise"] = 4278243025] = "darkturquoise";
    colors[colors["darkviolet"] = 4287889619] = "darkviolet";
    colors[colors["deeppink"] = 4294907027] = "deeppink";
    colors[colors["deepskyblue"] = 4278239231] = "deepskyblue";
    colors[colors["dimgray"] = 4285098345] = "dimgray";
    colors[colors["dimgrey"] = 4285098345] = "dimgrey";
    colors[colors["dodgerblue"] = 4280193279] = "dodgerblue";
    colors[colors["firebrick"] = 4289864226] = "firebrick";
    colors[colors["floralwhite"] = 4294966000] = "floralwhite";
    colors[colors["forestgreen"] = 4280453922] = "forestgreen";
    colors[colors["fuchsia"] = 4294902015] = "fuchsia";
    colors[colors["gainsboro"] = 4292664540] = "gainsboro";
    colors[colors["ghostwhite"] = 4294506751] = "ghostwhite";
    colors[colors["gold"] = 4294956800] = "gold";
    colors[colors["goldenrod"] = 4292519200] = "goldenrod";
    colors[colors["gray"] = 4286611584] = "gray";
    colors[colors["green"] = 4278222848] = "green";
    colors[colors["greenyellow"] = 4289593135] = "greenyellow";
    colors[colors["grey"] = 4286611584] = "grey";
    colors[colors["honeydew"] = 4293984240] = "honeydew";
    colors[colors["hotpink"] = 4294928820] = "hotpink";
    colors[colors["indianred"] = 4291648604] = "indianred";
    colors[colors["indigo"] = 4283105410] = "indigo";
    colors[colors["ivory"] = 4294967280] = "ivory";
    colors[colors["khaki"] = 4293977740] = "khaki";
    colors[colors["lavender"] = 4293322490] = "lavender";
    colors[colors["lavenderblush"] = 4294963445] = "lavenderblush";
    colors[colors["lawngreen"] = 4286381056] = "lawngreen";
    colors[colors["lemonchiffon"] = 4294965965] = "lemonchiffon";
    colors[colors["lightblue"] = 4289583334] = "lightblue";
    colors[colors["lightcoral"] = 4293951616] = "lightcoral";
    colors[colors["lightcyan"] = 4292935679] = "lightcyan";
    colors[colors["lightgoldenrodyellow"] = 4294638290] = "lightgoldenrodyellow";
    colors[colors["lightgray"] = 4292072403] = "lightgray";
    colors[colors["lightgreen"] = 4287688336] = "lightgreen";
    colors[colors["lightgrey"] = 4292072403] = "lightgrey";
    colors[colors["lightpink"] = 4294948545] = "lightpink";
    colors[colors["lightsalmon"] = 4294942842] = "lightsalmon";
    colors[colors["lightseagreen"] = 4280332970] = "lightseagreen";
    colors[colors["lightskyblue"] = 4287090426] = "lightskyblue";
    colors[colors["lightslategray"] = 4286023833] = "lightslategray";
    colors[colors["lightslategrey"] = 4286023833] = "lightslategrey";
    colors[colors["lightsteelblue"] = 4289774814] = "lightsteelblue";
    colors[colors["lightyellow"] = 4294967264] = "lightyellow";
    colors[colors["lime"] = 4278255360] = "lime";
    colors[colors["limegreen"] = 4281519410] = "limegreen";
    colors[colors["linen"] = 4294635750] = "linen";
    colors[colors["magenta"] = 4294902015] = "magenta";
    colors[colors["maroon"] = 4286578688] = "maroon";
    colors[colors["mediumaquamarine"] = 4284927402] = "mediumaquamarine";
    colors[colors["mediumblue"] = 4278190285] = "mediumblue";
    colors[colors["mediumorchid"] = 4290401747] = "mediumorchid";
    colors[colors["mediumpurple"] = 4287852763] = "mediumpurple";
    colors[colors["mediumseagreen"] = 4282168177] = "mediumseagreen";
    colors[colors["mediumslateblue"] = 4286277870] = "mediumslateblue";
    colors[colors["mediumspringgreen"] = 4278254234] = "mediumspringgreen";
    colors[colors["mediumturquoise"] = 4282962380] = "mediumturquoise";
    colors[colors["mediumvioletred"] = 4291237253] = "mediumvioletred";
    colors[colors["midnightblue"] = 4279834992] = "midnightblue";
    colors[colors["mintcream"] = 4294311930] = "mintcream";
    colors[colors["mistyrose"] = 4294960353] = "mistyrose";
    colors[colors["moccasin"] = 4294960309] = "moccasin";
    colors[colors["navajowhite"] = 4294958765] = "navajowhite";
    colors[colors["navy"] = 4278190208] = "navy";
    colors[colors["oldlace"] = 4294833638] = "oldlace";
    colors[colors["olive"] = 4286611456] = "olive";
    colors[colors["olivedrab"] = 4285238819] = "olivedrab";
    colors[colors["orange"] = 4294944000] = "orange";
    colors[colors["orangered"] = 4294919424] = "orangered";
    colors[colors["orchid"] = 4292505814] = "orchid";
    colors[colors["palegoldenrod"] = 4293847210] = "palegoldenrod";
    colors[colors["palegreen"] = 4288215960] = "palegreen";
    colors[colors["paleturquoise"] = 4289720046] = "paleturquoise";
    colors[colors["palevioletred"] = 4292571283] = "palevioletred";
    colors[colors["papayawhip"] = 4294963157] = "papayawhip";
    colors[colors["peachpuff"] = 4294957753] = "peachpuff";
    colors[colors["peru"] = 4291659071] = "peru";
    colors[colors["pink"] = 4294951115] = "pink";
    colors[colors["plum"] = 4292714717] = "plum";
    colors[colors["powderblue"] = 4289781990] = "powderblue";
    colors[colors["purple"] = 4286578816] = "purple";
    colors[colors["rebeccapurple"] = 4284887961] = "rebeccapurple";
    colors[colors["red"] = 4294901760] = "red";
    colors[colors["rosybrown"] = 4290547599] = "rosybrown";
    colors[colors["royalblue"] = 4282477025] = "royalblue";
    colors[colors["saddlebrown"] = 4287317267] = "saddlebrown";
    colors[colors["salmon"] = 4294606962] = "salmon";
    colors[colors["sandybrown"] = 4294222944] = "sandybrown";
    colors[colors["seagreen"] = 4281240407] = "seagreen";
    colors[colors["seashell"] = 4294964718] = "seashell";
    colors[colors["sienna"] = 4288696877] = "sienna";
    colors[colors["silver"] = 4290822336] = "silver";
    colors[colors["skyblue"] = 4287090411] = "skyblue";
    colors[colors["slateblue"] = 4285160141] = "slateblue";
    colors[colors["slategray"] = 4285563024] = "slategray";
    colors[colors["slategrey"] = 4285563024] = "slategrey";
    colors[colors["snow"] = 4294966010] = "snow";
    colors[colors["springgreen"] = 4278255487] = "springgreen";
    colors[colors["steelblue"] = 4282811060] = "steelblue";
    colors[colors["tan"] = 4291998860] = "tan";
    colors[colors["teal"] = 4278222976] = "teal";
    colors[colors["thistle"] = 4292394968] = "thistle";
    colors[colors["tomato"] = 4294927175] = "tomato";
    colors[colors["turquoise"] = 4282441936] = "turquoise";
    colors[colors["violet"] = 4293821166] = "violet";
    colors[colors["wheat"] = 4294303411] = "wheat";
    colors[colors["white"] = 4294967295] = "white";
    colors[colors["whitesmoke"] = 4294309365] = "whitesmoke";
    colors[colors["yellow"] = 4294967040] = "yellow";
    colors[colors["yellowgreen"] = 4288335154] = "yellowgreen";
})(colors = exports.colors || (exports.colors = {}));
;
function parseColorKeyword(value, start, keyword) {
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    if (keyword && keyword.value in colors) {
        var end = keyword.end;
        var value_1 = colors[keyword.value];
        return { start: start, end: end, value: value_1 };
    }
    return null;
}
exports.parseColorKeyword = parseColorKeyword;
function parseColor(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    return parseHexColor(value, start) || parseColorKeyword(value, start, keyword) || parseRGBColor(value, start) || parseRGBAColor(value, start);
}
exports.parseColor = parseColor;
var keywordRegEx = /\s*([a-z][\w\-]*)\s*/giy;
function parseKeyword(text, start) {
    if (start === void 0) { start = 0; }
    keywordRegEx.lastIndex = start;
    var result = keywordRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = keywordRegEx.lastIndex;
    var value = result[1];
    return { start: start, end: end, value: value };
}
var backgroundRepeatKeywords = new Set(["repeat", "repeat-x", "repeat-y", "no-repeat"]);
function parseRepeat(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    if (keyword && backgroundRepeatKeywords.has(keyword.value)) {
        var end = keyword.end;
        var value_2 = keyword.value;
        return { start: start, end: end, value: value_2 };
    }
    return null;
}
exports.parseRepeat = parseRepeat;
var unitRegEx = /\s*([\+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][\+\-]?\d+)?)([a-zA-Z]+|%)?\s*/gy;
function parseUnit(text, start) {
    if (start === void 0) { start = 0; }
    unitRegEx.lastIndex = start;
    var result = unitRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = unitRegEx.lastIndex;
    var value = parseFloat(result[1]);
    var unit = result[2] || "dip";
    return { start: start, end: end, value: { value: value, unit: unit } };
}
exports.parseUnit = parseUnit;
function parsePercentageOrLength(text, start) {
    if (start === void 0) { start = 0; }
    var unitResult = parseUnit(text, start);
    if (unitResult) {
        var start_1 = unitResult.start, end = unitResult.end;
        var value = unitResult.value;
        if (value.unit === "%") {
            value.value /= 100;
        }
        else if (!value.unit) {
            value.unit = "dip";
        }
        else if (value.unit === "px" || value.unit === "dip") {
        }
        else {
            return null;
        }
        return { start: start_1, end: end, value: value };
    }
    return null;
}
exports.parsePercentageOrLength = parsePercentageOrLength;
var angleUnitsToRadMap = {
    "deg": function (start, end, deg) { return ({ start: start, end: end, value: deg / 180 * Math.PI }); },
    "rad": function (start, end, rad) { return ({ start: start, end: end, value: rad }); },
    "grad": function (start, end, grad) { return ({ start: start, end: end, value: grad / 200 * Math.PI }); },
    "turn": function (start, end, turn) { return ({ start: start, end: end, value: turn * Math.PI * 2 }); }
};
function parseAngle(value, start) {
    if (start === void 0) { start = 0; }
    var angleResult = parseUnit(value, start);
    if (angleResult) {
        var start_2 = angleResult.start, end = angleResult.end, value_3 = angleResult.value;
        return (angleUnitsToRadMap[value_3.unit] || (function (_, __, ___) { return null; }))(start_2, end, value_3.value);
    }
    return null;
}
exports.parseAngle = parseAngle;
var backgroundSizeKeywords = new Set(["auto", "contain", "cover"]);
function parseBackgroundSize(value, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(value, start); }
    var end = start;
    if (keyword && backgroundSizeKeywords.has(keyword.value)) {
        end = keyword.end;
        var value_4 = keyword.value;
        return { start: start, end: end, value: value_4 };
    }
    var firstLength = parsePercentageOrLength(value, end);
    if (firstLength) {
        end = firstLength.end;
        var secondLength = parsePercentageOrLength(value, firstLength.end);
        if (secondLength) {
            end = secondLength.end;
            return { start: start, end: end, value: { x: firstLength.value, y: secondLength.value } };
        }
        else {
            return { start: start, end: end, value: { x: firstLength.value, y: "auto" } };
        }
    }
    return null;
}
exports.parseBackgroundSize = parseBackgroundSize;
var backgroundPositionKeywords = Object.freeze(new Set(["left", "right", "top", "bottom", "center"]));
var backgroundPositionKeywordsDirection = {
    "left": "x",
    "right": "x",
    "center": "center",
    "top": "y",
    "bottom": "y"
};
function parseBackgroundPosition(text, start, keyword) {
    if (start === void 0) { start = 0; }
    if (keyword === void 0) { keyword = parseKeyword(text, start); }
    function formatH(align, offset) {
        if (align.value === "center") {
            return "center";
        }
        if (offset && offset.value.value !== 0) {
            return { align: align.value, offset: offset.value };
        }
        return align.value;
    }
    function formatV(align, offset) {
        if (align.value === "center") {
            return "center";
        }
        if (offset && offset.value.value !== 0) {
            return { align: align.value, offset: offset.value };
        }
        return align.value;
    }
    var end = start;
    if (keyword && backgroundPositionKeywords.has(keyword.value)) {
        end = keyword.end;
        var firstDirection = backgroundPositionKeywordsDirection[keyword.value];
        var firstLength = firstDirection !== "center" && parsePercentageOrLength(text, end);
        if (firstLength) {
            end = firstLength.end;
        }
        var secondKeyword = parseKeyword(text, end);
        if (secondKeyword && backgroundPositionKeywords.has(secondKeyword.value)) {
            end = secondKeyword.end;
            var secondDirection = backgroundPositionKeywordsDirection[secondKeyword.end];
            if (firstDirection === secondDirection && firstDirection !== "center") {
                return null;
            }
            var secondLength = secondDirection !== "center" && parsePercentageOrLength(text, end);
            if (secondLength) {
                end = secondLength.end;
            }
            if ((firstDirection === secondDirection && secondDirection === "center") || (firstDirection === "x" || secondDirection === "y")) {
                return { start: start, end: end, value: {
                        x: formatH(keyword, firstLength),
                        y: formatV(secondKeyword, secondLength)
                    } };
            }
            else {
                return { start: start, end: end, value: {
                        x: formatH(secondKeyword, secondLength),
                        y: formatV(keyword, firstLength),
                    } };
            }
        }
        else {
            if (firstDirection === "center") {
                return { start: start, end: end, value: { x: "center", y: "center" } };
            }
            else if (firstDirection === "x") {
                return { start: start, end: end, value: { x: formatH(keyword, firstLength), y: "center" } };
            }
            else {
                return { start: start, end: end, value: { x: "center", y: formatV(keyword, firstLength) } };
            }
        }
    }
    else {
        var firstLength = parsePercentageOrLength(text, end);
        if (firstLength) {
            end = firstLength.end;
            var secondLength = parsePercentageOrLength(text, end);
            if (secondLength) {
                end = secondLength.end;
                return { start: start, end: end, value: { x: { align: "left", offset: firstLength.value }, y: { align: "top", offset: secondLength.value } } };
            }
            else {
                return { start: start, end: end, value: { x: { align: "left", offset: firstLength.value }, y: "center" } };
            }
        }
        else {
            return null;
        }
    }
}
exports.parseBackgroundPosition = parseBackgroundPosition;
var directionRegEx = /\s*to\s*(left|right|top|bottom)\s*(left|right|top|bottom)?\s*/gy;
var sideDirections = {
    top: Math.PI * 0 / 2,
    right: Math.PI * 1 / 2,
    bottom: Math.PI * 2 / 2,
    left: Math.PI * 3 / 2
};
var cornerDirections = {
    top: {
        right: Math.PI * 1 / 4,
        left: Math.PI * 7 / 4
    },
    right: {
        top: Math.PI * 1 / 4,
        bottom: Math.PI * 3 / 4
    },
    bottom: {
        right: Math.PI * 3 / 4,
        left: Math.PI * 5 / 4
    },
    left: {
        top: Math.PI * 7 / 4,
        bottom: Math.PI * 5 / 4
    }
};
function parseDirection(text, start) {
    if (start === void 0) { start = 0; }
    directionRegEx.lastIndex = start;
    var result = directionRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = directionRegEx.lastIndex;
    var firstDirection = result[1];
    if (result[2]) {
        var secondDirection = result[2];
        var value = cornerDirections[firstDirection][secondDirection];
        return value === undefined ? null : { start: start, end: end, value: value };
    }
    else {
        return { start: start, end: end, value: sideDirections[firstDirection] };
    }
}
var openingBracketRegEx = /\s*\(\s*/gy;
var closingBracketRegEx = /\s*\)\s*/gy;
var closingBracketOrCommaRegEx = /\s*(\)|,)\s*/gy;
function parseArgumentsList(text, start, argument) {
    openingBracketRegEx.lastIndex = start;
    var openingBracket = openingBracketRegEx.exec(text);
    if (!openingBracket) {
        return null;
    }
    var end = openingBracketRegEx.lastIndex;
    var value = [];
    closingBracketRegEx.lastIndex = end;
    var closingBracket = closingBracketRegEx.exec(text);
    if (closingBracket) {
        return { start: start, end: end, value: value };
    }
    for (var index_1 = 0; true; index_1++) {
        var arg = argument(text, end, index_1);
        if (!arg) {
            return null;
        }
        end = arg.end;
        value.push(arg);
        closingBracketOrCommaRegEx.lastIndex = end;
        var closingBracketOrComma = closingBracketOrCommaRegEx.exec(text);
        if (closingBracketOrComma) {
            end = closingBracketOrCommaRegEx.lastIndex;
            if (closingBracketOrComma[1] === ",") {
                continue;
            }
            else if (closingBracketOrComma[1] === ")") {
                return { start: start, end: end, value: value };
            }
        }
        else {
            return null;
        }
    }
}
function parseColorStop(text, start) {
    if (start === void 0) { start = 0; }
    var color = parseColor(text, start);
    if (!color) {
        return null;
    }
    var end = color.end;
    var offset = parsePercentageOrLength(text, end);
    if (offset) {
        end = offset.end;
        return { start: start, end: end, value: { argb: color.value, offset: offset.value } };
    }
    return { start: start, end: end, value: { argb: color.value } };
}
exports.parseColorStop = parseColorStop;
var linearGradientStartRegEx = /\s*linear-gradient\s*/gy;
function parseLinearGradient(text, start) {
    if (start === void 0) { start = 0; }
    linearGradientStartRegEx.lastIndex = start;
    var lgs = linearGradientStartRegEx.exec(text);
    if (!lgs) {
        return null;
    }
    var end = linearGradientStartRegEx.lastIndex;
    var angle = Math.PI;
    var colors = [];
    var parsedArgs = parseArgumentsList(text, end, function (text, start, index) {
        if (index === 0) {
            var angleArg = parseAngle(text, start) || parseDirection(text, start);
            if (angleArg) {
                angle = angleArg.value;
                return angleArg;
            }
        }
        var colorStop = parseColorStop(text, start);
        if (colorStop) {
            colors.push(colorStop.value);
            return colorStop;
        }
        return null;
    });
    if (!parsedArgs) {
        return null;
    }
    end = parsedArgs.end;
    return { start: start, end: end, value: { angle: angle, colors: colors } };
}
exports.parseLinearGradient = parseLinearGradient;
var slashRegEx = /\s*(\/)\s*/gy;
function parseSlash(text, start) {
    slashRegEx.lastIndex = start;
    var slash = slashRegEx.exec(text);
    if (!slash) {
        return null;
    }
    var end = slashRegEx.lastIndex;
    return { start: start, end: end, value: "/" };
}
function parseBackground(text, start) {
    if (start === void 0) { start = 0; }
    var value = {};
    var end = start;
    while (end < text.length) {
        var keyword = parseKeyword(text, end);
        var color = parseColor(text, end, keyword);
        if (color) {
            value.color = color.value;
            end = color.end;
            continue;
        }
        var repeat = parseRepeat(text, end, keyword);
        if (repeat) {
            value.repeat = repeat.value;
            end = repeat.end;
            continue;
        }
        var position = parseBackgroundPosition(text, end, keyword);
        if (position) {
            position.value.text = text.substring(position.start, position.end);
            value.position = position.value;
            end = position.end;
            var slash = parseSlash(text, end);
            if (slash) {
                end = slash.end;
                var size = parseBackgroundSize(text, end);
                if (!size) {
                    return null;
                }
                value.size = size.value;
                end = size.end;
            }
            continue;
        }
        var url = parseURL(text, end);
        if (url) {
            value.image = url.value;
            end = url.end;
            continue;
        }
        var gradient = parseLinearGradient(text, end);
        if (gradient) {
            value.image = gradient.value;
            end = gradient.end;
            continue;
        }
        return null;
    }
    return { start: start, end: end, value: value };
}
exports.parseBackground = parseBackground;
var universalSelectorRegEx = /\*/gy;
function parseUniversalSelector(text, start) {
    if (start === void 0) { start = 0; }
    universalSelectorRegEx.lastIndex = start;
    var result = universalSelectorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = universalSelectorRegEx.lastIndex;
    return { start: start, end: end, value: { type: "*" } };
}
exports.parseUniversalSelector = parseUniversalSelector;
var simpleIdentifierSelectorRegEx = /(#|\.|:|\b)([_-\w][_-\w\d]*)/gy;
function parseSimpleIdentifierSelector(text, start) {
    if (start === void 0) { start = 0; }
    simpleIdentifierSelectorRegEx.lastIndex = start;
    var result = simpleIdentifierSelectorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = simpleIdentifierSelectorRegEx.lastIndex;
    var type = result[1];
    var identifier = result[2];
    var value = { type: type, identifier: identifier };
    return { start: start, end: end, value: value };
}
exports.parseSimpleIdentifierSelector = parseSimpleIdentifierSelector;
var attributeSelectorRegEx = /\[\s*([_-\w][_-\w\d]*)\s*(?:(=|\^=|\$=|\*=|\~=|\|=)\s*(?:([_-\w][_-\w\d]*)|"((?:[^\\"]|\\(?:"|n|r|f|\\|0-9a-f))*)"|'((?:[^\\']|\\(?:'|n|r|f|\\|0-9a-f))*)')\s*)?\]/gy;
function parseAttributeSelector(text, start) {
    attributeSelectorRegEx.lastIndex = start;
    var result = attributeSelectorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = attributeSelectorRegEx.lastIndex;
    var property = result[1];
    if (result[2]) {
        var test_1 = result[2];
        var value = result[3] || result[4] || result[5];
        return { start: start, end: end, value: { type: "[]", property: property, test: test_1, value: value } };
    }
    return { start: start, end: end, value: { type: "[]", property: property } };
}
exports.parseAttributeSelector = parseAttributeSelector;
function parseSimpleSelector(text, start) {
    if (start === void 0) { start = 0; }
    return parseUniversalSelector(text, start) ||
        parseSimpleIdentifierSelector(text, start) ||
        parseAttributeSelector(text, start);
}
exports.parseSimpleSelector = parseSimpleSelector;
function parseSimpleSelectorSequence(text, start) {
    var simpleSelector = parseSimpleSelector(text, start);
    if (!simpleSelector) {
        return null;
    }
    var end = simpleSelector.end;
    var value = [];
    while (simpleSelector) {
        value.push(simpleSelector.value);
        end = simpleSelector.end;
        simpleSelector = parseSimpleSelector(text, end);
    }
    return { start: start, end: end, value: value };
}
exports.parseSimpleSelectorSequence = parseSimpleSelectorSequence;
var combinatorRegEx = /\s*(\+|~|>)?\s*/gy;
function parseCombinator(text, start) {
    if (start === void 0) { start = 0; }
    combinatorRegEx.lastIndex = start;
    var result = combinatorRegEx.exec(text);
    if (!result) {
        return null;
    }
    var end = combinatorRegEx.lastIndex;
    var value = result[1] || " ";
    return { start: start, end: end, value: value };
}
exports.parseCombinator = parseCombinator;
var whiteSpaceRegEx = /\s*/gy;
function parseSelector(text, start) {
    if (start === void 0) { start = 0; }
    var end = start;
    whiteSpaceRegEx.lastIndex = end;
    var leadingWhiteSpace = whiteSpaceRegEx.exec(text);
    if (leadingWhiteSpace) {
        end = whiteSpaceRegEx.lastIndex;
    }
    var value = [];
    var combinator;
    var expectSimpleSelector = true;
    var pair;
    do {
        var simpleSelectorSequence = parseSimpleSelectorSequence(text, end);
        if (!simpleSelectorSequence) {
            if (expectSimpleSelector) {
                return null;
            }
            else {
                break;
            }
        }
        end = simpleSelectorSequence.end;
        if (combinator) {
            pair[1] = combinator.value;
        }
        pair = [simpleSelectorSequence.value, undefined];
        value.push(pair);
        combinator = parseCombinator(text, end);
        if (combinator) {
            end = combinator.end;
        }
        expectSimpleSelector = combinator && combinator.value !== " ";
    } while (combinator);
    return { start: start, end: end, value: value };
}
exports.parseSelector = parseSelector;
var whitespaceRegEx = /[\s\t\n\r\f]*/gym;
var singleQuoteStringRegEx = /'((?:[^\n\r\f\']|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?'|$)/gym;
var doubleQuoteStringRegEx = /"((?:[^\n\r\f\"]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)(:?"|$)/gym;
var commentRegEx = /(\/\*(?:[^\*]|\*[^\/])*\*\/)/gym;
var numberRegEx = /[\+\-]?(?:\d+\.\d+|\d+|\.\d+)(?:[eE][\+\-]?\d+)?/gym;
var nameRegEx = /-?(?:(?:[a-zA-Z_]|[^\x00-\x7F]|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))(?:[a-zA-Z_0-9\-]*|\\(?:\$|\n|[0-9a-fA-F]{1,6}\s?))*)/gym;
var CSS3Parser = (function () {
    function CSS3Parser(text) {
        this.text = text;
        this.nextInputCodePointIndex = 0;
    }
    CSS3Parser.prototype.tokenize = function () {
        var tokens = [];
        var inputToken;
        do {
            inputToken = this.consumeAToken();
            tokens.push(inputToken);
        } while (inputToken);
        return tokens;
    };
    CSS3Parser.prototype.consumeAToken = function () {
        if (this.reconsumedInputToken) {
            var result = this.reconsumedInputToken;
            this.reconsumedInputToken = null;
            return result;
        }
        var char = this.text[this.nextInputCodePointIndex];
        switch (char) {
            case "\"": return this.consumeAStringToken();
            case "'": return this.consumeAStringToken();
            case "(":
            case ")":
            case ",":
            case ":":
            case ";":
            case "[":
            case "]":
            case "{":
            case "}":
                this.nextInputCodePointIndex++;
                return char;
            case "#": return this.consumeAHashToken() || this.consumeADelimToken();
            case " ":
            case "\t":
            case "\n":
            case "\r":
            case "\f":
                return this.consumeAWhitespace();
            case "@": return this.consumeAtKeyword() || this.consumeADelimToken();
            case "\\": return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                return this.consumeANumericToken();
            case "u":
            case "U":
                if (this.text[this.nextInputCodePointIndex + 1] === "+") {
                    var thirdChar = this.text[this.nextInputCodePointIndex + 2];
                    if (thirdChar >= "0" && thirdChar <= "9" || thirdChar === "?") {
                        throw new Error("Unicode tokens not supported!");
                    }
                }
                return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
            case "$":
            case "*":
            case "^":
            case "|":
            case "~":
                return this.consumeAMatchToken() || this.consumeADelimToken();
            case "-": return this.consumeANumericToken() || this.consumeAnIdentLikeToken() || this.consumeCDC() || this.consumeADelimToken();
            case "+":
            case ".":
                return this.consumeANumericToken() || this.consumeADelimToken();
            case "/": return this.consumeAComment() || this.consumeADelimToken();
            case "<": return this.consumeCDO() || this.consumeADelimToken();
            case undefined: return undefined;
            default: return this.consumeAnIdentLikeToken() || this.consumeADelimToken();
        }
    };
    CSS3Parser.prototype.consumeADelimToken = function () {
        return { type: 2, text: this.text[this.nextInputCodePointIndex++] };
    };
    CSS3Parser.prototype.consumeAWhitespace = function () {
        whitespaceRegEx.lastIndex = this.nextInputCodePointIndex;
        whitespaceRegEx.exec(this.text);
        this.nextInputCodePointIndex = whitespaceRegEx.lastIndex;
        return " ";
    };
    CSS3Parser.prototype.consumeAHashToken = function () {
        this.nextInputCodePointIndex++;
        var hashName = this.consumeAName();
        if (hashName) {
            return { type: 12, text: "#" + hashName.text };
        }
        this.nextInputCodePointIndex--;
        return null;
    };
    CSS3Parser.prototype.consumeCDO = function () {
        if (this.text.substr(this.nextInputCodePointIndex, 4) === "<!--") {
            this.nextInputCodePointIndex += 4;
            return "<!--";
        }
        return null;
    };
    CSS3Parser.prototype.consumeCDC = function () {
        if (this.text.substr(this.nextInputCodePointIndex, 3) === "-->") {
            this.nextInputCodePointIndex += 3;
            return "-->";
        }
        return null;
    };
    CSS3Parser.prototype.consumeAMatchToken = function () {
        if (this.text[this.nextInputCodePointIndex + 1] === "=") {
            var token = this.text.substr(this.nextInputCodePointIndex, 2);
            this.nextInputCodePointIndex += 2;
            return token;
        }
        return null;
    };
    CSS3Parser.prototype.consumeANumericToken = function () {
        numberRegEx.lastIndex = this.nextInputCodePointIndex;
        var result = numberRegEx.exec(this.text);
        if (!result) {
            return null;
        }
        this.nextInputCodePointIndex = numberRegEx.lastIndex;
        if (this.text[this.nextInputCodePointIndex] === "%") {
            return { type: 4, text: result[0] };
        }
        var name = this.consumeAName();
        if (name) {
            return { type: 5, text: result[0] + name.text };
        }
        return { type: 3, text: result[0] };
    };
    CSS3Parser.prototype.consumeAnIdentLikeToken = function () {
        var name = this.consumeAName();
        if (!name) {
            return null;
        }
        if (this.text[this.nextInputCodePointIndex] === "(") {
            this.nextInputCodePointIndex++;
            if (name.text.toLowerCase() === "url") {
                return this.consumeAURLToken();
            }
            return { type: 8, name: name.text, text: name.text + "(" };
        }
        return name;
    };
    CSS3Parser.prototype.consumeAStringToken = function () {
        var char = this.text[this.nextInputCodePointIndex];
        var result;
        if (char === "'") {
            singleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
            result = singleQuoteStringRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = singleQuoteStringRegEx.lastIndex;
        }
        else if (char === "\"") {
            doubleQuoteStringRegEx.lastIndex = this.nextInputCodePointIndex;
            result = doubleQuoteStringRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = doubleQuoteStringRegEx.lastIndex;
        }
        return { type: 1, text: result[0] };
    };
    CSS3Parser.prototype.consumeAURLToken = function () {
        var start = this.nextInputCodePointIndex - 3 - 1;
        var urlToken = { type: 7, text: undefined };
        this.consumeAWhitespace();
        if (this.nextInputCodePointIndex >= this.text.length) {
            return urlToken;
        }
        var nextInputCodePoint = this.text[this.nextInputCodePointIndex];
        if (nextInputCodePoint === "\"" || nextInputCodePoint === "'") {
            var stringToken = this.consumeAStringToken();
            urlToken.text = stringToken.text;
            this.consumeAWhitespace();
            if (this.text[this.nextInputCodePointIndex] === ")" || this.nextInputCodePointIndex >= this.text.length) {
                this.nextInputCodePointIndex++;
                var end = this.nextInputCodePointIndex;
                urlToken.text = this.text.substring(start, end);
                return urlToken;
            }
            else {
                return null;
            }
        }
        while (this.nextInputCodePointIndex < this.text.length) {
            var char = this.text[this.nextInputCodePointIndex++];
            switch (char) {
                case ")": return urlToken;
                case " ":
                case "\t":
                case "\n":
                case "\r":
                case "\f":
                    this.consumeAWhitespace();
                    if (this.text[this.nextInputCodePointIndex] === ")") {
                        this.nextInputCodePointIndex++;
                        return urlToken;
                    }
                    else {
                        return null;
                    }
                case "\"":
                case "\'":
                    return null;
                case "\\":
                    throw new Error("Escaping not yet supported!");
                default:
                    urlToken.text += char;
            }
        }
        return urlToken;
    };
    CSS3Parser.prototype.consumeAName = function () {
        nameRegEx.lastIndex = this.nextInputCodePointIndex;
        var result = nameRegEx.exec(this.text);
        if (!result) {
            return null;
        }
        this.nextInputCodePointIndex = nameRegEx.lastIndex;
        return { type: 6, text: result[0] };
    };
    CSS3Parser.prototype.consumeAtKeyword = function () {
        this.nextInputCodePointIndex++;
        var name = this.consumeAName();
        if (name) {
            return { type: 11, text: name.text };
        }
        this.nextInputCodePointIndex--;
        return null;
    };
    CSS3Parser.prototype.consumeAComment = function () {
        if (this.text[this.nextInputCodePointIndex + 1] === "*") {
            commentRegEx.lastIndex = this.nextInputCodePointIndex;
            var result = commentRegEx.exec(this.text);
            if (!result) {
                return null;
            }
            this.nextInputCodePointIndex = commentRegEx.lastIndex;
            return this.consumeAToken();
        }
        return null;
    };
    CSS3Parser.prototype.reconsumeTheCurrentInputToken = function (currentInputToken) {
        this.reconsumedInputToken = currentInputToken;
    };
    CSS3Parser.prototype.parseAStylesheet = function () {
        this.topLevelFlag = true;
        var stylesheet = {
            rules: this.consumeAListOfRules()
        };
        return stylesheet;
    };
    CSS3Parser.prototype.consumeAListOfRules = function () {
        var rules = [];
        var inputToken;
        while (inputToken = this.consumeAToken()) {
            switch (inputToken) {
                case " ": continue;
                case "<!--":
                case "-->":
                    if (this.topLevelFlag) {
                        continue;
                    }
                    this.reconsumeTheCurrentInputToken(inputToken);
                    var atRule = this.consumeAnAtRule();
                    if (atRule) {
                        rules.push(atRule);
                    }
                    continue;
            }
            if (inputToken.type === 11) {
                this.reconsumeTheCurrentInputToken(inputToken);
                var atRule = this.consumeAnAtRule();
                if (atRule) {
                    rules.push(atRule);
                }
                continue;
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var qualifiedRule = this.consumeAQualifiedRule();
            if (qualifiedRule) {
                rules.push(qualifiedRule);
            }
        }
        return rules;
    };
    CSS3Parser.prototype.consumeAnAtRule = function () {
        var inputToken = this.consumeAToken();
        var atRule = {
            type: "at-rule",
            name: inputToken.text,
            prelude: [],
            block: undefined
        };
        while (inputToken = this.consumeAToken()) {
            if (inputToken === ";") {
                return atRule;
            }
            else if (inputToken === "{") {
                atRule.block = this.consumeASimpleBlock(inputToken);
                return atRule;
            }
            else if (inputToken.type === 9 && inputToken.associatedToken === "{") {
                atRule.block = inputToken;
                return atRule;
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var component = this.consumeAComponentValue();
            if (component) {
                atRule.prelude.push(component);
            }
        }
        return atRule;
    };
    CSS3Parser.prototype.consumeAQualifiedRule = function () {
        var qualifiedRule = {
            type: "qualified-rule",
            prelude: [],
            block: undefined
        };
        var inputToken;
        while (inputToken = this.consumeAToken()) {
            if (inputToken === "{") {
                var block = this.consumeASimpleBlock(inputToken);
                qualifiedRule.block = block;
                return qualifiedRule;
            }
            else if (inputToken.type === 9) {
                var simpleBlock = inputToken;
                if (simpleBlock.associatedToken === "{") {
                    qualifiedRule.block = simpleBlock;
                    return qualifiedRule;
                }
            }
            this.reconsumeTheCurrentInputToken(inputToken);
            var componentValue = this.consumeAComponentValue();
            if (componentValue) {
                qualifiedRule.prelude.push(componentValue);
            }
        }
        return null;
    };
    CSS3Parser.prototype.consumeAComponentValue = function () {
        var inputToken = this.consumeAToken();
        switch (inputToken) {
            case "{":
            case "[":
            case "(":
                this.nextInputCodePointIndex++;
                return this.consumeASimpleBlock(inputToken);
        }
        if (typeof inputToken === "object" && inputToken.type === 8) {
            return this.consumeAFunction(inputToken.name);
        }
        return inputToken;
    };
    CSS3Parser.prototype.consumeASimpleBlock = function (associatedToken) {
        var endianToken = {
            "[": "]",
            "{": "}",
            "(": ")"
        }[associatedToken];
        var start = this.nextInputCodePointIndex - 1;
        var block = {
            type: 9,
            text: undefined,
            associatedToken: associatedToken,
            values: []
        };
        var nextInputToken;
        while (nextInputToken = this.text[this.nextInputCodePointIndex]) {
            if (nextInputToken === endianToken) {
                this.nextInputCodePointIndex++;
                var end = this.nextInputCodePointIndex;
                block.text = this.text.substring(start, end);
                return block;
            }
            var value = this.consumeAComponentValue();
            if (value) {
                block.values.push(value);
            }
        }
        block.text = this.text.substring(start);
        return block;
    };
    CSS3Parser.prototype.consumeAFunction = function (name) {
        var start = this.nextInputCodePointIndex;
        var funcToken = { type: 14, name: name, text: undefined, components: [] };
        do {
            if (this.nextInputCodePointIndex >= this.text.length) {
                funcToken.text = name + "(" + this.text.substring(start);
                return funcToken;
            }
            var nextInputToken = this.text[this.nextInputCodePointIndex];
            switch (nextInputToken) {
                case ")":
                    this.nextInputCodePointIndex++;
                    var end = this.nextInputCodePointIndex;
                    funcToken.text = name + "(" + this.text.substring(start, end);
                    return funcToken;
                default:
                    var component = this.consumeAComponentValue();
                    if (component) {
                        funcToken.components.push(component);
                    }
            }
        } while (true);
    };
    return CSS3Parser;
}());
exports.CSS3Parser = CSS3Parser;
var CSSNativeScript = (function () {
    function CSSNativeScript() {
    }
    CSSNativeScript.prototype.parseStylesheet = function (stylesheet) {
        return {
            type: "stylesheet",
            stylesheet: {
                rules: this.parseRules(stylesheet.rules)
            }
        };
    };
    CSSNativeScript.prototype.parseRules = function (rules) {
        var _this = this;
        return rules.map(function (rule) { return _this.parseRule(rule); });
    };
    CSSNativeScript.prototype.parseRule = function (rule) {
        if (rule.type === "at-rule") {
            return this.parseAtRule(rule);
        }
        else if (rule.type === "qualified-rule") {
            return this.parseQualifiedRule(rule);
        }
    };
    CSSNativeScript.prototype.parseAtRule = function (rule) {
        if (rule.name === "import") {
            return {
                import: rule.prelude.map(function (m) { return typeof m === "string" ? m : m.text; }).join("").trim(),
                type: "import"
            };
        }
        return;
    };
    CSSNativeScript.prototype.parseQualifiedRule = function (rule) {
        return {
            type: "rule",
            selectors: this.preludeToSelectorsStringArray(rule.prelude),
            declarations: this.ruleBlockToDeclarations(rule.block.values)
        };
    };
    CSSNativeScript.prototype.ruleBlockToDeclarations = function (declarationsInputTokens) {
        var declarations = [];
        var property = "";
        var value = "";
        var reading = "property";
        for (var i = 0; i < declarationsInputTokens.length; i++) {
            var inputToken = declarationsInputTokens[i];
            if (reading === "property") {
                if (inputToken === ":") {
                    reading = "value";
                }
                else if (typeof inputToken === "string") {
                    property += inputToken;
                }
                else {
                    property += inputToken.text;
                }
            }
            else {
                if (inputToken === ";") {
                    property = property.trim();
                    value = value.trim();
                    declarations.push({ type: "declaration", property: property, value: value });
                    property = "";
                    value = "";
                    reading = "property";
                }
                else if (typeof inputToken === "string") {
                    value += inputToken;
                }
                else {
                    value += inputToken.text;
                }
            }
        }
        property = property.trim();
        value = value.trim();
        if (property || value) {
            declarations.push({ type: "declaration", property: property, value: value });
        }
        return declarations;
    };
    CSSNativeScript.prototype.preludeToSelectorsStringArray = function (prelude) {
        var selectors = [];
        var selector = "";
        prelude.forEach(function (inputToken) {
            if (typeof inputToken === "string") {
                if (inputToken === ",") {
                    if (selector) {
                        selectors.push(selector.trim());
                    }
                    selector = "";
                }
                else {
                    selector += inputToken;
                }
            }
            else if (typeof inputToken === "object") {
                selector += inputToken.text;
            }
        });
        if (selector) {
            selectors.push(selector.trim());
        }
        return selectors;
    };
    return CSSNativeScript;
}());
exports.CSSNativeScript = CSSNativeScript;
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/data/observable-array/observable-array.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var observable = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var ChangeType = (function () {
    function ChangeType() {
    }
    ChangeType.Add = "add";
    ChangeType.Delete = "delete";
    ChangeType.Update = "update";
    ChangeType.Splice = "splice";
    return ChangeType;
}());
exports.ChangeType = ChangeType;
var CHANGE = "change";
var ObservableArray = (function (_super) {
    __extends(ObservableArray, _super);
    function ObservableArray() {
        var _this = _super.call(this) || this;
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
            _this._array = arguments[0].slice();
        }
        else {
            _this._array = Array.apply(null, arguments);
        }
        _this._addArgs = {
            eventName: CHANGE, object: _this,
            action: ChangeType.Add,
            index: null,
            removed: new Array(),
            addedCount: 1
        };
        _this._deleteArgs = {
            eventName: CHANGE, object: _this,
            action: ChangeType.Delete,
            index: null,
            removed: null,
            addedCount: 0
        };
        return _this;
    }
    ObservableArray.prototype.getItem = function (index) {
        return this._array[index];
    };
    ObservableArray.prototype.setItem = function (index, value) {
        var oldValue = this._array[index];
        this._array[index] = value;
        this.notify({
            eventName: CHANGE, object: this,
            action: ChangeType.Update,
            index: index,
            removed: [oldValue],
            addedCount: 1
        });
    };
    Object.defineProperty(ObservableArray.prototype, "length", {
        get: function () {
            return this._array.length;
        },
        set: function (value) {
            if (types.isNumber(value) && this._array && this._array.length !== value) {
                this.splice(value, this._array.length - value);
            }
        },
        enumerable: true,
        configurable: true
    });
    ObservableArray.prototype.toString = function () {
        return this._array.toString();
    };
    ObservableArray.prototype.toLocaleString = function () {
        return this._array.toLocaleString();
    };
    ObservableArray.prototype.concat = function () {
        this._addArgs.index = this._array.length;
        var result = this._array.concat.apply(this._array, arguments);
        return result;
    };
    ObservableArray.prototype.join = function (separator) {
        return this._array.join(separator);
    };
    ObservableArray.prototype.pop = function () {
        this._deleteArgs.index = this._array.length - 1;
        var result = this._array.pop();
        this._deleteArgs.removed = [result];
        this.notify(this._deleteArgs);
        this._notifyLengthChange();
        return result;
    };
    ObservableArray.prototype.push = function () {
        this._addArgs.index = this._array.length;
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
            var source = arguments[0];
            for (var i = 0, l = source.length; i < l; i++) {
                this._array.push(source[i]);
            }
        }
        else {
            this._array.push.apply(this._array, arguments);
        }
        this._addArgs.addedCount = this._array.length - this._addArgs.index;
        this.notify(this._addArgs);
        this._notifyLengthChange();
        return this._array.length;
    };
    ObservableArray.prototype._notifyLengthChange = function () {
        var lengthChangedData = this._createPropertyChangeData("length", this._array.length);
        this.notify(lengthChangedData);
    };
    ObservableArray.prototype.reverse = function () {
        return this._array.reverse();
    };
    ObservableArray.prototype.shift = function () {
        var result = this._array.shift();
        this._deleteArgs.index = 0;
        this._deleteArgs.removed = [result];
        this.notify(this._deleteArgs);
        this._notifyLengthChange();
        return result;
    };
    ObservableArray.prototype.slice = function (start, end) {
        return this._array.slice(start, end);
    };
    ObservableArray.prototype.sort = function (compareFn) {
        return this._array.sort(compareFn);
    };
    ObservableArray.prototype.splice = function (start, deleteCount) {
        var length = this._array.length;
        var result = this._array.splice.apply(this._array, arguments);
        this.notify({
            eventName: CHANGE, object: this,
            action: ChangeType.Splice,
            index: start,
            removed: result,
            addedCount: this._array.length > length ? this._array.length - length : 0
        });
        if (this._array.length !== length) {
            this._notifyLengthChange();
        }
        return result;
    };
    ObservableArray.prototype.unshift = function () {
        var length = this._array.length;
        var result = this._array.unshift.apply(this._array, arguments);
        this._addArgs.index = 0;
        this._addArgs.addedCount = result - length;
        this.notify(this._addArgs);
        this._notifyLengthChange();
        return result;
    };
    ObservableArray.prototype.indexOf = function (searchElement, fromIndex) {
        var index = fromIndex ? fromIndex : 0;
        for (var i = index, l = this._array.length; i < l; i++) {
            if (this._array[i] === searchElement) {
                return i;
            }
        }
        return -1;
    };
    ObservableArray.prototype.lastIndexOf = function (searchElement, fromIndex) {
        var index = fromIndex ? fromIndex : this._array.length - 1;
        for (var i = index; i >= 0; i--) {
            if (this._array[i] === searchElement) {
                return i;
            }
        }
        return -1;
    };
    ObservableArray.prototype.every = function (callbackfn, thisArg) {
        return this._array.every(callbackfn, thisArg);
    };
    ObservableArray.prototype.some = function (callbackfn, thisArg) {
        return this._array.some(callbackfn, thisArg);
    };
    ObservableArray.prototype.forEach = function (callbackfn, thisArg) {
        this._array.forEach(callbackfn, thisArg);
    };
    ObservableArray.prototype.map = function (callbackfn, thisArg) {
        return this._array.map(callbackfn, thisArg);
    };
    ObservableArray.prototype.filter = function (callbackfn, thisArg) {
        return this._array.filter(callbackfn, thisArg);
    };
    ObservableArray.prototype.reduce = function (callbackfn, initialValue) {
        return initialValue !== undefined ? this._array.reduce(callbackfn, initialValue) : this._array.reduce(callbackfn);
    };
    ObservableArray.prototype.reduceRight = function (callbackfn, initialValue) {
        return initialValue !== undefined ? this._array.reduceRight(callbackfn, initialValue) : this._array.reduceRight(callbackfn);
    };
    ObservableArray.changeEvent = CHANGE;
    return ObservableArray;
}(observable.Observable));
exports.ObservableArray = ObservableArray;
//# sourceMappingURL=observable-array.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/data/observable/observable.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var _wrappedIndex = 0;
var WrappedValue = (function () {
    function WrappedValue(wrapped) {
        this.wrapped = wrapped;
    }
    WrappedValue.unwrap = function (value) {
        return (value instanceof WrappedValue) ? value.wrapped : value;
    };
    WrappedValue.wrap = function (value) {
        var w = _wrappedValues[_wrappedIndex++ % 5];
        w.wrapped = value;
        return w;
    };
    return WrappedValue;
}());
exports.WrappedValue = WrappedValue;
var _wrappedValues = [
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null),
    new WrappedValue(null)
];
var Observable = (function () {
    function Observable() {
        this._observers = {};
    }
    Observable.prototype.get = function (name) {
        return this[name];
    };
    Observable.prototype.set = function (name, value) {
        var oldValue = this[name];
        if (this[name] === value) {
            return;
        }
        var newValue = WrappedValue.unwrap(value);
        this[name] = newValue;
        this.notifyPropertyChange(name, newValue, oldValue);
    };
    Observable.prototype.on = function (eventNames, callback, thisArg) {
        this.addEventListener(eventNames, callback, thisArg);
    };
    Observable.prototype.once = function (event, callback, thisArg) {
        var list = this._getEventList(event, true);
        list.push({ callback: callback, thisArg: thisArg, once: true });
    };
    Observable.prototype.off = function (eventNames, callback, thisArg) {
        this.removeEventListener(eventNames, callback, thisArg);
    };
    Observable.prototype.addEventListener = function (eventNames, callback, thisArg) {
        if (typeof eventNames !== "string") {
            throw new TypeError("Events name(s) must be string.");
        }
        if (typeof callback !== "function") {
            throw new TypeError("callback must be function.");
        }
        var events = eventNames.split(",");
        for (var i = 0, l = events.length; i < l; i++) {
            var event_1 = events[i].trim();
            var list = this._getEventList(event_1, true);
            list.push({
                callback: callback,
                thisArg: thisArg
            });
        }
    };
    Observable.prototype.removeEventListener = function (eventNames, callback, thisArg) {
        if (typeof eventNames !== "string") {
            throw new TypeError("Events name(s) must be string.");
        }
        if (callback && typeof callback !== "function") {
            throw new TypeError("callback must be function.");
        }
        var events = eventNames.split(",");
        for (var i = 0, l = events.length; i < l; i++) {
            var event_2 = events[i].trim();
            if (callback) {
                var list = this._getEventList(event_2, false);
                if (list) {
                    var index_1 = this._indexOfListener(list, callback, thisArg);
                    if (index_1 >= 0) {
                        list.splice(index_1, 1);
                    }
                    if (list.length === 0) {
                        delete this._observers[event_2];
                    }
                }
            }
            else {
                this._observers[event_2] = undefined;
                delete this._observers[event_2];
            }
        }
    };
    Observable.prototype.notify = function (data) {
        var observers = this._observers[data.eventName];
        if (!observers) {
            return;
        }
        for (var i = observers.length - 1; i >= 0; i--) {
            var entry = observers[i];
            if (entry.once) {
                observers.splice(i, 1);
            }
            if (entry.thisArg) {
                entry.callback.apply(entry.thisArg, [data]);
            }
            else {
                entry.callback(data);
            }
        }
    };
    Observable.prototype.notifyPropertyChange = function (name, value, oldValue) {
        this.notify(this._createPropertyChangeData(name, value, oldValue));
    };
    Observable.prototype.hasListeners = function (eventName) {
        return eventName in this._observers;
    };
    Observable.prototype._createPropertyChangeData = function (propertyName, value, oldValue) {
        return { eventName: Observable.propertyChangeEvent, object: this, propertyName: propertyName, value: value, oldValue: oldValue };
    };
    Observable.prototype._emit = function (eventNames) {
        var events = eventNames.split(",");
        for (var i = 0, l = events.length; i < l; i++) {
            var event_3 = events[i].trim();
            this.notify({ eventName: event_3, object: this });
        }
    };
    Observable.prototype._getEventList = function (eventName, createIfNeeded) {
        if (!eventName) {
            throw new TypeError("EventName must be valid string.");
        }
        var list = this._observers[eventName];
        if (!list && createIfNeeded) {
            list = [];
            this._observers[eventName] = list;
        }
        return list;
    };
    Observable.prototype._indexOfListener = function (list, callback, thisArg) {
        for (var i = 0; i < list.length; i++) {
            var entry = list[i];
            if (thisArg) {
                if (entry.callback === callback && entry.thisArg === thisArg) {
                    return i;
                }
            }
            else {
                if (entry.callback === callback) {
                    return i;
                }
            }
        }
        return -1;
    };
    Observable.propertyChangeEvent = "propertyChange";
    return Observable;
}());
exports.Observable = Observable;
var ObservableFromObject = (function (_super) {
    __extends(ObservableFromObject, _super);
    function ObservableFromObject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._map = {};
        return _this;
    }
    ObservableFromObject.prototype.get = function (name) {
        return this._map[name];
    };
    ObservableFromObject.prototype.set = function (name, value) {
        var currentValue = this._map[name];
        if (currentValue === value) {
            return;
        }
        var newValue = WrappedValue.unwrap(value);
        this._map[name] = newValue;
        this.notifyPropertyChange(name, newValue, currentValue);
    };
    return ObservableFromObject;
}(Observable));
function defineNewProperty(target, propertyName) {
    Object.defineProperty(target, propertyName, {
        get: function () {
            return target._map[propertyName];
        },
        set: function (value) {
            target.set(propertyName, value);
        },
        enumerable: true,
        configurable: true
    });
}
function addPropertiesFromObject(observable, source, recursive) {
    if (recursive === void 0) { recursive = false; }
    Object.keys(source).forEach(function (prop) {
        var value = source[prop];
        if (recursive
            && !Array.isArray(value)
            && value
            && typeof value === "object"
            && !(value instanceof Observable)) {
            value = fromObjectRecursive(value);
        }
        defineNewProperty(observable, prop);
        observable.set(prop, value);
    });
}
function fromObject(source) {
    var observable = new ObservableFromObject();
    addPropertiesFromObject(observable, source, false);
    return observable;
}
exports.fromObject = fromObject;
function fromObjectRecursive(source) {
    var observable = new ObservableFromObject();
    addPropertiesFromObject(observable, source, true);
    return observable;
}
exports.fromObjectRecursive = fromObjectRecursive;
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/InspectorBackendCommands.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
function DomainDispatcher(domain) {
    return function (klass) { return __registerDomainDispatcher(domain, klass); };
}
exports.DomainDispatcher = DomainDispatcher;
var HeapDomain;
(function (HeapDomain) {
    var HeapFrontend = (function () {
        function HeapFrontend() {
        }
        HeapFrontend.prototype.garbageCollected = function (collection) {
            __inspectorSendEvent(JSON.stringify({ "method": "Heap.garbageCollected", "params": { "collection": collection } }));
        };
        HeapFrontend.prototype.trackingStart = function (timestamp, snapshotData) {
            __inspectorSendEvent(JSON.stringify({ "method": "Heap.trackingStart", "params": { "timestamp": timestamp, "snapshotData": snapshotData } }));
        };
        HeapFrontend.prototype.trackingComplete = function (timestamp, snapshotData) {
            __inspectorSendEvent(JSON.stringify({ "method": "Heap.trackingComplete", "params": { "timestamp": timestamp, "snapshotData": snapshotData } }));
        };
        return HeapFrontend;
    }());
    HeapDomain.HeapFrontend = HeapFrontend;
})(HeapDomain = exports.HeapDomain || (exports.HeapDomain = {}));
var DebuggerDomain;
(function (DebuggerDomain) {
    var DebuggerFrontend = (function () {
        function DebuggerFrontend() {
        }
        DebuggerFrontend.prototype.globalObjectCleared = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.globalObjectCleared", "params": {} }));
        };
        DebuggerFrontend.prototype.scriptParsed = function (scriptId, url, startLine, startColumn, endLine, endColumn, isContentScript, sourceURL, sourceMapURL) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.scriptParsed", "params": { "scriptId": scriptId, "url": url, "startLine": startLine, "startColumn": startColumn, "endLine": endLine, "endColumn": endColumn, "isContentScript": isContentScript, "sourceURL": sourceURL, "sourceMapURL": sourceMapURL } }));
        };
        DebuggerFrontend.prototype.scriptFailedToParse = function (url, scriptSource, startLine, errorLine, errorMessage) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.scriptFailedToParse", "params": { "url": url, "scriptSource": scriptSource, "startLine": startLine, "errorLine": errorLine, "errorMessage": errorMessage } }));
        };
        DebuggerFrontend.prototype.breakpointResolved = function (breakpointId, location) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.breakpointResolved", "params": { "breakpointId": breakpointId, "location": location } }));
        };
        DebuggerFrontend.prototype.paused = function (callFrames, reason, data) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.paused", "params": { "callFrames": callFrames, "reason": reason, "data": data } }));
        };
        DebuggerFrontend.prototype.resumed = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.resumed", "params": {} }));
        };
        DebuggerFrontend.prototype.didSampleProbe = function (sample) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.didSampleProbe", "params": { "sample": sample } }));
        };
        DebuggerFrontend.prototype.playBreakpointActionSound = function (breakpointActionId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Debugger.playBreakpointActionSound", "params": { "breakpointActionId": breakpointActionId } }));
        };
        return DebuggerFrontend;
    }());
    DebuggerDomain.DebuggerFrontend = DebuggerFrontend;
})(DebuggerDomain = exports.DebuggerDomain || (exports.DebuggerDomain = {}));
var RuntimeDomain;
(function (RuntimeDomain) {
    ;
    var RuntimeFrontend = (function () {
        function RuntimeFrontend() {
        }
        RuntimeFrontend.prototype.executionContextCreated = function (context) {
            __inspectorSendEvent(JSON.stringify({ "method": "Runtime.executionContextCreated", "params": { "context": context } }));
        };
        return RuntimeFrontend;
    }());
    RuntimeDomain.RuntimeFrontend = RuntimeFrontend;
})(RuntimeDomain = exports.RuntimeDomain || (exports.RuntimeDomain = {}));
var ConsoleDomain;
(function (ConsoleDomain) {
    var ConsoleFrontend = (function () {
        function ConsoleFrontend() {
        }
        ConsoleFrontend.prototype.messageAdded = function (message) {
            __inspectorSendEvent(JSON.stringify({ "method": "Console.messageAdded", "params": { "message": message } }));
        };
        ConsoleFrontend.prototype.messageRepeatCountUpdated = function (count) {
            __inspectorSendEvent(JSON.stringify({ "method": "Console.messageRepeatCountUpdated", "params": { "count": count } }));
        };
        ConsoleFrontend.prototype.messagesCleared = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "Console.messagesCleared", "params": {} }));
        };
        ConsoleFrontend.prototype.heapSnapshot = function (timestamp, snapshotData, title) {
            __inspectorSendEvent(JSON.stringify({ "method": "Console.heapSnapshot", "params": { "timestamp": timestamp, "snapshotData": snapshotData, "title": title } }));
        };
        return ConsoleFrontend;
    }());
    ConsoleDomain.ConsoleFrontend = ConsoleFrontend;
})(ConsoleDomain = exports.ConsoleDomain || (exports.ConsoleDomain = {}));
var PageDomain;
(function (PageDomain) {
    ;
    ;
    var PageFrontend = (function () {
        function PageFrontend() {
        }
        PageFrontend.prototype.domContentEventFired = function (timestamp) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.domContentEventFired", "params": { "timestamp": timestamp } }));
        };
        PageFrontend.prototype.loadEventFired = function (timestamp) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.loadEventFired", "params": { "timestamp": timestamp } }));
        };
        PageFrontend.prototype.frameNavigated = function (frame) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameNavigated", "params": { "frame": frame } }));
        };
        PageFrontend.prototype.frameDetached = function (frameId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameDetached", "params": { "frameId": frameId } }));
        };
        PageFrontend.prototype.frameStartedLoading = function (frameId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameStartedLoading", "params": { "frameId": frameId } }));
        };
        PageFrontend.prototype.frameStoppedLoading = function (frameId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameStoppedLoading", "params": { "frameId": frameId } }));
        };
        PageFrontend.prototype.frameScheduledNavigation = function (frameId, delay) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameScheduledNavigation", "params": { "frameId": frameId, "delay": delay } }));
        };
        PageFrontend.prototype.frameClearedScheduledNavigation = function (frameId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.frameClearedScheduledNavigation", "params": { "frameId": frameId } }));
        };
        PageFrontend.prototype.javascriptDialogOpening = function (message) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.javascriptDialogOpening", "params": { "message": message } }));
        };
        PageFrontend.prototype.javascriptDialogClosed = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.javascriptDialogClosed", "params": {} }));
        };
        PageFrontend.prototype.scriptsEnabled = function (isEnabled) {
            __inspectorSendEvent(JSON.stringify({ "method": "Page.scriptsEnabled", "params": { "isEnabled": isEnabled } }));
        };
        return PageFrontend;
    }());
    PageDomain.PageFrontend = PageFrontend;
})(PageDomain = exports.PageDomain || (exports.PageDomain = {}));
var NetworkDomain;
(function (NetworkDomain) {
    var NetworkFrontend = (function () {
        function NetworkFrontend() {
        }
        NetworkFrontend.prototype.requestWillBeSent = function (requestId, frameId, loaderId, documentURL, request, timestamp, initiator, redirectResponse, type) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.requestWillBeSent", "params": { "requestId": requestId, "frameId": frameId, "loaderId": loaderId, "documentURL": documentURL, "request": request, "timestamp": timestamp, "initiator": initiator, "redirectResponse": redirectResponse, "type": type } }));
        };
        NetworkFrontend.prototype.requestServedFromCache = function (requestId) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.requestServedFromCache", "params": { "requestId": requestId } }));
        };
        NetworkFrontend.prototype.responseReceived = function (requestId, frameId, loaderId, timestamp, type, response) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.responseReceived", "params": { "requestId": requestId, "frameId": frameId, "loaderId": loaderId, "timestamp": timestamp, "type": type, "response": response } }));
        };
        NetworkFrontend.prototype.dataReceived = function (requestId, timestamp, dataLength, encodedDataLength) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.dataReceived", "params": { "requestId": requestId, "timestamp": timestamp, "dataLength": dataLength, "encodedDataLength": encodedDataLength } }));
        };
        NetworkFrontend.prototype.loadingFinished = function (requestId, timestamp, sourceMapURL) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.loadingFinished", "params": { "requestId": requestId, "timestamp": timestamp, "sourceMapURL": sourceMapURL } }));
        };
        NetworkFrontend.prototype.loadingFailed = function (requestId, timestamp, errorText, canceled) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.loadingFailed", "params": { "requestId": requestId, "timestamp": timestamp, "errorText": errorText, "canceled": canceled } }));
        };
        NetworkFrontend.prototype.requestServedFromMemoryCache = function (requestId, frameId, loaderId, documentURL, timestamp, initiator, resource) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.requestServedFromMemoryCache", "params": { "requestId": requestId, "frameId": frameId, "loaderId": loaderId, "documentURL": documentURL, "timestamp": timestamp, "initiator": initiator, "resource": resource } }));
        };
        NetworkFrontend.prototype.webSocketWillSendHandshakeRequest = function (requestId, timestamp, request) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketWillSendHandshakeRequest", "params": { "requestId": requestId, "timestamp": timestamp, "request": request } }));
        };
        NetworkFrontend.prototype.webSocketHandshakeResponseReceived = function (requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketHandshakeResponseReceived", "params": { "requestId": requestId, "timestamp": timestamp, "response": response } }));
        };
        NetworkFrontend.prototype.webSocketCreated = function (requestId, url) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketCreated", "params": { "requestId": requestId, "url": url } }));
        };
        NetworkFrontend.prototype.webSocketClosed = function (requestId, timestamp) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketClosed", "params": { "requestId": requestId, "timestamp": timestamp } }));
        };
        NetworkFrontend.prototype.webSocketFrameReceived = function (requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketFrameReceived", "params": { "requestId": requestId, "timestamp": timestamp, "response": response } }));
        };
        NetworkFrontend.prototype.webSocketFrameError = function (requestId, timestamp, errorMessage) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketFrameError", "params": { "requestId": requestId, "timestamp": timestamp, "errorMessage": errorMessage } }));
        };
        NetworkFrontend.prototype.webSocketFrameSent = function (requestId, timestamp, response) {
            __inspectorSendEvent(JSON.stringify({ "method": "Network.webSocketFrameSent", "params": { "requestId": requestId, "timestamp": timestamp, "response": response } }));
        };
        return NetworkFrontend;
    }());
    NetworkDomain.NetworkFrontend = NetworkFrontend;
})(NetworkDomain = exports.NetworkDomain || (exports.NetworkDomain = {}));
var DOMDomain;
(function (DOMDomain) {
    ;
    ;
    ;
    var DOMFrontend = (function () {
        function DOMFrontend() {
        }
        DOMFrontend.prototype.documentUpdated = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.documentUpdated", "params": {} }));
        };
        DOMFrontend.prototype.setChildNodes = function (parentId, nodes) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.setChildNodes", "params": { "parentId": parentId, "nodes": nodes } }));
        };
        DOMFrontend.prototype.attributeModified = function (nodeId, name, value) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.attributeModified", "params": { "nodeId": nodeId, "name": name, "value": value } }));
        };
        DOMFrontend.prototype.attributeRemoved = function (nodeId, name) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.attributeRemoved", "params": { "nodeId": nodeId, "name": name } }));
        };
        DOMFrontend.prototype.inlineStyleInvalidated = function (nodeIds) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.inlineStyleInvalidated", "params": { "nodeIds": nodeIds } }));
        };
        DOMFrontend.prototype.characterDataModified = function (nodeId, characterData) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.characterDataModified", "params": { "nodeId": nodeId, "characterData": characterData } }));
        };
        DOMFrontend.prototype.childNodeCountUpdated = function (nodeId, childNodeCount) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.childNodeCountUpdated", "params": { "nodeId": nodeId, "childNodeCount": childNodeCount } }));
        };
        DOMFrontend.prototype.childNodeInserted = function (parentNodeId, previousNodeId, node) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.childNodeInserted", "params": { "parentNodeId": parentNodeId, "previousNodeId": previousNodeId, "node": node } }));
        };
        DOMFrontend.prototype.childNodeRemoved = function (parentNodeId, nodeId) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.childNodeRemoved", "params": { "parentNodeId": parentNodeId, "nodeId": nodeId } }));
        };
        DOMFrontend.prototype.shadowRootPushed = function (hostId, root) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.shadowRootPushed", "params": { "hostId": hostId, "root": root } }));
        };
        DOMFrontend.prototype.shadowRootPopped = function (hostId, rootId) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.shadowRootPopped", "params": { "hostId": hostId, "rootId": rootId } }));
        };
        DOMFrontend.prototype.pseudoElementAdded = function (parentId, pseudoElement) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.pseudoElementAdded", "params": { "parentId": parentId, "pseudoElement": pseudoElement } }));
        };
        DOMFrontend.prototype.pseudoElementRemoved = function (parentId, pseudoElementId) {
            __inspectorSendEvent(JSON.stringify({ "method": "DOM.pseudoElementRemoved", "params": { "parentId": parentId, "pseudoElementId": pseudoElementId } }));
        };
        return DOMFrontend;
    }());
    DOMDomain.DOMFrontend = DOMFrontend;
})(DOMDomain = exports.DOMDomain || (exports.DOMDomain = {}));
var CSSDomain;
(function (CSSDomain) {
    ;
    var CSSFrontend = (function () {
        function CSSFrontend() {
        }
        CSSFrontend.prototype.mediaQueryResultChanged = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.mediaQueryResultChanged", "params": {} }));
        };
        CSSFrontend.prototype.fontsUpdated = function () {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.fontsUpdated", "params": {} }));
        };
        CSSFrontend.prototype.styleSheetChanged = function (styleSheetId) {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.styleSheetChanged", "params": { "styleSheetId": styleSheetId } }));
        };
        CSSFrontend.prototype.styleSheetAdded = function (header) {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.styleSheetAdded", "params": { "header": header } }));
        };
        CSSFrontend.prototype.styleSheetRemoved = function (styleSheetId) {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.styleSheetRemoved", "params": { "styleSheetId": styleSheetId } }));
        };
        CSSFrontend.prototype.layoutEditorChange = function (styleSheetId, changeRange) {
            __inspectorSendEvent(JSON.stringify({ "method": "CSS.layoutEditorChange", "params": { "styleSheetId": styleSheetId, "changeRange": changeRange } }));
        };
        return CSSFrontend;
    }());
    CSSDomain.CSSFrontend = CSSFrontend;
})(CSSDomain = exports.CSSDomain || (exports.CSSDomain = {}));
//# sourceMappingURL=InspectorBackendCommands.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/debugger.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var network;
function getNetwork() {
    return network;
}
exports.getNetwork = getNetwork;
function setNetwork(newNetwork) {
    network = newNetwork;
}
exports.setNetwork = setNetwork;
var dom;
function getDOM() {
    return dom;
}
exports.getDOM = getDOM;
function setDOM(newDOM) {
    dom = newDOM;
}
exports.setDOM = setDOM;
var css;
function getCSS() {
    return css;
}
exports.getCSS = getCSS;
function setCSS(newCSS) {
    css = newCSS;
}
exports.setCSS = setCSS;
var NetworkAgent;
(function (NetworkAgent) {
    function responseReceived(requestId, result, headers) {
        var requestIdStr = requestId.toString();
        var mimeType = headers["Content-Type"] || headers["content-type"] || "application/octet-stream";
        var contentLengthHeader = headers["Content-Length"] || headers["content-length"];
        var contentLength = parseInt(contentLengthHeader, 10);
        if (isNaN(contentLength)) {
            contentLength = 0;
        }
        var response = {
            url: result.url || "",
            status: result.statusCode,
            statusText: result.statusText || "",
            headers: headers,
            mimeType: mimeType,
            fromDiskCache: false,
            connectionReused: true,
            connectionId: 0,
            encodedDataLength: contentLength,
            securityState: "info"
        };
        var responseData = {
            requestId: requestIdStr,
            type: mimeTypeToType(response.mimeType),
            response: response,
            timestamp: getTimeStamp()
        };
        global.__inspector.responseReceived(responseData);
        global.__inspector.loadingFinished({
            requestId: requestIdStr,
            timestamp: getTimeStamp(),
            encodedDataLength: contentLength
        });
        var hasTextContent = responseData.type === "Document" || responseData.type === "Script";
        var data;
        if (!hasTextContent) {
            if (responseData.type === "Image") {
                var bitmap = result.responseAsImage;
                if (bitmap) {
                    var outputStream = new java.io.ByteArrayOutputStream();
                    bitmap.compress(android.graphics.Bitmap.CompressFormat.PNG, 100, outputStream);
                    var base64Image = android.util.Base64.encodeToString(outputStream.toByteArray(), android.util.Base64.DEFAULT);
                    data = base64Image;
                }
            }
        }
        else {
            data = result.responseAsString;
        }
        var successfulRequestData = {
            requestId: requestIdStr,
            data: data,
            hasTextContent: hasTextContent
        };
        global.__inspector.dataForRequestId(successfulRequestData);
    }
    NetworkAgent.responseReceived = responseReceived;
    function requestWillBeSent(requestId, options) {
        var request = {
            url: options.url,
            method: options.method,
            headers: options.headers || {},
            postData: options.content ? options.content.toString() : "",
            initialPriority: "Medium",
            referrerPolicy: "no-referrer-when-downgrade"
        };
        var requestData = {
            requestId: requestId.toString(),
            url: request.url,
            request: request,
            timestamp: getTimeStamp(),
            type: "Document",
            wallTime: 0
        };
        global.__inspector.requestWillBeSent(requestData);
    }
    NetworkAgent.requestWillBeSent = requestWillBeSent;
    function getTimeStamp() {
        var d = new Date();
        return Math.round(d.getTime() / 1000);
    }
    function mimeTypeToType(mimeType) {
        var type = "Document";
        if (mimeType) {
            if (mimeType.indexOf("image") === 0) {
                type = "Image";
            }
            else if (mimeType.indexOf("javascript") !== -1 || mimeType.indexOf("json") !== -1) {
                type = "Script";
            }
        }
        return type;
    }
})(NetworkAgent = exports.NetworkAgent || (exports.NetworkAgent = {}));
//# sourceMappingURL=debugger.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/devtools-elements.common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var dom_node_1 = __webpack_require__("../node_modules/tns-core-modules/debugger/dom-node.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var frameTopmost = function () { return __webpack_require__("../node_modules/tns-core-modules/ui/frame/frame.js").topmost(); };
var unsetValue;
function unsetViewValue(view, name) {
    if (!unsetValue) {
        unsetValue = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js").unsetValue;
    }
    view[name] = unsetValue;
}
function getViewById(nodeId) {
    var node = dom_node_1.getNodeById(nodeId);
    var view;
    if (node) {
        view = node.viewRef.get();
    }
    return view;
}
function getDocument() {
    var topMostFrame = frameTopmost();
    if (!topMostFrame) {
        return undefined;
    }
    try {
        topMostFrame.ensureDomNode();
    }
    catch (e) {
        console.log("ERROR in getDocument(): " + e);
    }
    return topMostFrame.domNode.toObject();
}
exports.getDocument = getDocument;
function getComputedStylesForNode(nodeId) {
    var view = getViewById(nodeId);
    if (view) {
        return view.domNode.getComputedProperties();
    }
    return [];
}
exports.getComputedStylesForNode = getComputedStylesForNode;
exports.removeNode = utils_1.mainThreadify(function removeNode(nodeId) {
    var view = getViewById(nodeId);
    if (view) {
        var parent_1 = view.parent;
        if (parent_1.removeChild) {
            parent_1.removeChild(view);
        }
        else if (parent_1.content === view) {
            parent_1.content = null;
        }
        else {
            console.log("Can't remove child from " + parent_1);
        }
    }
});
exports.setAttributeAsText = utils_1.mainThreadify(function setAttributeAsText(nodeId, text, name) {
    var view = getViewById(nodeId);
    if (view) {
        var hasOriginalAttribute = !!name.trim();
        if (text) {
            var textParts = text.split("=");
            if (textParts.length === 2) {
                var attrName = textParts[0];
                var attrValue = textParts[1].replace(/['"]+/g, "");
                if (name !== attrName && hasOriginalAttribute) {
                    unsetViewValue(view, name);
                    view[attrName] = attrValue;
                }
                else {
                    view[hasOriginalAttribute ? name : attrName] = attrValue;
                }
            }
        }
        else {
            unsetViewValue(view, name);
        }
        view.domNode.loadAttributes();
    }
});
//# sourceMappingURL=devtools-elements.common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/devtools-elements.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var devtools_elements_common_1 = __webpack_require__("../node_modules/tns-core-modules/debugger/devtools-elements.common.js");
var dom_node_1 = __webpack_require__("../node_modules/tns-core-modules/debugger/dom-node.js");
function attachDOMInspectorEventCallbacks(DOMDomainFrontend) {
    dom_node_1.registerInspectorEvents(DOMDomainFrontend);
    var originalChildNodeInserted = DOMDomainFrontend.childNodeInserted;
    DOMDomainFrontend.childNodeInserted = function (parentId, lastId, node) {
        originalChildNodeInserted(parentId, lastId, node.toObject());
    };
}
exports.attachDOMInspectorEventCallbacks = attachDOMInspectorEventCallbacks;
function attachDOMInspectorCommandCallbacks(DOMDomainBackend) {
    DOMDomainBackend.getDocument = devtools_elements_common_1.getDocument;
    DOMDomainBackend.removeNode = devtools_elements_common_1.removeNode;
    DOMDomainBackend.setAttributeAsText = devtools_elements_common_1.setAttributeAsText;
}
exports.attachDOMInspectorCommandCallbacks = attachDOMInspectorCommandCallbacks;
function attachCSSInspectorCommandCallbacks(CSSDomainBackend) {
    CSSDomainBackend.getComputedStylesForNode = devtools_elements_common_1.getComputedStylesForNode;
}
exports.attachCSSInspectorCommandCallbacks = attachCSSInspectorCommandCallbacks;
//# sourceMappingURL=devtools-elements.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/dom-node.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var registeredDomNodes = {};
var ELEMENT_NODE_TYPE = 1;
var ROOT_NODE_TYPE = 9;
var propertyBlacklist = [
    "effectivePaddingLeft",
    "effectivePaddingBottom",
    "effectivePaddingRight",
    "effectivePaddingTop",
    "effectiveBorderTopWidth",
    "effectiveBorderRightWidth",
    "effectiveBorderBottomWidth",
    "effectiveBorderLeftWidth",
    "effectiveMinWidth",
    "effectiveMinHeight",
    "effectiveWidth",
    "effectiveHeight",
    "effectiveMarginLeft",
    "effectiveMarginTop",
    "effectiveMarginRight",
    "effectiveMarginBottom",
    "nodeName",
    "nodeType",
    "decodeWidth",
    "decodeHeight",
    "ng-reflect-items",
    "domNode",
    "touchListenerIsSet",
    "bindingContext",
    "nativeView"
];
function lazy(action) {
    var _value;
    return function () { return _value || (_value = action()); };
}
var percentLengthToStringLazy = lazy(function () { return __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js").PercentLength.convertToString; });
var getSetPropertiesLazy = lazy(function () { return __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js").getSetProperties; });
var getComputedCssValuesLazy = lazy(function () { return __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js").getComputedCssValues; });
function registerInspectorEvents(inspector) {
    inspectorFrontendInstance = inspector;
}
exports.registerInspectorEvents = registerInspectorEvents;
var inspectorFrontendInstance;
function notifyInspector(callback) {
    if (inspectorFrontendInstance) {
        callback(inspectorFrontendInstance);
    }
}
function valueToString(value) {
    if (typeof value === "undefined" || value === null) {
        return "";
    }
    else if (typeof value === "object" && value.unit) {
        return percentLengthToStringLazy()(value);
    }
    else {
        return value + "";
    }
}
function propertyFilter(_a) {
    var name = _a[0], value = _a[1];
    if (name[0] === "_") {
        return false;
    }
    if (value !== null && typeof value === "object") {
        return false;
    }
    if (propertyBlacklist.indexOf(name) >= 0) {
        return false;
    }
    return true;
}
function registerNode(domNode) {
    registeredDomNodes[domNode.nodeId] = domNode;
}
function unregisterNode(domNode) {
    delete registeredDomNodes[domNode.nodeId];
}
function getNodeById(id) {
    return registeredDomNodes[id];
}
exports.getNodeById = getNodeById;
var DOMNode = (function () {
    function DOMNode(view) {
        this.nodeValue = "";
        this.attributes = [];
        this.viewRef = new WeakRef(view);
        this.nodeType = view.typeName === "Frame" ? ROOT_NODE_TYPE : ELEMENT_NODE_TYPE;
        this.nodeId = view._domId;
        this.nodeName = view.typeName;
        this.localName = this.nodeName;
        this.loadAttributes();
        registerNode(this);
    }
    DOMNode.prototype.loadAttributes = function () {
        var _this = this;
        this.attributes = [];
        getSetPropertiesLazy()(this.viewRef.get())
            .filter(propertyFilter)
            .forEach(function (pair) { return _this.attributes.push(pair[0], pair[1] + ""); });
    };
    Object.defineProperty(DOMNode.prototype, "children", {
        get: function () {
            var view = this.viewRef.get();
            if (!view) {
                return [];
            }
            var res = [];
            view.eachChild(function (child) {
                child.ensureDomNode();
                res.push(child.domNode);
                return true;
            });
            return res;
        },
        enumerable: true,
        configurable: true
    });
    DOMNode.prototype.onChildAdded = function (childView) {
        var _this = this;
        notifyInspector(function (ins) {
            var view = _this.viewRef.get();
            var previousChild;
            view.eachChild(function (child) {
                if (child === childView) {
                    return false;
                }
                previousChild = child;
                return true;
            });
            var index = !!previousChild ? previousChild._domId : 0;
            childView.ensureDomNode();
            ins.childNodeInserted(_this.nodeId, index, childView.domNode);
        });
    };
    DOMNode.prototype.onChildRemoved = function (view) {
        var _this = this;
        notifyInspector(function (ins) {
            ins.childNodeRemoved(_this.nodeId, view._domId);
        });
    };
    DOMNode.prototype.attributeModified = function (name, value) {
        var _this = this;
        notifyInspector(function (ins) {
            if (propertyBlacklist.indexOf(name) < 0) {
                ins.attributeModified(_this.nodeId, name, valueToString(value));
            }
        });
    };
    DOMNode.prototype.attributeRemoved = function (name) {
        var _this = this;
        notifyInspector(function (ins) {
            ins.attributeRemoved(_this.nodeId, name);
        });
    };
    DOMNode.prototype.getComputedProperties = function () {
        var view = this.viewRef.get();
        if (!view) {
            return [];
        }
        var result = getComputedCssValuesLazy()(view)
            .filter(function (pair) { return pair[0][0] !== "_"; })
            .map(function (pair) {
            return {
                name: pair[0],
                value: valueToString(pair[1])
            };
        });
        return result;
    };
    DOMNode.prototype.dispose = function () {
        unregisterNode(this);
        this.viewRef.clear();
    };
    DOMNode.prototype.toObject = function () {
        return {
            nodeId: this.nodeId,
            nodeType: this.nodeType,
            nodeName: this.nodeName,
            localName: this.localName,
            nodeValue: this.nodeValue,
            children: this.children.map(function (c) { return c.toObject(); }),
            attributes: this.attributes,
            backendNodeId: 0
        };
    };
    return DOMNode;
}());
exports.DOMNode = DOMNode;
//# sourceMappingURL=dom-node.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/webinspector-css.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var inspectorCommands = __webpack_require__("../node_modules/tns-core-modules/debugger/InspectorBackendCommands.js");
var debuggerDomains = __webpack_require__("../node_modules/tns-core-modules/debugger/debugger.js");
var devtools_elements_1 = __webpack_require__("../node_modules/tns-core-modules/debugger/devtools-elements.js");
var CSSDomainDebugger = (function () {
    function CSSDomainDebugger() {
        this.events = new inspectorCommands.CSSDomain.CSSFrontend();
        this.commands = {};
        devtools_elements_1.attachCSSInspectorCommandCallbacks(this.commands);
        this.enable();
    }
    Object.defineProperty(CSSDomainDebugger.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    CSSDomainDebugger.prototype.enable = function () {
        if (debuggerDomains.getCSS()) {
            throw new Error("One CSSDomainDebugger may be enabled at a time.");
        }
        else {
            debuggerDomains.setCSS(this);
        }
        this._enabled = true;
    };
    CSSDomainDebugger.prototype.disable = function () {
        if (debuggerDomains.getCSS() === this) {
            debuggerDomains.setCSS(null);
        }
        this._enabled = false;
    };
    CSSDomainDebugger.prototype.getMatchedStylesForNode = function (params) {
        return {};
    };
    CSSDomainDebugger.prototype.getInlineStylesForNode = function (params) {
        return {};
    };
    CSSDomainDebugger.prototype.getComputedStyleForNode = function (params) {
        return { computedStyle: this.commands.getComputedStylesForNode(params.nodeId) };
    };
    CSSDomainDebugger.prototype.getPlatformFontsForNode = function (params) {
        return {
            fonts: [
                {
                    familyName: "Standard Font",
                    isCustomFont: false,
                    glyphCount: 0
                }
            ]
        };
    };
    CSSDomainDebugger.prototype.getStyleSheetText = function (params) {
        return null;
    };
    CSSDomainDebugger = __decorate([
        inspectorCommands.DomainDispatcher("CSS")
    ], CSSDomainDebugger);
    return CSSDomainDebugger;
}());
exports.CSSDomainDebugger = CSSDomainDebugger;
//# sourceMappingURL=webinspector-css.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/webinspector-dom.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var inspectorCommands = __webpack_require__("../node_modules/tns-core-modules/debugger/InspectorBackendCommands.js");
var debuggerDomains = __webpack_require__("../node_modules/tns-core-modules/debugger/debugger.js");
var devtools_elements_1 = __webpack_require__("../node_modules/tns-core-modules/debugger/devtools-elements.js");
var DOMDomainDebugger = (function () {
    function DOMDomainDebugger() {
        this.events = new inspectorCommands.DOMDomain.DOMFrontend();
        this.commands = {};
        devtools_elements_1.attachDOMInspectorEventCallbacks(this.events);
        devtools_elements_1.attachDOMInspectorCommandCallbacks(this.commands);
        this.enable();
    }
    Object.defineProperty(DOMDomainDebugger.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    DOMDomainDebugger.prototype.enable = function () {
        if (debuggerDomains.getDOM()) {
            throw new Error("One DOMDomainDebugger may be enabled at a time.");
        }
        else {
            debuggerDomains.setDOM(this);
        }
        this._enabled = true;
    };
    DOMDomainDebugger.prototype.disable = function () {
        if (debuggerDomains.getDOM() === this) {
            debuggerDomains.setDOM(null);
        }
        this._enabled = false;
    };
    DOMDomainDebugger.prototype.getDocument = function () {
        var domNode = this.commands.getDocument();
        return { root: domNode };
    };
    DOMDomainDebugger.prototype.removeNode = function (params) {
        this.commands.removeNode(params.nodeId);
    };
    DOMDomainDebugger.prototype.setAttributeValue = function (params) {
        throw new Error("Method not implemented.");
    };
    DOMDomainDebugger.prototype.setAttributesAsText = function (params) {
        this.commands.setAttributeAsText(params.nodeId, params.text, params.name);
    };
    DOMDomainDebugger.prototype.removeAttribute = function (params) {
        throw new Error("Method not implemented.");
    };
    DOMDomainDebugger.prototype.performSearch = function (params) {
        return null;
    };
    DOMDomainDebugger.prototype.getSearchResults = function (params) {
        return null;
    };
    DOMDomainDebugger.prototype.discardSearchResults = function (params) {
        return;
    };
    DOMDomainDebugger.prototype.highlightNode = function (params) {
        return;
    };
    DOMDomainDebugger.prototype.hideHighlight = function () {
        return;
    };
    DOMDomainDebugger.prototype.resolveNode = function (params) {
        return null;
    };
    DOMDomainDebugger = __decorate([
        inspectorCommands.DomainDispatcher("DOM")
    ], DOMDomainDebugger);
    return DOMDomainDebugger;
}());
exports.DOMDomainDebugger = DOMDomainDebugger;
//# sourceMappingURL=webinspector-dom.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/debugger/webinspector-network.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var inspectorCommands = __webpack_require__("../node_modules/tns-core-modules/debugger/InspectorBackendCommands.js");
var debuggerDomains = __webpack_require__("../node_modules/tns-core-modules/debugger/debugger.js");
var frameId = "NativeScriptMainFrameIdentifier";
var loaderId = "Loader Identifier";
var resources_datas = [];
var documentTypeByMimeType = {
    "text/xml": "Document",
    "text/plain": "Document",
    "text/html": "Document",
    "application/xml": "Document",
    "application/xhtml+xml": "Document",
    "text/css": "Stylesheet",
    "text/javascript": "Script",
    "text/ecmascript": "Script",
    "application/javascript": "Script",
    "application/ecmascript": "Script",
    "application/x-javascript": "Script",
    "application/json": "Script",
    "application/x-json": "Script",
    "text/x-javascript": "Script",
    "text/x-json": "Script",
    "text/typescript": "Script"
};
var Request = (function () {
    function Request(_networkDomainDebugger, _requestID) {
        this._networkDomainDebugger = _networkDomainDebugger;
        this._requestID = _requestID;
    }
    Object.defineProperty(Request.prototype, "mimeType", {
        get: function () {
            return this._mimeType;
        },
        set: function (value) {
            if (this._mimeType !== value) {
                if (!value) {
                    this._mimeType = "text/plain";
                    this._resourceType = "Other";
                    return;
                }
                this._mimeType = value;
                var resourceType = "Other";
                if (this._mimeType in documentTypeByMimeType) {
                    resourceType = documentTypeByMimeType[this._mimeType];
                }
                if (this._mimeType.indexOf("image/") !== -1) {
                    resourceType = "Image";
                }
                if (this._mimeType.indexOf("font/") !== -1) {
                    resourceType = "Font";
                }
                this._resourceType = resourceType;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Request.prototype, "requestID", {
        get: function () {
            return this._requestID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Request.prototype, "hasTextContent", {
        get: function () {
            return ["Document", "Stylesheet", "Script", "XHR"].indexOf(this._resourceType) !== -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Request.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (value) {
            if (this._data !== value) {
                this._data = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Request.prototype, "resourceType", {
        get: function () {
            return this._resourceType;
        },
        set: function (value) {
            if (this._resourceType !== value) {
                this._resourceType = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Request.prototype.responseReceived = function (response) {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.responseReceived(this.requestID, frameId, loaderId, __inspectorTimestamp(), this.resourceType, response);
        }
    };
    Request.prototype.loadingFinished = function () {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.loadingFinished(this.requestID, __inspectorTimestamp());
        }
    };
    Request.prototype.requestWillBeSent = function (request) {
        if (this._networkDomainDebugger.enabled) {
            this._networkDomainDebugger.events.requestWillBeSent(this.requestID, frameId, loaderId, request.url, request, __inspectorTimestamp(), { type: "Script" });
        }
    };
    return Request;
}());
exports.Request = Request;
var NetworkDomainDebugger = (function () {
    function NetworkDomainDebugger() {
        this.events = new inspectorCommands.NetworkDomain.NetworkFrontend();
        this.enable();
    }
    NetworkDomainDebugger_1 = NetworkDomainDebugger;
    Object.defineProperty(NetworkDomainDebugger.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    NetworkDomainDebugger.prototype.enable = function () {
        if (debuggerDomains.getNetwork()) {
            throw new Error("One NetworkDomainDebugger may be enabled at a time.");
        }
        else {
            debuggerDomains.setNetwork(this);
        }
        this._enabled = true;
    };
    NetworkDomainDebugger.prototype.disable = function () {
        if (debuggerDomains.getNetwork() === this) {
            debuggerDomains.setNetwork(null);
        }
        this._enabled = false;
    };
    NetworkDomainDebugger.prototype.setExtraHTTPHeaders = function (params) {
    };
    NetworkDomainDebugger.prototype.getResponseBody = function (params) {
        var resource_data = resources_datas[params.requestId];
        var body = resource_data.hasTextContent ? NSString.alloc().initWithDataEncoding(resource_data.data, 4).toString() :
            resource_data.data.base64EncodedStringWithOptions(0);
        if (resource_data) {
            return {
                body: body,
                base64Encoded: !resource_data.hasTextContent
            };
        }
    };
    NetworkDomainDebugger.prototype.canClearBrowserCache = function () {
        return {
            result: false
        };
    };
    NetworkDomainDebugger.prototype.clearBrowserCache = function () {
    };
    NetworkDomainDebugger.prototype.canClearBrowserCookies = function () {
        return {
            result: false
        };
    };
    NetworkDomainDebugger.prototype.clearBrowserCookies = function () {
    };
    NetworkDomainDebugger.prototype.setCacheDisabled = function (params) {
    };
    NetworkDomainDebugger.prototype.loadResource = function (params) {
        var appPath = NSBundle.mainBundle.bundlePath;
        var pathUrl = params.url.replace("file://", appPath);
        var fileManager = NSFileManager.defaultManager;
        var data = fileManager.fileExistsAtPath(pathUrl) ? fileManager.contentsAtPath(pathUrl) : undefined;
        var content = data ? NSString.alloc().initWithDataEncoding(data, NSUTF8StringEncoding) : "";
        return {
            content: content.toString(),
            mimeType: "application/octet-stream",
            status: 200
        };
    };
    NetworkDomainDebugger.prototype.create = function () {
        var id = (++NetworkDomainDebugger_1.idSequence).toString();
        var resourceData = new Request(this, id);
        resources_datas[id] = resourceData;
        return resourceData;
    };
    var NetworkDomainDebugger_1;
    NetworkDomainDebugger.idSequence = 0;
    NetworkDomainDebugger = NetworkDomainDebugger_1 = __decorate([
        inspectorCommands.DomainDispatcher("Network")
    ], NetworkDomainDebugger);
    return NetworkDomainDebugger;
}());
exports.NetworkDomainDebugger = NetworkDomainDebugger;
var RuntimeDomainDebugger = (function () {
    function RuntimeDomainDebugger() {
        __inspectorSendEvent("{\"method\":\"Runtime.executionContextCreated\",\"params\":{\"context\":{\"id\":1,\"origin\":\"http://main.xml\",\"name\":\"\",\"auxData\":{\"isDefault\":true,\"frameId\":\"" + frameId + "\"}}}}");
    }
    RuntimeDomainDebugger.prototype.compileScript = function () {
        return {};
    };
    RuntimeDomainDebugger = __decorate([
        inspectorCommands.DomainDispatcher("Runtime")
    ], RuntimeDomainDebugger);
    return RuntimeDomainDebugger;
}());
exports.RuntimeDomainDebugger = RuntimeDomainDebugger;
//# sourceMappingURL=webinspector-network.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/fetch/fetch.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {﻿(function () {
    'use strict';

    exports.XMLHttpRequest = global.XMLHttpRequest;
    exports.FormData = global.FormData;

    if (!exports.XMLHttpRequest) {
        var xhr = __webpack_require__("../node_modules/tns-core-modules/xhr/xhr.js");
        exports.XMLHttpRequest = xhr.XMLHttpRequest;
        exports.FormData = xhr.FormData;
    }

    function normalizeName(name) {
        if (typeof name !== 'string') {
            name = name.toString();
        }
        if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
        }
        return name.toLowerCase()
    }

    function normalizeValue(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return value
    }

    function Headers(headers) {
        this.map = {}

        if (headers instanceof Headers) {
            headers.forEach(function (value, name) {
                this.append(name, value)
            }, this)

        } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
                this.append(name, headers[name])
            }, this)
        }
    }

    Headers.prototype.append = function (name, value) {
        name = normalizeName(name)
        value = normalizeValue(value)
        var list = this.map[name]
        if (!list) {
            list = []
            this.map[name] = list
        }
        list.push(value)
    }

    Headers.prototype['delete'] = function (name) {
        delete this.map[normalizeName(name)]
    }

    Headers.prototype.get = function (name) {
        var values = this.map[normalizeName(name)]
        return values ? values[0] : null
    }

    Headers.prototype.getAll = function (name) {
        return this.map[normalizeName(name)] || []
    }

    Headers.prototype.has = function (name) {
        return this.map.hasOwnProperty(normalizeName(name))
    }

    Headers.prototype.set = function (name, value) {
        this.map[normalizeName(name)] = [normalizeValue(value)]
    }

    Headers.prototype.forEach = function (callback, thisArg) {
        Object.getOwnPropertyNames(this.map).forEach(function (name) {
            this.map[name].forEach(function (value) {
                callback.call(thisArg, value, name, this)
            }, this)
        }, this)
    }

    function consumed(body) {
        if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
        }
        body.bodyUsed = true
    }

    function fileReaderReady(reader) {
        return new Promise(function (resolve, reject) {
            reader.onload = function () {
                resolve(reader.result)
            }
            reader.onerror = function () {
                reject(reader.error)
            }
        })
    }

    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader()
        reader.readAsArrayBuffer(blob)
        return fileReaderReady(reader)
    }

    function readBlobAsText(blob) {
        var reader = new FileReader()
        reader.readAsText(blob)
        return fileReaderReady(reader)
    }

    var support = {
        blob: 'FileReader' in exports && 'Blob' in exports && (function () {
            try {
                new Blob();
                return true
            } catch (e) {
                return false
            }
        })(),
        formData: 'FormData' in exports
    }

    function Body() {
        this.bodyUsed = false


        this._initBody = function (body) {
            this._bodyInit = body
            if (typeof body === 'string') {
                this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body
            } else if (support.formData && exports.FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body
            } else if (!body) {
                this._bodyText = ''
            } else {
                throw new Error('unsupported BodyInit type')
            }
        }

        if (support.blob) {
            this.blob = function () {
                var rejected = consumed(this)
                if (rejected) {
                    return rejected
                }

                if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob)
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob')
                } else {
                    return Promise.resolve(new Blob([this._bodyText]))
                }
            }

            this.arrayBuffer = function () {
                return this.blob().then(readBlobAsArrayBuffer)
            }

            this.text = function () {
                var rejected = consumed(this)
                if (rejected) {
                    return rejected
                }

                if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob)
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as text')
                } else {
                    return Promise.resolve(this._bodyText)
                }
            }
        } else {
            this.text = function () {
                var rejected = consumed(this)
                return rejected ? rejected : Promise.resolve(this._bodyText)
            }
        }

        if (support.formData) {
            this.formData = function () {
                return this.text().then(decode)
            }
        }

        this.json = function () {
            return this.text().then(JSON.parse)
        }

        return this
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

    function normalizeMethod(method) {
        var upcased = method.toUpperCase()
        return (methods.indexOf(upcased) > -1) ? upcased : method
    }

    function Request(url, options) {
        options = options || {}
        this.url = url

        this.credentials = options.credentials || 'omit'
        this.headers = new Headers(options.headers)
        this.method = normalizeMethod(options.method || 'GET')
        this.mode = options.mode || null
        this.referrer = null

        if ((this.method === 'GET' || this.method === 'HEAD') && options.body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
        }
        this._initBody(options.body)
    }

    function decode(body) {
        var form = new exports.FormData()
        body.trim().split('&').forEach(function (bytes) {
            if (bytes) {
                var split = bytes.split('=')
                var name = split.shift().replace(/\+/g, ' ')
                var value = split.join('=').replace(/\+/g, ' ')
                form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
        })
        return form
    }

    function headers(xhr) {
        var head = new Headers()
        var pairs = xhr.getAllResponseHeaders().trim().split('\n')
        pairs.forEach(function (header) {
            var split = header.trim().split(':')
            var key = split.shift().trim()
            var value = split.join(':').trim()
            head.append(key, value)
        })
        return head
    }

    Body.call(Request.prototype)

    function Response(bodyInit, options) {
        if (!options) {
            options = {}
        }

        this._initBody(bodyInit)
        this.type = 'default'
        this.url = null
        this.status = options.status
        this.ok = this.status >= 200 && this.status < 300
        this.statusText = options.statusText
        this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
        this.url = options.url || ''
    }

    Body.call(Response.prototype)

    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;

    exports.fetch = function (input, init) {
        // TODO: Request constructor should accept input, init
        var request
        if (Request.prototype.isPrototypeOf(input) && !init) {
            request = input
        } else {
            request = new Request(input, init)
        }

        return new Promise(function (resolve, reject) {
            var xhr = new exports.XMLHttpRequest()

            function responseURL() {
                if ('responseURL' in xhr) {
                    return xhr.responseURL
                }

                // Avoid security warnings on getResponseHeader when not allowed by CORS
                if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
                    return xhr.getResponseHeader('X-Request-URL')
                }

                return;
            }

            xhr.onload = function () {
                var status = (xhr.status === 1223) ? 204 : xhr.status
                if (status < 100 || status > 599) {
                    reject(new TypeError('Network request failed'))
                    return
                }
                var options = {
                    status: status,
                    statusText: xhr.statusText,
                    headers: headers(xhr),
                    url: responseURL()
                }
                //var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(xhr.responseText, options))
            }

            xhr.onerror = function (error) {
                reject(new TypeError(['Network request failed:', error.message].join(' ')))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
                xhr.withCredentials = true
            }

            if ('responseType' in xhr && support.blob) {
                xhr.responseType = 'blob'
            }

            request.headers.forEach(function (value, name) {
                xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
        })
    }
    exports.fetch.polyfill = true

})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/file-system/file-name-resolver/file-name-resolver.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var trace = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var appCommonModule = __webpack_require__("../node_modules/tns-core-modules/application/application-common.js");
var MIN_WH = "minWH";
var MIN_W = "minW";
var MIN_H = "minH";
var PRIORITY_STEP = 10000;
var minWidthHeightQualifier = {
    isMatch: function (value) {
        return value.indexOf(MIN_WH) === 0;
    },
    getMatchValue: function (value, context) {
        var numVal = parseInt(value.substr(MIN_WH.length));
        if (isNaN(numVal)) {
            return -1;
        }
        var actualLength = Math.min(context.width, context.height);
        if (actualLength < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualLength - numVal);
    }
};
var minWidthQualifier = {
    isMatch: function (value) {
        return value.indexOf(MIN_W) === 0 && value.indexOf(MIN_WH) < 0;
    },
    getMatchValue: function (value, context) {
        var numVal = parseInt(value.substr(MIN_W.length));
        if (isNaN(numVal)) {
            return -1;
        }
        var actualWidth = context.width;
        if (actualWidth < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualWidth - numVal);
    }
};
var minHeightQualifier = {
    isMatch: function (value) {
        return value.indexOf(MIN_H) === 0 && value.indexOf(MIN_WH) < 0;
    },
    getMatchValue: function (value, context) {
        var numVal = parseInt(value.substr(MIN_H.length));
        if (isNaN(numVal)) {
            return -1;
        }
        var actualHeight = context.height;
        if (actualHeight < numVal) {
            return -1;
        }
        return PRIORITY_STEP - (actualHeight - numVal);
    }
};
var platformQualifier = {
    isMatch: function (value) {
        return value === "android" ||
            value === "ios";
    },
    getMatchValue: function (value, context) {
        return value === context.os.toLowerCase() ? 1 : -1;
    }
};
var orientationQualifier = {
    isMatch: function (value) {
        return value === "land" ||
            value === "port";
    },
    getMatchValue: function (value, context) {
        var isLandscape = (context.width > context.height) ? 1 : -1;
        return (value === "land") ? isLandscape : -isLandscape;
    }
};
var supportedQualifiers = [
    minWidthHeightQualifier,
    minWidthQualifier,
    minHeightQualifier,
    orientationQualifier,
    platformQualifier
];
var FileNameResolver = (function () {
    function FileNameResolver(context) {
        this._cache = {};
        this._context = context;
    }
    FileNameResolver.prototype.resolveFileName = function (path, ext) {
        var key = path + ext;
        var result = this._cache[key];
        if (result === undefined) {
            result = this.resolveFileNameImpl(path, ext);
            this._cache[key] = result;
        }
        return result;
    };
    FileNameResolver.prototype.clearCache = function () {
        this._cache = {};
    };
    FileNameResolver.prototype.resolveFileNameImpl = function (path, ext) {
        var result = null;
        path = file_system_1.path.normalize(path);
        ext = "." + ext;
        var candidates = this.getFileCandidatesFromFolder(path, ext);
        result = _findFileMatch(path, ext, candidates, this._context);
        return result;
    };
    FileNameResolver.prototype.getFileCandidatesFromFolder = function (path, ext) {
        var candidates = new Array();
        var folderPath = path.substring(0, path.lastIndexOf(file_system_1.path.separator) + 1);
        if (file_system_1.Folder.exists(folderPath)) {
            var folder = file_system_1.Folder.fromPath(folderPath);
            folder.eachEntity(function (e) {
                if (e instanceof file_system_1.File) {
                    var file = e;
                    if (file.path.indexOf(path) === 0 && file.extension === ext) {
                        candidates.push(file.path);
                    }
                }
                return true;
            });
        }
        else {
            if (trace.isEnabled()) {
                trace.write("Could not find folder " + folderPath + " when loading " + path + ext, trace.categories.Navigation);
            }
        }
        return candidates;
    };
    return FileNameResolver;
}());
exports.FileNameResolver = FileNameResolver;
function _findFileMatch(path, ext, candidates, context) {
    var bestValue = -1;
    var result = null;
    for (var i = 0; i < candidates.length; i++) {
        var filePath = candidates[i];
        var qualifiersStr = filePath.substr(path.length, filePath.length - path.length - ext.length);
        var qualifiers = qualifiersStr.split(".");
        var value = checkQualifiers(qualifiers, context);
        if (value >= 0 && value > bestValue) {
            bestValue = value;
            result = candidates[i];
        }
    }
    return result;
}
exports._findFileMatch = _findFileMatch;
function checkQualifiers(qualifiers, context) {
    var result = 0;
    var value;
    for (var i = 0; i < qualifiers.length; i++) {
        if (qualifiers[i]) {
            value = checkQualifier(qualifiers[i], context);
            if (value < 0) {
                return -1;
            }
            result += value;
        }
    }
    return result;
}
function checkQualifier(value, context) {
    var result;
    for (var i = 0; i < supportedQualifiers.length; i++) {
        if (supportedQualifiers[i].isMatch(value)) {
            result = supportedQualifiers[i].getMatchValue(value, context);
            if (result > 0) {
                result += (supportedQualifiers.length - i) * PRIORITY_STEP;
            }
            return result;
        }
    }
    return -1;
}
var resolverInstance;
function resolveFileName(path, ext) {
    if (!resolverInstance) {
        resolverInstance = new FileNameResolver({
            width: platform_1.screen.mainScreen.widthDIPs,
            height: platform_1.screen.mainScreen.heightDIPs,
            os: platform_1.device.os,
            deviceType: platform_1.device.deviceType
        });
    }
    return resolverInstance.resolveFileName(path, ext);
}
exports.resolveFileName = resolveFileName;
appCommonModule.on("cssChanged", function (args) { return resolverInstance = undefined; });
appCommonModule.on("livesync", function (args) { return resolverInstance && resolverInstance.clearCache(); });
//# sourceMappingURL=file-name-resolver.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/file-system/file-system-access.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var text_1 = __webpack_require__("../node_modules/tns-core-modules/text/text.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var FileSystemAccess = (function () {
    function FileSystemAccess() {
    }
    FileSystemAccess.prototype.getLastModified = function (path) {
        var fileManager = NSFileManager.defaultManager;
        var attributes = fileManager.attributesOfItemAtPathError(path);
        if (attributes) {
            return attributes.objectForKey("NSFileModificationDate");
        }
        else {
            return new Date();
        }
    };
    FileSystemAccess.prototype.getFileSize = function (path) {
        var fileManager = NSFileManager.defaultManager;
        var attributes = fileManager.attributesOfItemAtPathError(path);
        if (attributes) {
            return attributes.objectForKey("NSFileSize");
        }
        else {
            return 0;
        }
    };
    FileSystemAccess.prototype.getParent = function (path, onError) {
        try {
            var fileManager = NSFileManager.defaultManager;
            var nsString = NSString.stringWithString(path);
            var parentPath = nsString.stringByDeletingLastPathComponent;
            var name_1 = fileManager.displayNameAtPath(parentPath);
            return {
                path: parentPath.toString(),
                name: name_1
            };
        }
        catch (exception) {
            if (onError) {
                onError(exception);
            }
            return undefined;
        }
    };
    FileSystemAccess.prototype.getFile = function (path, onError) {
        try {
            var fileManager = NSFileManager.defaultManager;
            var exists = fileManager.fileExistsAtPath(path);
            if (!exists) {
                var parentPath = this.getParent(path, onError).path;
                if (!fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(parentPath, true, null)
                    || !fileManager.createFileAtPathContentsAttributes(path, null, null)) {
                    if (onError) {
                        onError(new Error("Failed to create file at path '" + path + "'"));
                    }
                    return undefined;
                }
            }
            var fileName = fileManager.displayNameAtPath(path);
            return {
                path: path,
                name: fileName,
                extension: this.getFileExtension(path)
            };
        }
        catch (exception) {
            if (onError) {
                onError(exception);
            }
            return undefined;
        }
    };
    FileSystemAccess.prototype.getFolder = function (path, onError) {
        try {
            var fileManager = NSFileManager.defaultManager;
            var exists = this.folderExists(path);
            if (!exists) {
                try {
                    fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(path, true, null);
                }
                catch (ex) {
                    if (onError) {
                        onError(new Error("Failed to create folder at path '" + path + "': " + ex));
                    }
                    return undefined;
                }
            }
            var dirName = fileManager.displayNameAtPath(path);
            return {
                path: path,
                name: dirName
            };
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to create folder at path '" + path + "'"));
            }
            return undefined;
        }
    };
    FileSystemAccess.prototype.getExistingFolder = function (path, onError) {
        try {
            var fileManager = NSFileManager.defaultManager;
            var exists = this.folderExists(path);
            if (exists) {
                var dirName = fileManager.displayNameAtPath(path);
                return {
                    path: path,
                    name: dirName
                };
            }
            return undefined;
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to get folder at path '" + path + "'"));
            }
            return undefined;
        }
    };
    FileSystemAccess.prototype.eachEntity = function (path, onEntity, onError) {
        if (!onEntity) {
            return;
        }
        this.enumEntities(path, onEntity, onError);
    };
    FileSystemAccess.prototype.getEntities = function (path, onError) {
        var fileInfos = new Array();
        var onEntity = function (entity) {
            fileInfos.push(entity);
            return true;
        };
        var errorOccurred;
        var localError = function (error) {
            if (onError) {
                onError(error);
            }
            errorOccurred = true;
        };
        this.enumEntities(path, onEntity, localError);
        if (!errorOccurred) {
            return fileInfos;
        }
        return null;
    };
    FileSystemAccess.prototype.fileExists = function (path) {
        var result = this.exists(path);
        return result.exists;
    };
    FileSystemAccess.prototype.folderExists = function (path) {
        var result = this.exists(path);
        return result.exists && result.isDirectory;
    };
    FileSystemAccess.prototype.exists = function (path) {
        var fileManager = NSFileManager.defaultManager;
        var isDirectory = new interop.Reference(interop.types.bool, false);
        var exists = fileManager.fileExistsAtPathIsDirectory(path, isDirectory);
        return { exists: exists, isDirectory: isDirectory.value };
    };
    FileSystemAccess.prototype.concatPath = function (left, right) {
        return NSString.pathWithComponents([left, right]).toString();
    };
    FileSystemAccess.prototype.deleteFile = function (path, onError) {
        this.deleteEntity(path, onError);
    };
    FileSystemAccess.prototype.deleteFolder = function (path, onError) {
        this.deleteEntity(path, onError);
    };
    FileSystemAccess.prototype.emptyFolder = function (path, onError) {
        var fileManager = NSFileManager.defaultManager;
        var entities = this.getEntities(path, onError);
        if (!entities) {
            return;
        }
        for (var i = 0; i < entities.length; i++) {
            try {
                fileManager.removeItemAtPathError(entities[i].path);
            }
            catch (ex) {
                if (onError) {
                    onError(new Error("Failed to empty folder '" + path + "': " + ex));
                }
                return;
            }
        }
    };
    FileSystemAccess.prototype.rename = function (path, newPath, onError) {
        var fileManager = NSFileManager.defaultManager;
        try {
            fileManager.moveItemAtPathToPathError(path, newPath);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to rename '" + path + "' to '" + newPath + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.getLogicalRootPath = function () {
        var mainBundlePath = NSBundle.mainBundle.bundlePath;
        var resolvedPath = NSString.stringWithString(mainBundlePath).stringByResolvingSymlinksInPath;
        return resolvedPath;
    };
    FileSystemAccess.prototype.getDocumentsFolderPath = function () {
        return this.getKnownPath(9);
    };
    FileSystemAccess.prototype.getTempFolderPath = function () {
        return this.getKnownPath(13);
    };
    FileSystemAccess.prototype.getCurrentAppPath = function () {
        return utils_1.ios.getCurrentAppPath();
    };
    FileSystemAccess.prototype.readText = function (path, onError, encoding) {
        var actualEncoding = encoding || text_1.encoding.UTF_8;
        try {
            var nsString = NSString.stringWithContentsOfFileEncodingError(path, actualEncoding);
            return nsString.toString();
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.read = function (path, onError) {
        try {
            return NSData.dataWithContentsOfFile(path);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to read file at path '" + path + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.writeText = function (path, content, onError, encoding) {
        var nsString = NSString.stringWithString(content);
        var actualEncoding = encoding || text_1.encoding.UTF_8;
        try {
            nsString.writeToFileAtomicallyEncodingError(path, false, actualEncoding);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to write to file '" + path + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.write = function (path, content, onError) {
        try {
            content.writeToFileAtomically(path, true);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to write to file '" + path + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.getKnownPath = function (folderType) {
        var fileManager = NSFileManager.defaultManager;
        var paths = fileManager.URLsForDirectoryInDomains(folderType, 1);
        var url = paths.objectAtIndex(0);
        return url.path;
    };
    FileSystemAccess.prototype.getFileExtension = function (path) {
        var dotIndex = path.lastIndexOf(".");
        if (dotIndex && dotIndex >= 0 && dotIndex < path.length) {
            return path.substring(dotIndex);
        }
        return "";
    };
    FileSystemAccess.prototype.deleteEntity = function (path, onError) {
        var fileManager = NSFileManager.defaultManager;
        try {
            fileManager.removeItemAtPathError(path);
        }
        catch (ex) {
            if (onError) {
                onError(new Error("Failed to delete file at path '" + path + "': " + ex));
            }
        }
    };
    FileSystemAccess.prototype.enumEntities = function (path, callback, onError) {
        try {
            var fileManager = NSFileManager.defaultManager;
            var files = void 0;
            try {
                files = fileManager.contentsOfDirectoryAtPathError(path);
            }
            catch (ex) {
                if (onError) {
                    onError(new Error("Failed to enum files for folder '" + path + "': " + ex));
                }
                return;
            }
            for (var i = 0; i < files.count; i++) {
                var file = files.objectAtIndex(i);
                var info = {
                    path: this.concatPath(path, file),
                    name: file,
                    extension: ""
                };
                if (!this.folderExists(this.joinPath(path, file))) {
                    info.extension = this.getFileExtension(info.path);
                }
                var retVal = callback(info);
                if (retVal === false) {
                    break;
                }
            }
        }
        catch (ex) {
            if (onError) {
                onError(ex);
            }
        }
    };
    FileSystemAccess.prototype.getPathSeparator = function () {
        return "/";
    };
    FileSystemAccess.prototype.normalizePath = function (path) {
        var nsString = NSString.stringWithString(path);
        var normalized = nsString.stringByStandardizingPath;
        return normalized;
    };
    FileSystemAccess.prototype.joinPath = function (left, right) {
        var nsString = NSString.stringWithString(left);
        return nsString.stringByAppendingPathComponent(right);
    };
    FileSystemAccess.prototype.joinPaths = function (paths) {
        return utils_1.ios.joinPaths.apply(utils_1.ios, paths);
    };
    return FileSystemAccess;
}());
exports.FileSystemAccess = FileSystemAccess;
//# sourceMappingURL=file-system-access.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/file-system/file-system.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var file_system_access_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system-access.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var fileAccess;
function getFileAccess() {
    if (!fileAccess) {
        fileAccess = new file_system_access_1.FileSystemAccess();
    }
    return fileAccess;
}
;
var platform;
function ensurePlatform() {
    if (!platform) {
        platform = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
    }
}
function createFile(info) {
    var file = new File();
    file._path = info.path;
    file._name = info.name;
    file._extension = info.extension;
    return file;
}
;
function createFolder(info) {
    var documents = knownFolders.documents();
    if (info.path === documents.path) {
        return documents;
    }
    var temp = knownFolders.temp();
    if (info.path === temp.path) {
        return temp;
    }
    var folder = new Folder();
    folder._path = info.path;
    folder._name = info.name;
    return folder;
}
;
var FileSystemEntity = (function () {
    function FileSystemEntity() {
    }
    Object.defineProperty(FileSystemEntity.prototype, "parent", {
        get: function () {
            var onError = function (error) {
                throw error;
            };
            var folderInfo = getFileAccess().getParent(this.path, onError);
            if (!folderInfo) {
                return undefined;
            }
            return createFolder(folderInfo);
        },
        enumerable: true,
        configurable: true
    });
    FileSystemEntity.prototype.remove = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var localError = function (error) {
                hasError = true;
                reject(error);
            };
            _this.removeSync(localError);
            if (!hasError) {
                resolve();
            }
        });
    };
    FileSystemEntity.prototype.removeSync = function (onError) {
        if (this._isKnown) {
            if (onError) {
                onError({ message: "Cannot delete known folder." });
            }
            return;
        }
        var fileAccess = getFileAccess();
        if (this instanceof File) {
            fileAccess.deleteFile(this.path, onError);
        }
        else if (this instanceof Folder) {
            fileAccess.deleteFolder(this.path, onError);
        }
    };
    FileSystemEntity.prototype.rename = function (newName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var localError = function (error) {
                hasError = true;
                reject(error);
            };
            _this.renameSync(newName, localError);
            if (!hasError) {
                resolve();
            }
        });
    };
    FileSystemEntity.prototype.renameSync = function (newName, onError) {
        if (this._isKnown) {
            if (onError) {
                onError(new Error("Cannot rename known folder."));
            }
            return;
        }
        var parentFolder = this.parent;
        if (!parentFolder) {
            if (onError) {
                onError(new Error("No parent folder."));
            }
            return;
        }
        var fileAccess = getFileAccess();
        var path = parentFolder.path;
        var newPath = fileAccess.joinPath(path, newName);
        var localError = function (error) {
            if (onError) {
                onError(error);
            }
            return null;
        };
        fileAccess.rename(this.path, newPath, localError);
        this._path = newPath;
        this._name = newName;
        if (this instanceof File) {
            this._extension = fileAccess.getFileExtension(newPath);
        }
    };
    Object.defineProperty(FileSystemEntity.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileSystemEntity.prototype, "path", {
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileSystemEntity.prototype, "lastModified", {
        get: function () {
            var value = this._lastModified;
            if (!this._lastModified) {
                value = this._lastModified = getFileAccess().getLastModified(this.path);
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    return FileSystemEntity;
}());
exports.FileSystemEntity = FileSystemEntity;
var File = (function (_super) {
    __extends(File, _super);
    function File() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    File.fromPath = function (path) {
        var onError = function (error) {
            throw error;
        };
        var fileInfo = getFileAccess().getFile(path, onError);
        if (!fileInfo) {
            return undefined;
        }
        return createFile(fileInfo);
    };
    File.exists = function (path) {
        return getFileAccess().fileExists(path);
    };
    Object.defineProperty(File.prototype, "extension", {
        get: function () {
            return this._extension;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "isLocked", {
        get: function () {
            return !!this._locked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        get: function () {
            return getFileAccess().getFileSize(this.path);
        },
        enumerable: true,
        configurable: true
    });
    File.prototype.readSync = function (onError) {
        this.checkAccess();
        this._locked = true;
        var that = this;
        var localError = function (error) {
            that._locked = false;
            if (onError) {
                onError(error);
            }
        };
        var content = getFileAccess().read(this.path, localError);
        this._locked = false;
        return content;
    };
    File.prototype.writeSync = function (content, onError) {
        this.checkAccess();
        try {
            this._locked = true;
            var that_1 = this;
            var localError = function (error) {
                that_1._locked = false;
                if (onError) {
                    onError(error);
                }
            };
            getFileAccess().write(this.path, content, localError);
        }
        finally {
            this._locked = false;
        }
    };
    File.prototype.readText = function (encoding) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var localError = function (error) {
                hasError = true;
                reject(error);
            };
            var content = _this.readTextSync(localError, encoding);
            if (!hasError) {
                resolve(content);
            }
        });
    };
    File.prototype.readTextSync = function (onError, encoding) {
        this.checkAccess();
        this._locked = true;
        var that = this;
        var localError = function (error) {
            that._locked = false;
            if (onError) {
                onError(error);
            }
        };
        var content = getFileAccess().readText(this.path, localError, encoding);
        this._locked = false;
        return content;
    };
    File.prototype.writeText = function (content, encoding) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var localError = function (error) {
                hasError = true;
                reject(error);
            };
            _this.writeTextSync(content, localError, encoding);
            if (!hasError) {
                resolve();
            }
        });
    };
    File.prototype.writeTextSync = function (content, onError, encoding) {
        this.checkAccess();
        try {
            this._locked = true;
            var that_2 = this;
            var localError = function (error) {
                that_2._locked = false;
                if (onError) {
                    onError(error);
                }
            };
            getFileAccess().writeText(this.path, content, localError, encoding);
        }
        finally {
            this._locked = false;
        }
    };
    File.prototype.checkAccess = function () {
        if (this.isLocked) {
            throw new Error("Cannot access a locked file.");
        }
    };
    __decorate([
        profiling_1.profile
    ], File.prototype, "readTextSync", null);
    return File;
}(FileSystemEntity));
exports.File = File;
var Folder = (function (_super) {
    __extends(Folder, _super);
    function Folder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Folder.fromPath = function (path) {
        var onError = function (error) {
            throw error;
        };
        var folderInfo = getFileAccess().getFolder(path, onError);
        if (!folderInfo) {
            return undefined;
        }
        return createFolder(folderInfo);
    };
    Folder.exists = function (path) {
        return getFileAccess().folderExists(path);
    };
    Folder.prototype.contains = function (name) {
        var fileAccess = getFileAccess();
        var path = fileAccess.joinPath(this.path, name);
        if (fileAccess.fileExists(path)) {
            return true;
        }
        return fileAccess.folderExists(path);
    };
    Folder.prototype.clear = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var onError = function (error) {
                hasError = true;
                reject(error);
            };
            _this.clearSync(onError);
            if (!hasError) {
                resolve();
            }
        });
    };
    Folder.prototype.clearSync = function (onError) {
        getFileAccess().emptyFolder(this.path, onError);
    };
    Object.defineProperty(Folder.prototype, "isKnown", {
        get: function () {
            return this._isKnown;
        },
        enumerable: true,
        configurable: true
    });
    Folder.prototype.getFile = function (name) {
        var fileAccess = getFileAccess();
        var path = fileAccess.joinPath(this.path, name);
        var onError = function (error) {
            throw error;
        };
        var fileInfo = fileAccess.getFile(path, onError);
        if (!fileInfo) {
            return undefined;
        }
        return createFile(fileInfo);
    };
    Folder.prototype.getFolder = function (name) {
        var fileAccess = getFileAccess();
        var path = fileAccess.joinPath(this.path, name);
        var onError = function (error) {
            throw error;
        };
        var folderInfo = fileAccess.getFolder(path, onError);
        if (!folderInfo) {
            return undefined;
        }
        return createFolder(folderInfo);
    };
    Folder.prototype.getEntities = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hasError = false;
            var localError = function (error) {
                hasError = true;
                reject(error);
            };
            var entities = _this.getEntitiesSync(localError);
            if (!hasError) {
                resolve(entities);
            }
        });
    };
    Folder.prototype.getEntitiesSync = function (onError) {
        var fileInfos = getFileAccess().getEntities(this.path, onError);
        if (!fileInfos) {
            return null;
        }
        var entities = new Array();
        for (var i = 0; i < fileInfos.length; i++) {
            if (fileInfos[i].extension) {
                entities.push(createFile(fileInfos[i]));
            }
            else {
                entities.push(createFolder(fileInfos[i]));
            }
        }
        return entities;
    };
    Folder.prototype.eachEntity = function (onEntity) {
        if (!onEntity) {
            return;
        }
        var onSuccess = function (fileInfo) {
            var entity;
            if (fileInfo.extension) {
                entity = createFile(fileInfo);
            }
            else {
                entity = createFolder(fileInfo);
            }
            return onEntity(entity);
        };
        var onError = function (error) {
            throw error;
        };
        getFileAccess().eachEntity(this.path, onSuccess, onError);
    };
    return Folder;
}(FileSystemEntity));
exports.Folder = Folder;
var knownFolders;
(function (knownFolders) {
    var _documents;
    var _temp;
    var _app;
    function documents() {
        if (!_documents) {
            var path_1 = getFileAccess().getDocumentsFolderPath();
            _documents = new Folder();
            _documents._path = path_1;
            _documents._isKnown = true;
        }
        return _documents;
    }
    knownFolders.documents = documents;
    ;
    function temp() {
        if (!_temp) {
            var path_2 = getFileAccess().getTempFolderPath();
            _temp = new Folder();
            _temp._path = path_2;
            _temp._isKnown = true;
        }
        return _temp;
    }
    knownFolders.temp = temp;
    ;
    function currentApp() {
        if (!_app) {
            var path_3 = getFileAccess().getCurrentAppPath();
            _app = new Folder();
            _app._path = path_3;
            _app._isKnown = true;
        }
        return _app;
    }
    knownFolders.currentApp = currentApp;
    ;
    var ios;
    (function (ios) {
        function _checkPlatform(knownFolderName) {
            ensurePlatform();
            if (!platform.isIOS) {
                throw new Error("The \"" + knownFolderName + "\" known folder is available on iOS only!");
            }
        }
        var _library;
        function library() {
            _checkPlatform("library");
            if (!_library) {
                var existingFolderInfo = getExistingFolderInfo(5);
                if (existingFolderInfo) {
                    _library = existingFolderInfo.folder;
                    _library._path = existingFolderInfo.path;
                    _library._isKnown = true;
                }
            }
            return _library;
        }
        ios.library = library;
        ;
        var _developer;
        function developer() {
            _checkPlatform("developer");
            if (!_developer) {
                var existingFolderInfo = getExistingFolderInfo(6);
                if (existingFolderInfo) {
                    _developer = existingFolderInfo.folder;
                    _developer._path = existingFolderInfo.path;
                    _developer._isKnown = true;
                }
            }
            return _developer;
        }
        ios.developer = developer;
        ;
        var _desktop;
        function desktop() {
            _checkPlatform("desktop");
            if (!_desktop) {
                var existingFolderInfo = getExistingFolderInfo(12);
                if (existingFolderInfo) {
                    _desktop = existingFolderInfo.folder;
                    _desktop._path = existingFolderInfo.path;
                    _desktop._isKnown = true;
                }
            }
            return _desktop;
        }
        ios.desktop = desktop;
        ;
        var _downloads;
        function downloads() {
            _checkPlatform("downloads");
            if (!_downloads) {
                var existingFolderInfo = getExistingFolderInfo(15);
                if (existingFolderInfo) {
                    _downloads = existingFolderInfo.folder;
                    _downloads._path = existingFolderInfo.path;
                    _downloads._isKnown = true;
                }
            }
            return _downloads;
        }
        ios.downloads = downloads;
        ;
        var _movies;
        function movies() {
            _checkPlatform("movies");
            if (!_movies) {
                var existingFolderInfo = getExistingFolderInfo(17);
                if (existingFolderInfo) {
                    _movies = existingFolderInfo.folder;
                    _movies._path = existingFolderInfo.path;
                    _movies._isKnown = true;
                }
            }
            return _movies;
        }
        ios.movies = movies;
        ;
        var _music;
        function music() {
            _checkPlatform("music");
            if (!_music) {
                var existingFolderInfo = getExistingFolderInfo(18);
                if (existingFolderInfo) {
                    _music = existingFolderInfo.folder;
                    _music._path = existingFolderInfo.path;
                    _music._isKnown = true;
                }
            }
            return _music;
        }
        ios.music = music;
        ;
        var _pictures;
        function pictures() {
            _checkPlatform("pictures");
            if (!_pictures) {
                var existingFolderInfo = getExistingFolderInfo(19);
                if (existingFolderInfo) {
                    _pictures = existingFolderInfo.folder;
                    _pictures._path = existingFolderInfo.path;
                    _pictures._isKnown = true;
                }
            }
            return _pictures;
        }
        ios.pictures = pictures;
        ;
        var _sharedPublic;
        function sharedPublic() {
            _checkPlatform("sharedPublic");
            if (!_sharedPublic) {
                var existingFolderInfo = getExistingFolderInfo(21);
                if (existingFolderInfo) {
                    _sharedPublic = existingFolderInfo.folder;
                    _sharedPublic._path = existingFolderInfo.path;
                    _sharedPublic._isKnown = true;
                }
            }
            return _sharedPublic;
        }
        ios.sharedPublic = sharedPublic;
        ;
        function getExistingFolderInfo(pathDirectory) {
            var fileAccess = getFileAccess();
            var folderPath = fileAccess.getKnownPath(pathDirectory);
            var folderInfo = fileAccess.getExistingFolder(folderPath);
            if (folderInfo) {
                return {
                    folder: createFolder(folderInfo),
                    path: folderPath
                };
            }
            return undefined;
        }
    })(ios = knownFolders.ios || (knownFolders.ios = {}));
})(knownFolders = exports.knownFolders || (exports.knownFolders = {}));
var path;
(function (path_4) {
    function normalize(path) {
        return getFileAccess().normalizePath(path);
    }
    path_4.normalize = normalize;
    function join() {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i] = arguments[_i];
        }
        var fileAccess = getFileAccess();
        return fileAccess.joinPaths(paths);
    }
    path_4.join = join;
    path_4.separator = getFileAccess().getPathSeparator();
})(path = exports.path || (exports.path = {}));
//# sourceMappingURL=file-system.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/globals/globals.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("../node_modules/tns-core-modules/globals/ts-helpers.js");
global.moduleMerge = function (sourceExports, destExports) {
    for (var key in sourceExports) {
        destExports[key] = sourceExports[key];
    }
};
var modules = new Map();
global.moduleResolvers = [global.require];
global.registerModule = function (name, loader) {
    modules.set(name, loader);
};
var defaultExtensionMap = { ".js": ".js", ".ts": ".js", ".css": ".css", ".scss": ".css", ".xml": ".xml", ".less": ".css", ".sass": ".css" };
global.registerWebpackModules = function registerWebpackModules(context, extensionMap) {
    if (extensionMap === void 0) { extensionMap = {}; }
    context.keys().forEach(function (key) {
        var extDotIndex = key.lastIndexOf(".");
        var base = key.substr(0, extDotIndex);
        var originalExt = key.substr(extDotIndex);
        var registerExt = extensionMap[originalExt] || defaultExtensionMap[originalExt] || originalExt;
        var isSourceFile = originalExt !== registerExt;
        var registerName = base + registerExt;
        if (registerName.startsWith("./") && registerName.endsWith(".js")) {
            var jsNickNames = [
                registerName.substr(2, registerName.length - 5),
                registerName.substr(0, registerName.length - 3),
                registerName.substr(2),
            ];
            jsNickNames.forEach(function (jsNickName) {
                if (isSourceFile || !global.moduleExists(jsNickName)) {
                    global.registerModule(jsNickName, function () { return context(key); });
                }
            });
        }
        if (isSourceFile || !global.moduleExists(registerName)) {
            global.registerModule(registerName, function () { return context(key); });
        }
    });
};
global.moduleExists = function (name) {
    return modules.has(name);
};
global.loadModule = function (name) {
    var loader = modules.get(name);
    if (loader) {
        return loader();
    }
    var _loop_1 = function (resolver) {
        var result = resolver(name);
        if (result) {
            modules.set(name, function () { return result; });
            return { value: result };
        }
    };
    for (var _i = 0, _a = global.moduleResolvers; _i < _a.length; _i++) {
        var resolver = _a[_i];
        var state_1 = _loop_1(resolver);
        if (typeof state_1 === "object")
            return state_1.value;
    }
};
global.zonedCallback = function (callback) {
    if (global.zone) {
        return global.zone.bind(callback);
    }
    if (global.Zone) {
        return global.Zone.current.wrap(callback);
    }
    else {
        return callback;
    }
};
global.registerModule("timer", function () { return __webpack_require__("../node_modules/tns-core-modules/timer/timer.js"); });
global.registerModule("ui/dialogs", function () { return __webpack_require__("../node_modules/tns-core-modules/ui/dialogs/dialogs.js"); });
global.registerModule("xhr", function () { return __webpack_require__("../node_modules/tns-core-modules/xhr/xhr.js"); });
global.registerModule("fetch", function () { return __webpack_require__("../node_modules/tns-core-modules/fetch/fetch.js"); });
global.System = {
    import: function (path) {
        return new Promise(function (resolve, reject) {
            try {
                resolve(global.require(path));
            }
            catch (e) {
                reject(e);
            }
        });
    }
};
function registerOnGlobalContext(name, module) {
    Object.defineProperty(global, name, {
        get: function () {
            var m = global.loadModule(module);
            var resolvedValue = m[name];
            Object.defineProperty(this, name, { value: resolvedValue, configurable: true, writable: true });
            return resolvedValue;
        },
        configurable: true
    });
}
var snapshotGlobals;
function install() {
    if (global.__snapshot || global.__snapshotEnabled) {
        if (!snapshotGlobals) {
            var timer = __webpack_require__("../node_modules/tns-core-modules/timer/timer.js");
            var dialogs = __webpack_require__("../node_modules/tns-core-modules/ui/dialogs/dialogs.js");
            var xhr = __webpack_require__("../node_modules/tns-core-modules/xhr/xhr.js");
            var fetch_1 = __webpack_require__("../node_modules/tns-core-modules/fetch/fetch.js");
            snapshotGlobals = snapshotGlobals || {
                setTimeout: timer.setTimeout,
                clearTimeout: timer.clearTimeout,
                setInterval: timer.setInterval,
                clearInterval: timer.clearInterval,
                alert: dialogs.alert,
                confirm: dialogs.confirm,
                prompt: dialogs.prompt,
                login: dialogs.login,
                action: dialogs.action,
                XMLHttpRequest: xhr.XMLHttpRequest,
                FormData: xhr.FormData,
                fetch: fetch_1.fetch,
                Headers: fetch_1.Headers,
                Request: fetch_1.Request,
                Response: fetch_1.Response,
            };
        }
        var consoleModule = __webpack_require__("../node_modules/tns-core-modules/console/console.js").Console;
        global.console = global.console || new consoleModule();
        Object.assign(global, snapshotGlobals);
    }
    else {
        registerOnGlobalContext("setTimeout", "timer");
        registerOnGlobalContext("clearTimeout", "timer");
        registerOnGlobalContext("setInterval", "timer");
        registerOnGlobalContext("clearInterval", "timer");
        registerOnGlobalContext("alert", "ui/dialogs");
        registerOnGlobalContext("confirm", "ui/dialogs");
        registerOnGlobalContext("prompt", "ui/dialogs");
        registerOnGlobalContext("login", "ui/dialogs");
        registerOnGlobalContext("action", "ui/dialogs");
        registerOnGlobalContext("XMLHttpRequest", "xhr");
        registerOnGlobalContext("FormData", "xhr");
        registerOnGlobalContext("fetch", "fetch");
        registerOnGlobalContext("Headers", "fetch");
        registerOnGlobalContext("Request", "fetch");
        registerOnGlobalContext("Response", "fetch");
    }
}
exports.install = install;
install();
function Deprecated(target, key, descriptor) {
    if (descriptor) {
        var originalMethod_1 = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log(key.toString() + " is deprecated");
            return originalMethod_1.apply(this, args);
        };
        return descriptor;
    }
    else {
        console.log((target && target.name || target) + " is deprecated");
        return target;
    }
}
exports.Deprecated = Deprecated;
global.Deprecated = Deprecated;
function Experimental(target, key, descriptor) {
    if (descriptor) {
        var originalMethod_2 = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log(key.toString() + " is experimental");
            return originalMethod_2.apply(this, args);
        };
        return descriptor;
    }
    else {
        console.log((target && target.name || target) + " is experimental");
        return target;
    }
}
exports.Experimental = Experimental;
global.Experimental = Experimental;
//# sourceMappingURL=globals.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/globals/ts-helpers.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
if (!global.__extends) {
    global.__extends = function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) {
                d[p] = b[p];
            }
        }
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}
var tslib = __webpack_require__("../node_modules/tslib/tslib.es6.js");
for (var _i = 0, _a = Object.keys(tslib); _i < _a.length; _i++) {
    var fnName = _a[_i];
    if (typeof tslib[fnName] !== "function") {
        continue;
    }
    if (fnName in global) {
        continue;
    }
    global[fnName] = tslib[fnName];
}
//# sourceMappingURL=ts-helpers.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/http/http-request/http-request-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
function getFilenameFromUrl(url) {
    var fs = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
    var slashPos = url.lastIndexOf("/") + 1;
    var questionMarkPos = url.lastIndexOf("?");
    var actualFileName;
    if (questionMarkPos !== -1) {
        actualFileName = url.substring(slashPos, questionMarkPos);
    }
    else {
        actualFileName = url.substring(slashPos);
    }
    var result = fs.path.join(fs.knownFolders.documents().path, actualFileName);
    return result;
}
exports.getFilenameFromUrl = getFilenameFromUrl;
//# sourceMappingURL=http-request-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/http/http-request/http-request.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var domainDebugger = __webpack_require__("../node_modules/tns-core-modules/debugger/debugger.js");
var http_request_common_1 = __webpack_require__("../node_modules/tns-core-modules/http/http-request/http-request-common.js");
var HttpResponseEncoding;
(function (HttpResponseEncoding) {
    HttpResponseEncoding[HttpResponseEncoding["UTF8"] = 0] = "UTF8";
    HttpResponseEncoding[HttpResponseEncoding["GBK"] = 1] = "GBK";
})(HttpResponseEncoding = exports.HttpResponseEncoding || (exports.HttpResponseEncoding = {}));
var currentDevice = UIDevice.currentDevice;
var device = currentDevice.userInterfaceIdiom === 0 ? "Phone" : "Pad";
var osVersion = currentDevice.systemVersion;
var GET = "GET";
var USER_AGENT_HEADER = "User-Agent";
var USER_AGENT = "Mozilla/5.0 (i" + device + "; CPU OS " + osVersion.replace(".", "_") + " like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/" + osVersion + " Mobile/10A5355d Safari/8536.25";
var sessionConfig = NSURLSessionConfiguration.defaultSessionConfiguration;
var queue = NSOperationQueue.mainQueue;
function parseJSON(source) {
    var src = source.trim();
    if (src.lastIndexOf(")") === src.length - 1) {
        return JSON.parse(src.substring(src.indexOf("(") + 1, src.lastIndexOf(")")));
    }
    return JSON.parse(src);
}
var NSURLSessionTaskDelegateImpl = (function (_super) {
    __extends(NSURLSessionTaskDelegateImpl, _super);
    function NSURLSessionTaskDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NSURLSessionTaskDelegateImpl.prototype.URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler = function (session, task, response, request, completionHandler) {
        completionHandler(null);
    };
    NSURLSessionTaskDelegateImpl.ObjCProtocols = [NSURLSessionTaskDelegate];
    return NSURLSessionTaskDelegateImpl;
}(NSObject));
var sessionTaskDelegateInstance = NSURLSessionTaskDelegateImpl.new();
var defaultSession;
function ensureDefaultSession() {
    if (!defaultSession) {
        defaultSession = NSURLSession.sessionWithConfigurationDelegateDelegateQueue(sessionConfig, null, queue);
    }
}
var sessionNotFollowingRedirects;
function ensureSessionNotFollowingRedirects() {
    if (!sessionNotFollowingRedirects) {
        sessionNotFollowingRedirects = NSURLSession.sessionWithConfigurationDelegateDelegateQueue(sessionConfig, sessionTaskDelegateInstance, queue);
    }
}
var imageSource;
function ensureImageSource() {
    if (!imageSource) {
        imageSource = __webpack_require__("../node_modules/tns-core-modules/image-source/image-source.js");
    }
}
var fs;
function ensureFileSystem() {
    if (!fs) {
        fs = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
    }
}
function request(options) {
    return new Promise(function (resolve, reject) {
        if (!options.url) {
            reject(new Error("Request url was empty."));
            return;
        }
        try {
            var network = domainDebugger.getNetwork();
            var debugRequest_1 = network && network.create();
            var urlRequest = NSMutableURLRequest.requestWithURL(NSURL.URLWithString(options.url));
            urlRequest.HTTPMethod = types.isDefined(options.method) ? options.method : GET;
            urlRequest.setValueForHTTPHeaderField(USER_AGENT, USER_AGENT_HEADER);
            if (options.headers) {
                for (var header in options.headers) {
                    urlRequest.setValueForHTTPHeaderField(options.headers[header] + "", header);
                }
            }
            if (types.isString(options.content) || options.content instanceof FormData) {
                urlRequest.HTTPBody = NSString.stringWithString(options.content.toString()).dataUsingEncoding(4);
            }
            if (types.isNumber(options.timeout)) {
                urlRequest.timeoutInterval = options.timeout / 1000;
            }
            var session = void 0;
            if (types.isBoolean(options.dontFollowRedirects) && options.dontFollowRedirects) {
                ensureSessionNotFollowingRedirects();
                session = sessionNotFollowingRedirects;
            }
            else {
                ensureDefaultSession();
                session = defaultSession;
            }
            var dataTask = session.dataTaskWithRequestCompletionHandler(urlRequest, function (data, response, error) {
                if (error) {
                    reject(new Error(error.localizedDescription));
                }
                else {
                    var headers_1 = {};
                    if (response && response.allHeaderFields) {
                        var headerFields = response.allHeaderFields;
                        headerFields.enumerateKeysAndObjectsUsingBlock(function (key, value, stop) {
                            addHeader(headers_1, key, value);
                        });
                    }
                    if (debugRequest_1) {
                        debugRequest_1.mimeType = response.MIMEType;
                        debugRequest_1.data = data;
                        var debugResponse = {
                            url: options.url,
                            status: response.statusCode,
                            statusText: NSHTTPURLResponse.localizedStringForStatusCode(response.statusCode),
                            headers: headers_1,
                            mimeType: response.MIMEType,
                            fromDiskCache: false
                        };
                        debugRequest_1.responseReceived(debugResponse);
                        debugRequest_1.loadingFinished();
                    }
                    resolve({
                        content: {
                            raw: data,
                            toString: function (encoding) { return NSDataToString(data, encoding); },
                            toJSON: function (encoding) { return parseJSON(NSDataToString(data, encoding)); },
                            toImage: function () {
                                ensureImageSource();
                                return new Promise(function (resolve, reject) {
                                    UIImage.tns_decodeImageWithDataCompletion(data, function (image) {
                                        if (image) {
                                            resolve(imageSource.fromNativeSource(image));
                                        }
                                        else {
                                            reject(new Error("Response content may not be converted to an Image"));
                                        }
                                    });
                                });
                            },
                            toFile: function (destinationFilePath) {
                                ensureFileSystem();
                                if (!destinationFilePath) {
                                    destinationFilePath = http_request_common_1.getFilenameFromUrl(options.url);
                                }
                                if (data instanceof NSData) {
                                    var file = fs.File.fromPath(destinationFilePath);
                                    data.writeToFileAtomically(destinationFilePath, true);
                                    return file;
                                }
                                else {
                                    reject(new Error("Cannot save file with path: " + destinationFilePath + "."));
                                }
                            }
                        },
                        statusCode: response.statusCode,
                        headers: headers_1
                    });
                }
            });
            if (options.url && debugRequest_1) {
                var request_1 = {
                    url: options.url,
                    method: "GET",
                    headers: options.headers
                };
                debugRequest_1.requestWillBeSent(request_1);
            }
            dataTask.resume();
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.request = request;
function NSDataToString(data, encoding) {
    var code = NSUTF8StringEncoding;
    if (encoding === HttpResponseEncoding.GBK) {
        code = 1586;
    }
    var encodedString = NSString.alloc().initWithDataEncoding(data, code);
    if (!encodedString) {
        code = NSISOLatin1StringEncoding;
        encodedString = NSString.alloc().initWithDataEncoding(data, code);
    }
    return encodedString.toString();
}
function addHeader(headers, key, value) {
    if (!headers[key]) {
        headers[key] = value;
    }
    else if (Array.isArray(headers[key])) {
        headers[key].push(value);
    }
    else {
        var values = [headers[key]];
        values.push(value);
        headers[key] = values;
    }
}
exports.addHeader = addHeader;
//# sourceMappingURL=http-request.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/http/http.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var httpRequest = __webpack_require__("../node_modules/tns-core-modules/http/http-request/http-request.js");
__export(__webpack_require__("../node_modules/tns-core-modules/http/http-request/http-request.js"));
function getString(arg) {
    return new Promise(function (resolve, reject) {
        httpRequest.request(typeof arg === "string" ? { url: arg, method: "GET" } : arg)
            .then(function (r) {
            try {
                var str = r.content.toString();
                resolve(str);
            }
            catch (e) {
                reject(e);
            }
        }, function (e) { return reject(e); });
    });
}
exports.getString = getString;
function getJSON(arg) {
    return new Promise(function (resolve, reject) {
        httpRequest.request(typeof arg === "string" ? { url: arg, method: "GET" } : arg)
            .then(function (r) {
            try {
                var json = r.content.toJSON();
                resolve(json);
            }
            catch (e) {
                reject(e);
            }
        }, function (e) { return reject(e); });
    });
}
exports.getJSON = getJSON;
function getImage(arg) {
    return new Promise(function (resolve, reject) {
        httpRequest.request(typeof arg === "string" ? { url: arg, method: "GET" } : arg)
            .then(function (r) {
            try {
                resolve(r.content.toImage());
            }
            catch (err) {
                reject(err);
            }
        }, function (err) {
            reject(err);
        });
    });
}
exports.getImage = getImage;
function getFile(arg, destinationFilePath) {
    return new Promise(function (resolve, reject) {
        httpRequest.request(typeof arg === "string" ? { url: arg, method: "GET" } : arg)
            .then(function (r) {
            try {
                var file = r.content.toFile(destinationFilePath);
                resolve(file);
            }
            catch (e) {
                reject(e);
            }
        }, function (e) { return reject(e); });
    });
}
exports.getFile = getFile;
//# sourceMappingURL=http.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/image-source/image-source.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
exports.isFileOrResourcePath = utils_1.isFileOrResourcePath;
var http;
function ensureHttp() {
    if (!http) {
        http = __webpack_require__("../node_modules/tns-core-modules/http/http.js");
    }
}
var ImageSource = (function () {
    function ImageSource() {
    }
    ImageSource.prototype.fromAsset = function (asset) {
        return new Promise(function (resolve, reject) {
            asset.getImageAsync(function (image, err) {
                if (image) {
                    resolve(fromNativeSource(image));
                }
                else {
                    reject(err);
                }
            });
        });
    };
    ImageSource.prototype.loadFromResource = function (name) {
        this.ios = UIImage.tns_safeImageNamed(name) || UIImage.tns_safeImageNamed(name + ".jpg");
        return this.ios != null;
    };
    ImageSource.prototype.fromResource = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                UIImage.tns_safeDecodeImageNamedCompletion(name, function (image) {
                    if (image) {
                        _this.ios = image;
                        resolve(true);
                    }
                    else {
                        UIImage.tns_safeDecodeImageNamedCompletion(name + ".jpg", function (image) {
                            _this.ios = image;
                            resolve(true);
                        });
                    }
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    };
    ImageSource.prototype.loadFromFile = function (path) {
        this.ios = UIImage.imageWithContentsOfFile(getFileName(path));
        return this.ios != null;
    };
    ImageSource.prototype.fromFile = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                UIImage.tns_decodeImageWidthContentsOfFileCompletion(getFileName(path), function (image) {
                    _this.ios = image;
                    resolve(true);
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    };
    ImageSource.prototype.loadFromData = function (data) {
        this.ios = UIImage.imageWithData(data);
        return this.ios != null;
    };
    ImageSource.prototype.fromData = function (data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                UIImage.tns_decodeImageWithDataCompletion(data, function (image) {
                    _this.ios = image;
                    resolve(true);
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    };
    ImageSource.prototype.loadFromBase64 = function (source) {
        if (typeof source === "string") {
            var data = NSData.alloc().initWithBase64EncodedStringOptions(source, 1);
            this.ios = UIImage.imageWithData(data);
        }
        return this.ios != null;
    };
    ImageSource.prototype.fromBase64 = function (source) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                var data = NSData.alloc().initWithBase64EncodedStringOptions(source, 1);
                UIImage.imageWithData["async"](UIImage, [data]).then(function (image) {
                    _this.ios = image;
                    resolve(true);
                });
            }
            catch (ex) {
                reject(ex);
            }
        });
    };
    ImageSource.prototype.setNativeSource = function (source) {
        if (source && !(source instanceof UIImage)) {
            throw new Error("The method setNativeSource() expects UIImage instance.");
        }
        this.ios = source;
    };
    ImageSource.prototype.saveToFile = function (path, format, quality) {
        if (!this.ios) {
            return false;
        }
        if (quality) {
            quality = (quality - 0) / (100 - 0);
        }
        var data = getImageData(this.ios, format, quality);
        if (data) {
            return NSFileManager.defaultManager.createFileAtPathContentsAttributes(path, data, null);
        }
        return false;
    };
    ImageSource.prototype.toBase64String = function (format, quality) {
        var res = null;
        if (!this.ios) {
            return res;
        }
        if (quality) {
            quality = (quality - 0) / (100 - 0);
        }
        var data = getImageData(this.ios, format, quality);
        if (data) {
            res = data.base64Encoding();
        }
        return res;
    };
    Object.defineProperty(ImageSource.prototype, "height", {
        get: function () {
            if (this.ios) {
                return this.ios.size.height;
            }
            return NaN;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageSource.prototype, "width", {
        get: function () {
            if (this.ios) {
                return this.ios.size.width;
            }
            return NaN;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageSource.prototype, "rotationAngle", {
        get: function () {
            return NaN;
        },
        enumerable: true,
        configurable: true
    });
    return ImageSource;
}());
exports.ImageSource = ImageSource;
function getFileName(path) {
    var fileName = typeof path === "string" ? path.trim() : "";
    if (fileName.indexOf("~/") === 0) {
        fileName = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, fileName.replace("~/", ""));
    }
    return fileName;
}
function getImageData(instance, format, quality) {
    if (quality === void 0) { quality = 0.9; }
    var data = null;
    switch (format) {
        case "png":
            data = UIImagePNGRepresentation(instance);
            break;
        case "jpeg":
        case "jpg":
            data = UIImageJPEGRepresentation(instance, quality);
            break;
    }
    return data;
}
function fromAsset(asset) {
    var image = new ImageSource();
    return image.fromAsset(asset);
}
exports.fromAsset = fromAsset;
function fromResource(name) {
    var image = new ImageSource();
    return image.loadFromResource(name) ? image : null;
}
exports.fromResource = fromResource;
function fromFile(path) {
    var image = new ImageSource();
    return image.loadFromFile(path) ? image : null;
}
exports.fromFile = fromFile;
function fromData(data) {
    var image = new ImageSource();
    return image.loadFromData(data) ? image : null;
}
exports.fromData = fromData;
function fromBase64(source) {
    var image = new ImageSource();
    return image.loadFromBase64(source) ? image : null;
}
exports.fromBase64 = fromBase64;
function fromNativeSource(source) {
    var imageSource = new ImageSource();
    imageSource.setNativeSource(source);
    return imageSource;
}
exports.fromNativeSource = fromNativeSource;
function fromUrl(url) {
    ensureHttp();
    return http.getImage(url);
}
exports.fromUrl = fromUrl;
function fromFileOrResource(path) {
    if (!utils_1.isFileOrResourcePath(path)) {
        throw new Error("Path \"" + "\" is not a valid file or resource.");
    }
    if (path.indexOf(utils_1.RESOURCE_PREFIX) === 0) {
        return fromResource(path.substr(utils_1.RESOURCE_PREFIX.length));
    }
    return fromFile(path);
}
exports.fromFileOrResource = fromFileOrResource;
//# sourceMappingURL=image-source.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/inspector_modules.js":
/***/ (function(module, exports, __webpack_require__) {

console.log("Loading inspector modules...");
__webpack_require__("../node_modules/tns-core-modules/globals/ts-helpers.js");
__webpack_require__("../node_modules/tns-core-modules/debugger/webinspector-network.js");
__webpack_require__("../node_modules/tns-core-modules/debugger/webinspector-dom.js");
__webpack_require__("../node_modules/tns-core-modules/debugger/webinspector-css.js");
console.log("Finished loading inspector modules.");
//# sourceMappingURL=inspector_modules.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/js-libs/easysax/easysax.js":
/***/ (function(module, exports, __webpack_require__) {

﻿	/*
	new function() {
		var parser = new EasySAXParser();

		parser.ns('rss', { // or false
			rss: 'http://purl.org/rss/1.0/',
			atom: 'http://www.w3.org/2005/Atom',
			xhtml: 'http://www.w3.org/1999/xhtml',
			media: 'http://search.yahoo.com/mrss/'
		});


		parser.on('error', function(msg) {
			//console.log(msg)
		});

		parser.on('startNode', function(elem, attr, uq, tagend, getStrNode) {
			attr();
			return;
			if (tagend) {
				console.log('   '+str)
			} else {
				console.log('+  '+str)
			};
		});

		parser.on('endNode', function(elem, uq, tagstart, str) {
			return;
			if (!tagstart) console.log('-  ' + str)
		});

		parser.on('textNode', function(s, uq) {
			uq(s);
			return
			console.log('   '+s)
		});

		parser.on('cdata', function(data) {
		});


		parser.on('comment', function(text) {
			//console.log('--'+text+'--')
		});

		//parser.on('question', function() {}); // <? ... ?>
		//parser.on('attention', function() {}); // <!XXXXX zzzz="eeee">

		console.time('easysax');
		for(var z=1000;z--;) {
			parser.parse(xml)
		};
		console.timeEnd('easysax');
	};


	*/

// << ------------------------------------------------------------------------ >> //


if (true /*&& this == exports*/) {
	module.exports.EasySAXParser = EasySAXParser;
};

function EasySAXParser() {
	'use strict';

	if (!this) return null;

    this.angularSyntax = false;

	function nullFunc() {};

	this.onTextNode = nullFunc;
    this.onStartNode = nullFunc;
    this.onEndNode = nullFunc;
    this.onCDATA = nullFunc;
    this.onError = nullFunc;
    this.onComment = null;
    this.onQuestion = null;
    this.onAttention = null;
	this.is_onComment = this.is_onQuestion = this.is_onAttention = false;

	this.isNamespace = false;
    this.useNS = null;
    this.default_xmlns = null;
    this.xmlns = null;
	this.nsmatrix = {xmlns: this.xmlns};
	this.hasSurmiseNS = false;
	;


	this.attr_string = ''; // строка атрибутов
	this.attr_posstart = 0; //
	this.attr_res; // закешированный результат разбора атрибутов , null - разбор не проводился, object - хеш атрибутов, true - нет атрибутов, false - невалидный xml
}

EasySAXParser.prototype.on = function(name, cb) {
    if (typeof cb !== 'function') {
        if (cb !== null) return;
    };

    switch(name) {
        case 'error': this.onError = cb || nullFunc; break;
        case 'startNode': this.onStartNode = cb || nullFunc; break;
        case 'endNode': this.onEndNode = cb || nullFunc; break;
        case 'textNode': this.onTextNode = cb || nullFunc; break;
        case 'cdata': this.onCDATA = cb || nullFunc; break;

        case 'comment': this.onComment = cb; this.is_onComment = !!cb; break;
        case 'question': this.onQuestion = cb; this.is_onQuestion = !!cb; break; // <? ....  ?>
        case 'attention': this.onAttention = cb; this.is_onAttention = !!cb; break; // <!XXXXX zzzz="eeee">
    };
};

EasySAXParser.prototype.ns = function(root, ns) {
    if (!root || typeof root !== 'string' || !ns) {
        return;
    };

    var u, x = {}, ok, v, i;

    for(i in ns) {
        v = ns[i];
        if (typeof v === 'string') {
            if (root === v) ok = true;
            x[i] = v;
        };
    };

    if (ok) {
        this.isNamespace = true;
        this.default_xmlns = root;
        this.useNS = x;
    };
};


EasySAXParser.prototype.parse = function(xml) {
    if (typeof xml !== 'string') {
        return;
    };

    if (this.isNamespace) {
        this.nsmatrix = {xmlns: this.default_xmlns};

        parse(xml);

        this.nsmatrix = false;

    } else {
        parse(xml);
    };

    this.attr_res = true;
};

// -----------------------------------------------------

var xharsQuot={constructor: false, hasOwnProperty: false, isPrototypeOf: false, propertyIsEnumerable: false, toLocaleString: false, toString: false, valueOf: false
    , quot: '"'
    , QUOT: '"'
    , amp: '&'
    , AMP: '&'
    , nbsp: '\u00A0'
    , apos: '\''
    , lt: '<'
    , LT: '<'
    , gt: '>'
    , GT: '>'
    , copy: '\u00A9'
    , laquo: '\u00AB'
    , raquo: '\u00BB'
    , reg: '\u00AE'
    , deg: '\u00B0'
    , plusmn: '\u00B1'
    , sup2: '\u00B2'
    , sup3: '\u00B3'
    , micro: '\u00B5'
    , para: '\u00B6'
};


function rpEntities(s, d, x, z) {
    if (z) {
        return xharsQuot[z] || '\x01';
    };

    if (d) {
        return String.fromCharCode(d);
    };

    return String.fromCharCode(parseInt(x, 16));
};

function unEntities(s, i) {
    s = String(s);
    if (s.length > 3 && s.indexOf('&') !== -1) {
        if (s.indexOf('&gt;') !== -1) s = s.replace(/&gt;/g, '>');
        if (s.indexOf('&lt;') !== -1) s = s.replace(/&lt;/g, '<');
        if (s.indexOf('&quot;') !== -1) s = s.replace(/&quot;/g, '"');

        if (s.indexOf('&') !== -1) {
            s = s.replace(/&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/ig, rpEntities);
        };
    };

    return s;
};


EasySAXParser.prototype.allowedAngularAttributeChars = function(w) {
    if (!this.angularSyntax) {
        return false;
    } else {
        return (
            w === 40 || // (
            w === 41 || // )
            w === 91 || // [
            w === 93 || // ]
            w === 94 || // ^
            w === 35    // #
        );
    }
};

	/*
		парсит атрибуты по требованию. Важно! - функция не генерирует исключения.

		если была ошибка разбора возврашается false
		если атрибутов нет и разбор удачен то возврашается true
		если есть атрибуты то возврашается обьект(хеш)
	*/

EasySAXParser.prototype.getAttrs = function() {
    if (this.attr_res !== null) {
        return this.attr_res;
    };

    /*
    if (xxtest !== u && attr_string.indexOf(xxtest) === -1) {
        / *
            // для ускорения
            if (getAttrs('html').type == 'html') {
                ...
            };
        * /
        return true;
    };
    */

    var u
    , res = {}
    , s = this.attr_string
    , i = this.attr_posstart
    , l = s.length
    , attr_list = this.hasSurmiseNS ? [] : false
    , name, value = ''
    , ok = false
    , noValueAttribute = false
    , j, w, nn, n
    , hasNewMatrix
    , alias, newalias
    ;

    aa:
    for(; i < l; i++) {
        w = s.charCodeAt(i);

        if (w===32 || (w<14 && w > 8) ) { // \f\n\r\t\v
            continue
        };

        // Check for valid attribute start char
        if ((w < 65 && !this.allowedAngularAttributeChars(w)) ||
                w > 122 || (w > 90 && w < 97 && !this.allowedAngularAttributeChars(w)) ) { // ожидаем символ
            return this.attr_res = false; // error. invalid char
        };

        for(j = i + 1; j < l; j++) { // проверяем все символы имени атрибута
            w = s.charCodeAt(j);

            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46 /* https://github.com/telerik/xPlatCore/issues/179 */) {
                if (noValueAttribute) {
                    j--; //Started next attribute. Get back and break out of the loop.
                    break;
                } else {
                    continue;
                }
            };

            if (this.allowedAngularAttributeChars(w)) {
                continue;
            }

            if (w === 32 || (w > 8 && w < 14) ) {  // \f\n\r\t\v пробел
                noValueAttribute = true;
                continue;
            } else if (w === 61) { // "=" == 61
                noValueAttribute = false;
                break;
            } else {
                //console.log('error 2');
                if (!noValueAttribute)
                    return this.attr_res = false; // error. invalid char
            };

            break;
        };

        name = s.substring(i, j).trim();
        ok = true;

        if (name === 'xmlns:xmlns') {
            //console.log('error 6')
            return this.attr_res = false; // error. invalid name
        };

        w = s.charCodeAt(j+1);

        while (w = s.charCodeAt(j+1)) {
            if (w===32 || (w > 8 && w<14) ) {  // \f\n\r\t\v пробел
                j++;
            } else {
                break;
            }
        }

        if (!noValueAttribute) {
            if (w === 34) {  // '"'
                j = s.indexOf('"', i = j+2 );

            } else {
                if (w === 39) {
                    j = s.indexOf('\'', i = j+2 );

                } else {  // "'"
                    return this.attr_res = false; // error. invalid char
                };
            };
        }

        if (j === -1) {
            //console.log('error 4')
            return this.attr_res = false; // error. invalid char
        };


        if (j+1 < l && !noValueAttribute) {
            w = s.charCodeAt(j+1);

            if (w > 32 || w < 9 || (w < 32 && w > 13)) {
                // error. invalid char
                //console.log('error 5')
                return this.attr_res = false;
            };
        };


        if (noValueAttribute) {
            value = '';
        } else {
            value = s.substring(i, j);
        }

        //i = j + 1; // след. семвол уже проверен потому проверять нужно следуюший
        i = j; // след. семвол уже проверен потому проверять нужно следуюший

        if (this.isNamespace) { //
            if (this.hasSurmiseNS) {
                // есть подозрение что в атрибутах присутствует xmlns

                if (newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' && name.substr(6) ) {
                    alias = this.useNS[unEntities(value)];

                    if (alias) {
                        if (this.nsmatrix[newalias] !== alias) {
                            if (!hasNewMatrix) {
                                hasNewMatrix = true;
                                nn = {}; for (n in this.nsmatrix) nn[n] = this.nsmatrix[n];
                                this.nsmatrix = nn;
                            };

                            this.nsmatrix[newalias] = alias;
                        };
                    } else {
                        if (this.nsmatrix[newalias]) {
                            if (!hasNewMatrix) {
                                hasNewMatrix = true;
                                nn = {}; for (n in this.nsmatrix) nn[n] = this.nsmatrix[n];
                                this.nsmatrix = nn;
                            };

                            this.nsmatrix[newalias] = false;
                        };
                    };

                    res[name] = value;
                    continue;
                };

                attr_list.push(name, value);
                continue;
            };

            w = name.length;
            while(--w) {
                if (name.charCodeAt(w) === 58) { // ':'
                    if (w = this.nsmatrix[name.substring(0, w)] ) {
                        res[w + name.substr(w)] = value;
                    };
                    continue aa;

                    // 'xml:base' ???
                };
            };
        };

        res[name] = value;
        noValueAttribute = false;
    };


    if (!ok) {
        return this.attr_res = true;  // атрибутов нет, ошибок тоже нет
    };


    if (this.hasSurmiseNS)  {
        bb:

        for (i = 0, l = attr_list.length; i < l; i++) {
            name = attr_list[i++];

            w = name.length;
            while(--w) { // name.indexOf(':')
                if (name.charCodeAt(w) === 58) { // ':'
                    if (w = this.nsmatrix[name.substring(0, w)]) {
                        res[w + name.substr(w)] = attr_list[i];
                    };
                    continue bb;
                    break;
                };
            };

            res[name] = attr_list[i];
        };
    };

    return this.attr_res = res;
};


// xml - string
EasySAXParser.prototype.parse = function(xml) {
    var u
    , xml = String(xml)
    , nodestack = []
    , stacknsmatrix = []
    //, string_node
    , elem
    , tagend = false
    , tagstart = false
    , j = 0, i = 0, k = 0, len
    , x, y, q, w
    , xmlns
    , stopIndex = 0
    , stop // используется при разборе "namespace" . если встретился неизвестное пространство то события не генерируются
    , _nsmatrix
    , ok
    , pos = 0, ln = 0, lnStart = -2, lnEnd = -1
    ;

    len = xml.length;
    function getStringNode() {
        return xml.substring(i, j+1)
    };
    function findLineAndColumnFromPos() {
        while (lnStart < lnEnd && lnEnd < pos) {
            lnStart = lnEnd;
            lnEnd = xml.indexOf("\n", lnEnd + 1);
            ++ln;
        }
        return { line: ln, column: pos - lnStart };
    }
    function position(p) {
        pos = p;
        return findLineAndColumnFromPos;
    }

    while(j !== -1) {
        stop = stopIndex > 0;

        if (xml.charCodeAt(j) === 60) { // "<"
            i = j;
        } else {
            i = xml.indexOf('<', j);
        };

        if (i === -1) { // конец разбора

            if (nodestack.length) {
                this.onError('end file', position(j));
                return;
            };

            return;
        };

        if (j !== i && !stop) {
            ok = this.onTextNode(xml.substring(j, i), unEntities, position(j));
            if (ok === false) return;
        };

        w = xml.charCodeAt(i+1);

        if (w === 33) { // "!"
            w = xml.charCodeAt(i+2);
            if (w === 91 && xml.substr(i+3, 6) === 'CDATA[') { // 91 == "["
                j = xml.indexOf(']]>', i);
                if (j === -1) {
                    this.onError('cdata', position(i));
                    return;
                };

                //x = xml.substring(i+9, j);
                if (!stop) {
                    ok = this.onCDATA(xml.substring(i+9, j), false, position(i));
                    if (ok === false) return;
                };

                j += 3;
                continue;
            };

            if (w === 45 && xml.charCodeAt(i+3) === 45) { // 45 == "-"
                j = xml.indexOf('-->', i);
                if (j === -1) {
                    this.onError('expected -->', position(i));
                    return;
                };


                if (this.is_onComment && !stop) {
                    ok = this.onComment(xml.substring(i+4, j), unEntities, position(i));
                    if (ok === false) return;
                };

                j += 3;
                continue;
            };

            j = xml.indexOf('>', i+1);
            if (j === -1) {
                this.onError('expected ">"', position(i + 1));
                return;
            };

            if (this.is_onAttention && !stop) {
                ok = this.onAttention(xml.substring(i, j+1), unEntities, position(i));
                if (ok === false) return;
            };

            j += 1;
            continue;

        } else {
            if (w === 63) { // "?"
                j = xml.indexOf('?>', i);
                if (j === -1) { // error
                    this.onError('...?>', position(i));
                    return;
                };

                if (this.is_onQuestion) {
                    ok = this.onQuestion(xml.substring(i, j+2), position(i));
                    if (ok === false) return;
                };

                j += 2;
                continue;
            };
        };

        var inside=false;
        for (k=i,j=-1;k<len;k++) {
            var c = xml.charCodeAt(k);
            if (!inside) {

                if (c === 34) { // '"'
                    inside = c;
                }
                else if (c === 39) { // "'"
                    inside = c;
                }
                else if (c === 62) { // <
                    j = k; break;
                }
            } else {
                if (c === inside) { inside = false; }
            }
        }

        if (j == -1) { // error
            this.onError('...>', position(i + 1));
            return;
        };

        this.attr_res = true; // атрибутов нет

        //if (xml.charCodeAt(i+1) === 47) { // </...
        if (w === 47) { // </...
            tagstart = false;
            tagend = true;

            // проверяем что должен быть закрыт тотже тег что и открывался
            x = elem = nodestack.pop();
            q = i + 2 + x.length;

            //console.log()
            if (xml.substring(i+2, q) !== x) {
                this.onError('close tagname', position(i + 2));
                return;
            };

            // проверим что в закрываюшем теге нет лишнего
            for(; q < j; q++) {
                w = xml.charCodeAt(q);

                if (w===32 || (w > 8 && w<14) ) {  // \f\n\r\t\v пробел
                    continue;
                };

                this.onError('close tag', position(i + 2));
                return;
            };

        } else {
            if (xml.charCodeAt(j-1) ===  47) { // .../>
                x = elem = xml.substring(i+1, j-1);

                tagstart = true;
                tagend = true;
            } else {
                x = elem = xml.substring(i+1, j);

                tagstart = true;
                tagend = false;
            };

            if ( !(w > 96  && w < 123 || w > 64 && w <91) ) {
                this.onError('first char nodeName', position(i + 1));
                return;
            };

            for(q = 1, y = x.length; q < y; q++) {
                w = x.charCodeAt(q);

                if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w === 46 /* https://github.com/telerik/xPlatCore/issues/179 */) {
                    continue;
                };

                if (w===32 || (w<14 && w > 8)) { // \f\n\r\t\v пробел
                    elem = x.substring(0, q)
                    this.attr_res = null; // возможно есть атирибуты
                    break;
                };

                this.onError('invalid nodeName', position(i + 1));
                return;
            };

            if (!tagend) {
                nodestack.push(elem);
            };
        };


        if (this.isNamespace) {
            if (stop) {
                if (tagend) {
                    if (!tagstart) {
                        if (--stopIndex === 0) {
                            this.nsmatrix = stacknsmatrix.pop();
                        };
                    };

                } else {
                    stopIndex += 1;
                };


                j += 1;
                continue;
            };

            _nsmatrix = this.nsmatrix;

            if (!tagend) {
                stacknsmatrix.push(this.nsmatrix);

                if (this.attr_res !== true) {
                    if (this.hasSurmiseNS = x.indexOf('xmlns', q) !== -1) {
                        this.attr_string = x;
                        this.attr_posstart = q;

                        this.getAttrs();

                        this.hasSurmiseNS = false;
                    };
                };
            };


            w = elem.indexOf(':');
            if (w !== -1) {
                xmlns = this.nsmatrix[elem.substring(0, w)];
                elem = elem.substr(w+1);

            } else {
                xmlns = this.nsmatrix.xmlns;
            };

            if (!xmlns) {
                if (tagend) {
                    if (tagstart) {
                        this.nsmatrix = _nsmatrix;
                    } else {
                        this.nsmatrix = stacknsmatrix.pop();
                    };
                } else {
                    stopIndex = 1; // первый элемент для которого не определено пространство имен
                    this.attr_res = true;
                };

                j += 1;
                continue;
            };

            elem = xmlns + ':' + elem;
        };

        //string_node = xml.substring(i, j+1); // текст ноды как есть

        if (tagstart) { // is_onStartNode
            this.attr_string = x;
            this.attr_posstart = q;

            var that = this;
            ok = this.onStartNode(elem, function() { return that.getAttrs() }, unEntities, tagend
                , getStringNode, position(i)
            );

            if (ok === false) {
                return;
            };

            this.attr_res = true;
        };

        if (tagend) {
            ok = this.onEndNode(elem, unEntities, tagstart
                , getStringNode, position(i)
            );

            if (ok === false) {
                return;
            };

            if (this.isNamespace) {
                if (tagstart) {
                    this.nsmatrix = _nsmatrix;
                } else {
                    this.nsmatrix = stacknsmatrix.pop();
                };
            };
        };

        j += 1;
    };
};


/***/ }),

/***/ "../node_modules/tns-core-modules/js-libs/esprima/esprima.js":
/***/ (function(module, exports) {

﻿/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (global) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        Messages,
        source,
        index,
        length,
        delegate,
        lookahead,
        state;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        ArrayExpression: 'ArrayExpression',
        BinaryExpression: 'BinaryExpression',
        CallExpression: 'CallExpression',
        ConditionalExpression: 'ConditionalExpression',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        Identifier: 'Identifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ThisExpression: 'ThisExpression',
        UnaryExpression: 'UnaryExpression'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared'
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122);          // a..z
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57);           // 0..9
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        return (id === 'this')
    }

    // 7.4 Comments

    function skipWhitespace() {
        while (index < length && isWhiteSpace(source.charCodeAt(index))) {
            ++index;
        }
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        id = getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2;

        switch (code) {

            // Check for most common single-character punctuators.
            case 46:   // . dot
            case 40:   // ( open bracket
            case 41:   // ) close bracket
            case 59:   // ; semicolon
            case 44:   // , comma
            case 123:  // { open curly brace
            case 125:  // } close curly brace
            case 91:   // [
            case 93:   // ]
            case 58:   // :
            case 63:   // ?
                ++index;
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    range: [start, index]
                };

            default:
                code2 = source.charCodeAt(index + 1);

                // '=' (char #61) marks an assignment or comparison operator.
                if (code2 === 61) {
                    switch (code) {
                        case 37:  // %
                        case 38:  // &
                        case 42:  // *:
                        case 43:  // +
                        case 45:  // -
                        case 47:  // /
                        case 60:  // <
                        case 62:  // >
                        case 124: // |
                            index += 2;
                            return {
                                type: Token.Punctuator,
                                value: String.fromCharCode(code) + String.fromCharCode(code2),
                                range: [start, index]
                            };

                        case 33: // !
                        case 61: // =
                            index += 2;

                            // !== and ===
                            if (source.charCodeAt(index) === 61) {
                                ++index;
                            }
                            return {
                                type: Token.Punctuator,
                                value: source.slice(start, index),
                                range: [start, index]
                            };
                        default:
                            break;
                    }
                }
                break;
        }

        // Peek more characters.

        ch2 = source[index + 1];

        // Other 2-character punctuators: && ||

        if (ch1 === ch2 && ('&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals
    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;

                        default:
                            str += ch;
                            break;
                    }
                } else {
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch;

        skipWhitespace();

        if (index >= length) {
            return {
                type: Token.EOF,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];

        lookahead = advance();

        index = token.range[1];

        return token;
    }

    function peek() {
        var pos;

        pos = index;
        lookahead = advance();
        index = pos;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        error = new Error(msg);
        error.index = index;
        error.description = msg;
        throw error;
    }

    // Throw an exception because of the token.

    function throwUnexpected(token) {
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        skipWhitespace();

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parseObjectPropertyKey() {
        var token;

        skipWhitespace();
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key;

        token = lookahead;
        skipWhitespace();

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        }

        key = parseObjectPropertyKey();
        expect(':');
        return delegate.createProperty('init', key, parseExpression());
    }

    function parseObjectInitialiser() {
        var properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty());

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr;

        if (match('(')) {
            return parseGroupExpression();
        }

        type = lookahead.type;

        if (type === Token.Identifier) {
            expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('[')) {
            expr = parseArrayInitialiser();
        } else if (match('{')) {
            expr = parseObjectInitialiser();
        }

        if (expr) {
            return expr;
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token;

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, args, property;

        expr = parsePrimaryExpression();

        while (true) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else {
                break;
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    var parsePostfixExpression = parseLeftHandSideExpression;

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('+') || match('-') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            throwError({}, Messages.UnexpectedToken);
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
            case '||':
                prec = 1;
                break;

            case '&&':
                prec = 2;
                break;

            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;

            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;

            case 'in':
                prec = 7;
                break;

            case '+':
            case '-':
                prec = 9;
                break;

            case '*':
            case '/':
            case '%':
                prec = 11;
                break;

            default:
                break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, stack, right, operator, left, i;

        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            consequent = parseConditionalExpression();
            expect(':');
            alternate = parseConditionalExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // Simplification since we do not support AssignmentExpression.
    var parseExpression = parseConditionalExpression;

    // Polymer Syntax extensions

    // Filter ::
    //   Identifier
    //   Identifier "(" ")"
    //   Identifier "(" FilterArguments ")"

    function parseFilter() {
        var identifier, args;

        identifier = lex();

        if (identifier.type !== Token.Identifier) {
            throwUnexpected(identifier);
        }

        args = match('(') ? parseArguments() : [];

        return delegate.createFilter(identifier.value, args);
    }

    // Filters ::
    //   "|" Filter
    //   Filters "|" Filter

    function parseFilters() {
        while (match('|')) {
            lex();
            parseFilter();
        }
    }

    // TopLevel ::
    //   LabelledExpressions
    //   AsExpression
    //   InExpression
    //   FilterExpression

    // AsExpression ::
    //   FilterExpression as Identifier

    // InExpression ::
    //   Identifier, Identifier in FilterExpression
    //   Identifier in FilterExpression

    // FilterExpression ::
    //   Expression
    //   Expression Filters

    function parseTopLevel() {
        skipWhitespace();
        peek();

        var expr = parseExpression();
        if (expr) {
            if (lookahead.value === ',' || lookahead.value == 'in' &&
                       expr.type === Syntax.Identifier) {
                parseInExpression(expr);
            } else {
                parseFilters();
                if (lookahead.value === 'as') {
                    parseAsExpression(expr);
                } else {
                    delegate.createTopLevel(expr);
                }
            }
        }

        if (lookahead.type !== Token.EOF) {
            throwUnexpected(lookahead);
        }
    }

    function parseAsExpression(expr) {
        lex();  // as
        var identifier = lex().value;
        delegate.createAsExpression(expr, identifier);
    }

    function parseInExpression(identifier) {
        var indexName;
        if (lookahead.value === ',') {
            lex();
            if (lookahead.type !== Token.Identifier)
                throwUnexpected(lookahead);
            indexName = lex().value;
        }

        lex();  // in
        var expr = parseExpression();
        parseFilters();
        delegate.createInExpression(identifier.name, indexName, expr);
    }

    function parse(code, inDelegate) {
        delegate = inDelegate;
        source = code;
        index = 0;
        length = source.length;
        lookahead = null;
        state = {
            labelSet: {}
        };

        return parseTopLevel();
    }

    global.esprima = {
        parse: parse
    };
})(module.exports);

/***/ }),

/***/ "../node_modules/tns-core-modules/js-libs/polymer-expressions/path-parser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
﻿/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */



function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
        return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
        return false;
    }

    try {
        var f = new Function('', 'return true;');
        return f();
    } catch (ex) {
        return false;
    }
}

var hasEval = detectEval();

function isIndex(s) {
    return +s === s >>> 0 && s !== '';
}

function toNumber(s) {
    return +s;
}

function isObject(obj) {
    return obj === Object(obj);
}

var numberIsNaN = Number.isNaN || function (value) {
    return typeof value === 'number' && isNaN(value);
}

function areSameValue(left, right) {
    if (left === right)
        return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
        return true;

    return left !== left && right !== right;
}

var createObject = ('__proto__' in {}) ?
  function (obj) { return obj; } :
  function (obj) {
      var proto = obj.__proto__;
      if (!proto)
          return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function (name) {
          Object.defineProperty(newObject, name,
                               Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
  };

var identStart = '[\$_a-zA-Z]';
var identPart = '[\$_a-zA-Z0-9]';
var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

function getPathCharType(char) {
    if (char === undefined)
        return 'eof';

    var code = char.charCodeAt(0);

    switch (code) {
        case 0x5B: // [
        case 0x5D: // ]
        case 0x2E: // .
        case 0x22: // "
        case 0x27: // '
        case 0x30: // 0
            return char;

        case 0x5F: // _
        case 0x24: // $
            return 'ident';

        case 0x20: // Space
        case 0x09: // Tab
        case 0x0A: // Newline
        case 0x0D: // Return
        case 0xA0:  // No-break space
        case 0xFEFF:  // Byte Order Mark
        case 0x2028:  // Line Separator
        case 0x2029:  // Paragraph Separator
            return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
        return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
        return 'number';

    return 'else';
}

var pathStateMachine = {
    'beforePath': {
        'ws': ['beforePath'],
        'ident': ['inIdent', 'append'],
        '[': ['beforeElement'],
        'eof': ['afterPath']
    },

    'inPath': {
        'ws': ['inPath'],
        '.': ['beforeIdent'],
        '[': ['beforeElement'],
        'eof': ['afterPath']
    },

    'beforeIdent': {
        'ws': ['beforeIdent'],
        'ident': ['inIdent', 'append']
    },

    'inIdent': {
        'ident': ['inIdent', 'append'],
        '0': ['inIdent', 'append'],
        'number': ['inIdent', 'append'],
        'ws': ['inPath', 'push'],
        '.': ['beforeIdent', 'push'],
        '[': ['beforeElement', 'push'],
        'eof': ['afterPath', 'push']
    },

    'beforeElement': {
        'ws': ['beforeElement'],
        '0': ['afterZero', 'append'],
        'number': ['inIndex', 'append'],
        "'": ['inSingleQuote', 'append', ''],
        '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
        'ws': ['afterElement', 'push'],
        ']': ['inPath', 'push']
    },

    'inIndex': {
        '0': ['inIndex', 'append'],
        'number': ['inIndex', 'append'],
        'ws': ['afterElement'],
        ']': ['inPath', 'push']
    },

    'inSingleQuote': {
        "'": ['afterElement'],
        'eof': ['error'],
        'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
        '"': ['afterElement'],
        'eof': ['error'],
        'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
        'ws': ['afterElement'],
        ']': ['inPath', 'push']
    }
}

function noop() { }

function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
        push: function () {
            if (key === undefined)
                return;

            keys.push(key);
            key = undefined;
        },

        append: function () {
            if (key === undefined)
                key = newChar
            else
                key += newChar;
        }
    };

    function maybeUnescapeQuote() {
        if (index >= path.length)
            return;

        var nextChar = path[index + 1];
        if ((mode == 'inSingleQuote' && nextChar == "'") ||
            (mode == 'inDoubleQuote' && nextChar == '"')) {
            index++;
            newChar = nextChar;
            actions.append();
            return true;
        }
    }

    while (mode) {
        index++;
        c = path[index];

        if (c == '\\' && maybeUnescapeQuote(mode))
            continue;

        type = getPathCharType(c);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap['else'] || 'error';

        if (transition == 'error')
            return; // parse error;

        mode = transition[0];
        action = actions[transition[1]] || noop;
        newChar = transition[2] === undefined ? c : transition[2];
        action();

        if (mode === 'afterPath') {
            return keys;
        }
    }

    return; // parse error
}

function isIdent(s) {
    return identRegExp.test(s);
}

var constructorIsPrivate = {};

function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
        throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
        this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
        this.getValueFrom = this.compiledGetValueFromFn();
    }
}

// TODO(rafaelw): Make simple LRU cache
var pathCache = {};

function getPath(pathString) {
    if (pathString instanceof Path)
        return pathString;

    if (pathString == null || pathString.length == 0)
        pathString = '';

    if (typeof pathString != 'string') {
        if (isIndex(pathString.length)) {
            // Constructed with array-like (pre-parsed) keys
            return new Path(pathString, constructorIsPrivate);
        }

        pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
        return path;

    var parts = parsePath(pathString);
    if (!parts)
        return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
}

Path.get = getPath;

function formatAccessor(key) {
    if (isIndex(key)) {
        return '[' + key + ']';
    } else {
        return '["' + key.replace(/"/g, '\\"') + '"]';
    }
}

Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function () {
        var pathString = '';
        for (var i = 0; i < this.length; i++) {
            var key = this[i];
            if (isIdent(key)) {
                pathString += i ? '.' + key : key;
            } else {
                pathString += formatAccessor(key);
            }
        }

        return pathString;
    },

    getValueFrom: function (obj, directObserver) {
        for (var i = 0; i < this.length; i++) {
            if (obj == null)
                return;
            obj = obj[this[i]];
        }
        return obj;
    },

    iterateObjects: function (obj, observe) {
        for (var i = 0; i < this.length; i++) {
            if (i)
                obj = obj[this[i - 1]];
            if (!isObject(obj))
                return;
            observe(obj, this[i]);
        }
    },

    compiledGetValueFromFn: function () {
        var str = '';
        var pathString = 'obj';
        str += 'if (obj != null';
        var i = 0;
        var key;
        for (; i < (this.length - 1) ; i++) {
            key = this[i];
            pathString += isIdent(key) ? '.' + key : formatAccessor(key);
            str += ' &&\n     ' + pathString + ' != null';
        }
        str += ')\n';

        var key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);

        str += '  return ' + pathString + ';\nelse\n  return undefined;';
        return new Function('obj', str);
    },

    setValueFrom: function (obj, value) {
        if (!this.length)
            return false;

        for (var i = 0; i < this.length - 1; i++) {
            if (!isObject(obj))
                return false;
            obj = obj[this[i]];
        }

        if (!isObject(obj))
            return false;

        obj[this[i]] = value;
        return true;
    }
});

var invalidPath = new Path('', constructorIsPrivate);
invalidPath.valid = false;
invalidPath.getValueFrom = invalidPath.setValueFrom = function () { };

exports.Path = Path;


/***/ }),

/***/ "../node_modules/tns-core-modules/js-libs/polymer-expressions/polymer-expressions.js":
/***/ (function(module, exports, __webpack_require__) {

﻿// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

var esprima = __webpack_require__("../node_modules/tns-core-modules/js-libs/esprima/esprima.js").esprima;
var Path = __webpack_require__("../node_modules/tns-core-modules/js-libs/polymer-expressions/path-parser.js").Path;

(function (global) {
    'use strict';

    // TODO(rafaelw): Implement simple LRU.
    var expressionParseCache = Object.create(null);

    function getExpression(expressionText) {
        var expression = expressionParseCache[expressionText];
        if (!expression) {
            var delegate = new ASTDelegate();
            esprima.parse(expressionText, delegate);
            expression = new Expression(delegate);
            expressionParseCache[expressionText] = expression;
        }
        return expression;
    }

    function Literal(value) {
        this.value = value;
        this.valueFn_ = undefined;
    }

    Literal.prototype = {
        valueFn: function () {
            if (!this.valueFn_) {
                var value = this.value;
                this.valueFn_ = function () {
                    return value;
                }
            }

            return this.valueFn_;
        }
    }

    function IdentPath(name) {
        this.name = name;
        this.path = Path.get(name);
    }

    IdentPath.prototype = {
        valueFn: function () {
            if (!this.valueFn_) {
                var name = this.name;
                var path = this.path;
                this.valueFn_ = function (model, observer, changedModel) {
                    if (observer)
                        observer.addPath(model, path);

                    if (changedModel) {
                        var result = path.getValueFrom(changedModel);
                        if (result !== undefined) {
                            return result;
                        }
                    }

                    return path.getValueFrom(model);
                }
            }

            return this.valueFn_;
        },

        setValue: function (model, newValue) {
            if (this.path.length == 1) {
                model = findScope(model, this.path[0]);
            }

            return this.path.setValueFrom(model, newValue);
        }
    };

    function MemberExpression(object, property, accessor) {
        this.computed = accessor == '[';

        this.dynamicDeps = typeof object == 'function' ||
                           object.dynamicDeps ||
                           (this.computed && !(property instanceof Literal));

        this.simplePath =
            !this.dynamicDeps &&
            (property instanceof IdentPath || property instanceof Literal) &&
            (object instanceof MemberExpression || object instanceof IdentPath);

        this.object = this.simplePath ? object : getFn(object);
        this.property = !this.computed || this.simplePath ?
            property : getFn(property);
    }

    MemberExpression.prototype = {
        get fullPath() {
            if (!this.fullPath_) {

                var parts = this.object instanceof MemberExpression ?
                    this.object.fullPath.slice() : [this.object.name];
                parts.push(this.property instanceof IdentPath ?
                    this.property.name : this.property.value);
                this.fullPath_ = Path.get(parts);
            }

            return this.fullPath_;
        },

        valueFn: function () {
            if (!this.valueFn_) {
                var object = this.object;

                if (this.simplePath) {
                    var path = this.fullPath;

                    this.valueFn_ = function (model, observer) {
                        if (observer)
                            observer.addPath(model, path);

                        return path.getValueFrom(model);
                    };
                } else if (!this.computed) {
                    var path = Path.get(this.property.name);

                    this.valueFn_ = function (model, observer, filterRegistry) {
                        var context = object(model, observer, filterRegistry);

                        if (observer)
                            observer.addPath(context, path);

                        return path.getValueFrom(context);
                    }
                } else {
                    // Computed property.
                    var property = this.property;

                    this.valueFn_ = function (model, observer, filterRegistry) {
                        var context = object(model, observer, filterRegistry);
                        var propName = property(model, observer, filterRegistry);
                        if (observer)
                            observer.addPath(context, [propName]);

                        return context ? context[propName] : undefined;
                    };
                }
            }
            return this.valueFn_;
        },

        setValue: function (model, newValue) {
            if (this.simplePath) {
                this.fullPath.setValueFrom(model, newValue);
                return newValue;
            }

            var object = this.object(model);
            var propName = this.property instanceof IdentPath ? this.property.name :
                this.property(model);
            return object[propName] = newValue;
        }
    };

    function Filter(name, args) {
        this.name = name;
        this.args = [];
        for (var i = 0; i < args.length; i++) {
            this.args[i] = getFn(args[i]);
        }
    }

    Filter.prototype = {
        transform: function (model, observer, filterRegistry, toModelDirection,
                            initialArgs) {
            var fn = filterRegistry[this.name];
            var context = model;
            if (fn) {
                context = undefined;
            } else {
                fn = context[this.name];
                if (!fn) {
                    console.error('Cannot find function or filter: ' + this.name);
                    return;
                }
            }

            // If toModelDirection is falsey, then the "normal" (dom-bound) direction
            // is used. Otherwise, it looks for a 'toModel' property function on the
            // object.
            if (toModelDirection) {
                fn = fn.toModel;
            } else if (typeof fn.toView == 'function') {
                fn = fn.toView;
            }

            if (typeof fn != 'function') {
                console.error('Cannot find function or filter: ' + this.name);
                return;
            }

            var args = initialArgs || [];
            for (var i = 0; i < this.args.length; i++) {
                args.push(getFn(this.args[i])(model, observer, filterRegistry));
            }

            return fn.apply(context, args);
        }
    };

    function notImplemented() { throw Error('Not Implemented'); }

    var unaryOperators = {
        '+': function (v) { return +v; },
        '-': function (v) { return -v; },
        '!': function (v) { return !v; }
    };

    var binaryOperators = {
        '+': function (l, r) { return l + r; },
        '-': function (l, r) { return l - r; },
        '*': function (l, r) { return l * r; },
        '/': function (l, r) { return l / r; },
        '%': function (l, r) { return l % r; },
        '<': function (l, r) { return l < r; },
        '>': function (l, r) { return l > r; },
        '<=': function (l, r) { return l <= r; },
        '>=': function (l, r) { return l >= r; },
        '==': function (l, r) { return l == r; },
        '!=': function (l, r) { return l != r; },
        '===': function (l, r) { return l === r; },
        '!==': function (l, r) { return l !== r; },
        '&&': function (l, r) { return l && r; },
        '||': function (l, r) { return l || r; },
    };

    function getFn(arg) {
        return typeof arg == 'function' ? arg : arg.valueFn();
    }

    function ASTDelegate() {
        this.expression = null;
        this.filters = [];
        this.deps = {};
        this.currentPath = undefined;
        this.scopeIdent = undefined;
        this.indexIdent = undefined;
        this.dynamicDeps = false;
    }

    ASTDelegate.prototype = {
        createUnaryExpression: function (op, argument) {
            if (!unaryOperators[op])
                throw Error('Disallowed operator: ' + op);

            argument = getFn(argument);

            return function (model, observer, filterRegistry) {
                return unaryOperators[op](argument(model, observer, filterRegistry));
            };
        },

        createBinaryExpression: function (op, left, right) {
            if (!binaryOperators[op])
                throw Error('Disallowed operator: ' + op);

            left = getFn(left);
            right = getFn(right);

            switch (op) {
                case '||':
                    this.dynamicDeps = true;
                    return function (model, observer, filterRegistry) {
                        return left(model, observer, filterRegistry) ||
                            right(model, observer, filterRegistry);
                    };
                case '&&':
                    this.dynamicDeps = true;
                    return function (model, observer, filterRegistry) {
                        return left(model, observer, filterRegistry) &&
                            right(model, observer, filterRegistry);
                    };
            }

            return function (model, observer, filterRegistry) {
                return binaryOperators[op](left(model, observer, filterRegistry),
                                           right(model, observer, filterRegistry));
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            test = getFn(test);
            consequent = getFn(consequent);
            alternate = getFn(alternate);

            this.dynamicDeps = true;

            return function (model, observer, filterRegistry) {
                return test(model, observer, filterRegistry) ?
                    consequent(model, observer, filterRegistry) :
                    alternate(model, observer, filterRegistry);
            }
        },

        createIdentifier: function (name) {
            var ident = new IdentPath(name);
            ident.type = 'Identifier';
            return ident;
        },

        createMemberExpression: function (accessor, object, property) {
            var ex = new MemberExpression(object, property, accessor);
            if (ex.dynamicDeps)
                this.dynamicDeps = true;
            return ex;
        },

        createCallExpression: function (expression, args) {
            if (!(expression instanceof IdentPath))
                throw Error('Only identifier function invocations are allowed');

            var filter = new Filter(expression.name, args);

            return function (model, observer, filterRegistry) {
                return filter.transform(model, observer, filterRegistry, false);
            };
        },

        createLiteral: function (token) {
            return new Literal(token.value);
        },

        createArrayExpression: function (elements) {
            for (var i = 0; i < elements.length; i++)
                elements[i] = getFn(elements[i]);

            return function (model, observer, filterRegistry) {
                var arr = []
                for (var i = 0; i < elements.length; i++)
                    arr.push(elements[i](model, observer, filterRegistry));
                return arr;
            }
        },

        createProperty: function (kind, key, value) {
            return {
                key: key instanceof IdentPath ? key.name : key.value,
                value: value
            };
        },

        createObjectExpression: function (properties) {
            for (var i = 0; i < properties.length; i++)
                properties[i].value = getFn(properties[i].value);

            return function (model, observer, filterRegistry) {
                var obj = {};
                for (var i = 0; i < properties.length; i++)
                    obj[properties[i].key] =
                        properties[i].value(model, observer, filterRegistry);
                return obj;
            }
        },

        createFilter: function (name, args) {
            this.filters.push(new Filter(name, args));
        },

        createAsExpression: function (expression, scopeIdent) {
            this.expression = expression;
            this.scopeIdent = scopeIdent;
        },

        createInExpression: function (scopeIdent, indexIdent, expression) {
            this.expression = expression;
            this.scopeIdent = scopeIdent;
            this.indexIdent = indexIdent;
        },

        createTopLevel: function (expression) {
            this.expression = expression;
        },

        createThisExpression: notImplemented
    }

    function Expression(delegate) {
        this.scopeIdent = delegate.scopeIdent;
        this.indexIdent = delegate.indexIdent;

        if (!delegate.expression)
            throw Error('No expression found.');

        this.expression = delegate.expression;
        getFn(this.expression); // forces enumeration of path dependencies

        this.filters = delegate.filters;
        this.dynamicDeps = delegate.dynamicDeps;
    }

    Expression.prototype = {
        getValue: function (model, isBackConvert, changedModel, observer) {
            var value = getFn(this.expression)(model.context, observer, changedModel);
            for (var i = 0; i < this.filters.length; i++) {
                value = this.filters[i].transform(model.context, observer, model.context, isBackConvert, [value]);
            }

            return value;
        },

        setValue: function (model, newValue, filterRegistry) {
            var count = this.filters ? this.filters.length : 0;
            while (count-- > 0) {
                newValue = this.filters[count].transform(model, undefined,
                    filterRegistry, true, [newValue]);
            }

            if (this.expression.setValue)
                return this.expression.setValue(model, newValue);
        }
    }

    /**
     * Converts a style property name to a css property name. For example:
     * "WebkitUserSelect" to "-webkit-user-select"
     */
    function convertStylePropertyName(name) {
        return String(name).replace(/[A-Z]/g, function (c) {
            return '-' + c.toLowerCase();
        });
    }

    var parentScopeName = '@' + Math.random().toString(36).slice(2);

    // Single ident paths must bind directly to the appropriate scope object.
    // I.e. Pushed values in two-bindings need to be assigned to the actual model
    // object.
    function findScope(model, prop) {
        while (model[parentScopeName] &&
               !Object.prototype.hasOwnProperty.call(model, prop)) {
            model = model[parentScopeName];
        }

        return model;
    }

    function isLiteralExpression(pathString) {
        switch (pathString) {
            case '':
                return false;

            case 'false':
            case 'null':
            case 'true':
                return true;
        }

        if (!isNaN(Number(pathString)))
            return true;

        return false;
    };

    function PolymerExpressions() { }

    PolymerExpressions.prototype = {
        // "built-in" filters
        styleObject: function (value) {
            var parts = [];
            for (var key in value) {
                parts.push(convertStylePropertyName(key) + ': ' + value[key]);
            }
            return parts.join('; ');
        },

        tokenList: function (value) {
            var tokens = [];
            for (var key in value) {
                if (value[key])
                    tokens.push(key);
            }
            return tokens.join(' ');
        },

        // binding delegate API
        prepareInstancePositionChanged: function (template) {
            var indexIdent = template.polymerExpressionIndexIdent_;
            if (!indexIdent)
                return;

            return function (templateInstance, index) {
                templateInstance.model[indexIdent] = index;
            };
        },

        prepareInstanceModel: function (template) {
            var scopeName = template.polymerExpressionScopeIdent_;
            if (!scopeName)
                return;

            var parentScope = template.templateInstance ?
                template.templateInstance.model :
                template.model;

            var indexName = template.polymerExpressionIndexIdent_;

            return function (model) {
                return createScopeObject(parentScope, model, scopeName, indexName);
            };
        }
    };

    var createScopeObject = ('__proto__' in {}) ?
      function (parentScope, model, scopeName, indexName) {
          var scope = {};
          scope[scopeName] = model;
          scope[indexName] = undefined;
          scope[parentScopeName] = parentScope;
          scope.__proto__ = parentScope;
          return scope;
      } :
      function (parentScope, model, scopeName, indexName) {
          var scope = Object.create(parentScope);
          Object.defineProperty(scope, scopeName,
              { value: model, configurable: true, writable: true });
          Object.defineProperty(scope, indexName,
              { value: undefined, configurable: true, writable: true });
          Object.defineProperty(scope, parentScopeName,
              { value: parentScope, configurable: true, writable: true });
          return scope;
      };

    global.PolymerExpressions = PolymerExpressions;
    PolymerExpressions.getExpression = getExpression;
})(module.exports);

/***/ }),

/***/ "../node_modules/tns-core-modules/matrix/matrix.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var number_utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/number-utils.js");
exports.getTransformMatrix = function (_a) {
    var property = _a.property, value = _a.value;
    return TRANSFORM_MATRIXES[property](value);
};
var TRANSFORM_MATRIXES = {
    "scale": function (_a) {
        var x = _a.x, y = _a.y;
        return [
            x, 0, 0,
            0, y, 0,
            0, 0, 1,
        ];
    },
    "translate": function (_a) {
        var x = _a.x, y = _a.y;
        return [
            1, 0, x,
            0, 1, y,
            0, 0, 1,
        ];
    },
    "rotate": function (angleInDeg) {
        var angleInRad = number_utils_1.degreesToRadians(angleInDeg);
        return [
            Math.cos(angleInRad), -Math.sin(angleInRad), 0,
            Math.sin(angleInRad), Math.cos(angleInRad), 0,
            0, 0, 1,
        ];
    },
};
exports.matrixArrayToCssMatrix = function (m) { return [
    m[0], m[3], m[1],
    m[4], m[2], m[5],
]; };
function multiplyAffine2d(m1, m2) {
    return [
        m1[0] * m2[0] + m1[1] * m2[3],
        m1[0] * m2[1] + m1[1] * m2[4],
        m1[0] * m2[2] + m1[1] * m2[5] + m1[2],
        m1[3] * m2[0] + m1[4] * m2[3],
        m1[3] * m2[1] + m1[4] * m2[4],
        m1[3] * m2[2] + m1[4] * m2[5] + m1[5]
    ];
}
exports.multiplyAffine2d = multiplyAffine2d;
function decompose2DTransformMatrix(matrix) {
    verifyTransformMatrix(matrix);
    var _a = matrix.slice(), A = _a[0], B = _a[1], C = _a[2], D = _a[3], E = _a[4], F = _a[5];
    var determinant = A * D - B * C;
    var translate = { x: E || 0, y: F || 0 };
    var rotate = 0;
    var scale = { x: 1, y: 1 };
    if (A || B) {
        var R = Math.sqrt(A * A + B * B);
        rotate = B > 0 ? Math.acos(A / R) : -Math.acos(A / R);
        scale = { x: R, y: determinant / R };
    }
    else if (C || D) {
        var R = Math.sqrt(C * C + D * D);
        rotate = Math.PI / 2 - (D > 0 ? Math.acos(-C / R) : -Math.acos(C / R));
        scale = { x: determinant / R, y: R };
    }
    rotate = number_utils_1.radiansToDegrees(rotate);
    return { translate: translate, rotate: rotate, scale: scale };
}
exports.decompose2DTransformMatrix = decompose2DTransformMatrix;
function verifyTransformMatrix(matrix) {
    if (matrix.length < 6) {
        throw new Error("Transform matrix should be 2x3.");
    }
}
//# sourceMappingURL=matrix.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/platform/platform.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var platformNames;
(function (platformNames) {
    platformNames.android = "Android";
    platformNames.ios = "iOS";
})(platformNames = exports.platformNames || (exports.platformNames = {}));
var Device = (function () {
    function Device() {
    }
    Object.defineProperty(Device.prototype, "manufacturer", {
        get: function () {
            return "Apple";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "os", {
        get: function () {
            return platformNames.ios;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "osVersion", {
        get: function () {
            if (!this._osVersion) {
                this._osVersion = UIDevice.currentDevice.systemVersion;
            }
            return this._osVersion;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "model", {
        get: function () {
            if (!this._model) {
                this._model = UIDevice.currentDevice.model;
            }
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "sdkVersion", {
        get: function () {
            if (!this._sdkVersion) {
                this._sdkVersion = UIDevice.currentDevice.systemVersion;
            }
            return this._sdkVersion;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "deviceType", {
        get: function () {
            if (!this._deviceType) {
                if (UIDevice.currentDevice.userInterfaceIdiom === 0) {
                    this._deviceType = "Phone";
                }
                else {
                    this._deviceType = "Tablet";
                }
            }
            return this._deviceType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "uuid", {
        get: function () {
            var userDefaults = NSUserDefaults.standardUserDefaults;
            var uuid_key = "TNSUUID";
            var app_uuid = userDefaults.stringForKey(uuid_key);
            if (!app_uuid) {
                app_uuid = NSUUID.UUID().UUIDString;
                userDefaults.setObjectForKey(app_uuid, uuid_key);
                userDefaults.synchronize();
            }
            return app_uuid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "language", {
        get: function () {
            if (!this._language) {
                var languages = NSLocale.preferredLanguages;
                this._language = languages[0];
            }
            return this._language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "region", {
        get: function () {
            if (!this._region) {
                this._region = NSLocale.currentLocale.objectForKey(NSLocaleCountryCode);
            }
            return this._region;
        },
        enumerable: true,
        configurable: true
    });
    return Device;
}());
var MainScreen = (function () {
    function MainScreen() {
    }
    Object.defineProperty(MainScreen.prototype, "screen", {
        get: function () {
            if (!this._screen) {
                this._screen = UIScreen.mainScreen;
            }
            return this._screen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MainScreen.prototype, "widthPixels", {
        get: function () {
            return this.widthDIPs * this.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MainScreen.prototype, "heightPixels", {
        get: function () {
            return this.heightDIPs * this.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MainScreen.prototype, "scale", {
        get: function () {
            return this.screen.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MainScreen.prototype, "widthDIPs", {
        get: function () {
            return this.screen.bounds.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MainScreen.prototype, "heightDIPs", {
        get: function () {
            return this.screen.bounds.size.height;
        },
        enumerable: true,
        configurable: true
    });
    return MainScreen;
}());
exports.device = new Device();
var screen;
(function (screen) {
    screen.mainScreen = new MainScreen();
})(screen = exports.screen || (exports.screen = {}));
exports.isIOS = true;
//# sourceMappingURL=platform.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/profiling/profiling.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
function uptime() {
    return global.android ? org.nativescript.Process.getUpTime() : global.__tns_uptime();
}
exports.uptime = uptime;
function log(message) {
    if (global.__nslog) {
        global.__nslog("CONSOLE LOG: " + message);
    }
    console.log(message);
}
exports.log = log;
var timers = {};
var anyGlobal = global;
var profileNames = [];
exports.time = global.__time || Date.now;
function start(name) {
    var info = timers[name];
    if (info) {
        info.currentStart = exports.time();
        info.runCount++;
    }
    else {
        info = {
            totalTime: 0,
            count: 0,
            currentStart: exports.time(),
            runCount: 1
        };
        timers[name] = info;
        profileNames.push(name);
    }
}
exports.start = start;
function stop(name) {
    var info = timers[name];
    if (!info) {
        throw new Error("No timer started: " + name);
    }
    if (info.runCount) {
        info.runCount--;
        if (info.runCount) {
            info.count++;
        }
        else {
            info.lastTime = exports.time() - info.currentStart;
            info.totalTime += info.lastTime;
            info.count++;
            info.currentStart = 0;
        }
    }
    else {
        throw new Error("Timer " + name + " paused more times than started.");
    }
    return info;
}
exports.stop = stop;
function timer(name) {
    return timers[name];
}
exports.timer = timer;
function print(name) {
    var info = timers[name];
    if (!info) {
        throw new Error("No timer started: " + name);
    }
    console.log("---- [" + name + "] STOP total: " + info.totalTime + " count:" + info.count);
    return info;
}
exports.print = print;
function isRunning(name) {
    var info = timers[name];
    return !!(info && info.runCount);
}
exports.isRunning = isRunning;
function countersProfileFunctionFactory(fn, name, type) {
    if (type === void 0) { type = 1; }
    profileNames.push(name);
    return function () {
        start(name);
        try {
            return fn.apply(this, arguments);
        }
        finally {
            stop(name);
        }
    };
}
function timelineProfileFunctionFactory(fn, name, type) {
    if (type === void 0) { type = 1; }
    return type === 1 ? function () {
        var start = exports.time();
        try {
            return fn.apply(this, arguments);
        }
        finally {
            var end = exports.time();
            console.log("Timeline: Modules: " + name + " " + this + "  (" + start + "ms. - " + end + "ms.)");
        }
    } : function () {
        var start = exports.time();
        try {
            return fn.apply(this, arguments);
        }
        finally {
            var end = exports.time();
            console.log("Timeline: Modules: " + name + "  (" + start + "ms. - " + end + "ms.)");
        }
    };
}
var Level;
(function (Level) {
    Level[Level["none"] = 0] = "none";
    Level[Level["lifecycle"] = 1] = "lifecycle";
    Level[Level["timeline"] = 2] = "timeline";
})(Level = exports.Level || (exports.Level = {}));
var tracingLevel = Level.none;
var profileFunctionFactory;
function enable(mode) {
    if (mode === void 0) { mode = "counters"; }
    profileFunctionFactory = mode && {
        counters: countersProfileFunctionFactory,
        timeline: timelineProfileFunctionFactory
    }[mode];
    tracingLevel = {
        lifecycle: Level.lifecycle,
        timeline: Level.timeline,
    }[mode] || Level.none;
}
exports.enable = enable;
try {
    var appConfig = __webpack_require__("./package.json");
    if (appConfig && appConfig.profiling) {
        enable(appConfig.profiling);
    }
}
catch (e1) {
    try {
        console.log("Profiling startup failed to figure out defaults from package.json, error: " + e1);
    }
    catch (e2) {
    }
}
function disable() {
    profileFunctionFactory = undefined;
}
exports.disable = disable;
function profileFunction(fn, customName) {
    return profileFunctionFactory(fn, customName || fn.name);
}
var profileMethodUnnamed = function (target, key, descriptor) {
    if (descriptor === undefined) {
        descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    var originalMethod = descriptor.value;
    var className = "";
    if (target && target.constructor && target.constructor.name) {
        className = target.constructor.name + ".";
    }
    var name = className + key;
    descriptor.value = profileFunctionFactory(originalMethod, name, 1);
    return descriptor;
};
var profileStaticMethodUnnamed = function (ctor, key, descriptor) {
    if (descriptor === undefined) {
        descriptor = Object.getOwnPropertyDescriptor(ctor, key);
    }
    var originalMethod = descriptor.value;
    var className = "";
    if (ctor && ctor.name) {
        className = ctor.name + ".";
    }
    var name = className + key;
    descriptor.value = profileFunctionFactory(originalMethod, name, 0);
    return descriptor;
};
function profileMethodNamed(name) {
    return function (target, key, descriptor) {
        if (descriptor === undefined) {
            descriptor = Object.getOwnPropertyDescriptor(target, key);
        }
        var originalMethod = descriptor.value;
        descriptor.value = profileFunctionFactory(originalMethod, name);
        return descriptor;
    };
}
var voidMethodDecorator = function () {
};
function profile(nameFnOrTarget, fnOrKey, descriptor) {
    if (typeof nameFnOrTarget === "object" && (typeof fnOrKey === "string" || typeof fnOrKey === "symbol")) {
        if (!profileFunctionFactory) {
            return;
        }
        return profileMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
    }
    else if (typeof nameFnOrTarget === "function" && (typeof fnOrKey === "string" || typeof fnOrKey === "symbol")) {
        if (!profileFunctionFactory) {
            return;
        }
        return profileStaticMethodUnnamed(nameFnOrTarget, fnOrKey, descriptor);
    }
    else if (typeof nameFnOrTarget === "string" && typeof fnOrKey === "function") {
        if (!profileFunctionFactory) {
            return fnOrKey;
        }
        return profileFunction(fnOrKey, nameFnOrTarget);
    }
    else if (typeof nameFnOrTarget === "function") {
        if (!profileFunctionFactory) {
            return nameFnOrTarget;
        }
        return profileFunction(nameFnOrTarget);
    }
    else if (typeof nameFnOrTarget === "string") {
        if (!profileFunctionFactory) {
            return voidMethodDecorator;
        }
        return profileMethodNamed(nameFnOrTarget);
    }
    else {
        if (!profileFunctionFactory) {
            return voidMethodDecorator;
        }
        return profileMethodUnnamed;
    }
}
exports.profile = profile;
function dumpProfiles() {
    profileNames.forEach(function (name) {
        var info = timers[name];
        if (info) {
            console.log("---- [" + name + "] STOP total: " + info.totalTime + " count:" + info.count);
        }
        else {
            console.log("---- [" + name + "] Never called");
        }
    });
}
exports.dumpProfiles = dumpProfiles;
function resetProfiles() {
    profileNames.forEach(function (name) {
        var info = timers[name];
        if (info) {
            if (info.runCount) {
                console.log("---- timer with name [" + name + "] is currently running and won't be reset");
            }
            else {
                timers[name] = undefined;
            }
        }
    });
}
exports.resetProfiles = resetProfiles;
function startCPUProfile(name) {
    if (anyGlobal.android) {
        __startCPUProfiler(name);
    }
}
exports.startCPUProfile = startCPUProfile;
function stopCPUProfile(name) {
    if (anyGlobal.android) {
        __stopCPUProfiler(name);
    }
}
exports.stopCPUProfile = stopCPUProfile;
function level() {
    return tracingLevel;
}
exports.level = level;
function trace(message, start, end) {
    log("Timeline: Modules: " + message + "  (" + start + "ms. - " + end + "ms.)");
}
exports.trace = trace;
//# sourceMappingURL=profiling.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/text/formatted-string.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var span_1 = __webpack_require__("../node_modules/tns-core-modules/text/span.js");
exports.Span = span_1.Span;
var observable_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
var observable_array_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable-array/observable-array.js");
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var knownCollections;
(function (knownCollections) {
    knownCollections.spans = "spans";
})(knownCollections = exports.knownCollections || (exports.knownCollections = {}));
var CHILD_SPAN = "Span";
var FormattedString = (function (_super) {
    __extends(FormattedString, _super);
    function FormattedString() {
        var _this = _super.call(this) || this;
        _this._spans = new observable_array_1.ObservableArray();
        _this._spans.addEventListener(observable_array_1.ObservableArray.changeEvent, _this.onSpansCollectionChanged, _this);
        return _this;
    }
    Object.defineProperty(FormattedString.prototype, "fontFamily", {
        get: function () {
            return this.style.fontFamily;
        },
        set: function (value) {
            this.style.fontFamily = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "fontSize", {
        get: function () {
            return this.style.fontSize;
        },
        set: function (value) {
            this.style.fontSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "fontStyle", {
        get: function () {
            return this.style.fontStyle;
        },
        set: function (value) {
            this.style.fontStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "fontWeight", {
        get: function () {
            return this.style.fontWeight;
        },
        set: function (value) {
            this.style.fontWeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "textDecoration", {
        get: function () {
            return this.style.textDecoration;
        },
        set: function (value) {
            this.style.textDecoration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "color", {
        get: function () {
            return this.style.color;
        },
        set: function (value) {
            this.style.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "backgroundColor", {
        get: function () {
            return this.style.backgroundColor;
        },
        set: function (value) {
            this.style.backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormattedString.prototype, "spans", {
        get: function () {
            if (!this._spans) {
                this._spans = new observable_array_1.ObservableArray();
            }
            return this._spans;
        },
        enumerable: true,
        configurable: true
    });
    FormattedString.prototype.toString = function () {
        var result = "";
        for (var i = 0, length_1 = this._spans.length; i < length_1; i++) {
            result += this._spans.getItem(i).text;
        }
        return result;
    };
    FormattedString.prototype._addArrayFromBuilder = function (name, value) {
        if (name === knownCollections.spans) {
            this.spans.push(value);
        }
    };
    FormattedString.prototype._addChildFromBuilder = function (name, value) {
        if (name === CHILD_SPAN) {
            this.spans.push(value);
        }
    };
    FormattedString.prototype.onSpansCollectionChanged = function (eventData) {
        if (eventData.addedCount > 0) {
            for (var i = 0; i < eventData.addedCount; i++) {
                var span = eventData.object.getItem(eventData.index + i);
                this._addView(span);
                this.addPropertyChangeHandler(span);
            }
        }
        if (eventData.removed && eventData.removed.length > 0) {
            for (var p = 0; p < eventData.removed.length; p++) {
                var span = eventData.removed[p];
                this.removePropertyChangeHandler(span);
                this._removeView(span);
            }
        }
        this.notifyPropertyChange(".", this);
    };
    FormattedString.prototype.addPropertyChangeHandler = function (span) {
        var style = span.style;
        span.on(observable_1.Observable.propertyChangeEvent, this.onPropertyChange, this);
        style.on("fontFamilyChange", this.onPropertyChange, this);
        style.on("fontSizeChange", this.onPropertyChange, this);
        style.on("fontStyleChange", this.onPropertyChange, this);
        style.on("fontWeightChange", this.onPropertyChange, this);
        style.on("textDecorationChange", this.onPropertyChange, this);
        style.on("colorChange", this.onPropertyChange, this);
        style.on("backgroundColorChange", this.onPropertyChange, this);
    };
    FormattedString.prototype.removePropertyChangeHandler = function (span) {
        var style = span.style;
        span.off(observable_1.Observable.propertyChangeEvent, this.onPropertyChange, this);
        style.off("fontFamilyChange", this.onPropertyChange, this);
        style.off("fontSizeChange", this.onPropertyChange, this);
        style.off("fontStyleChange", this.onPropertyChange, this);
        style.off("fontWeightChange", this.onPropertyChange, this);
        style.off("textDecorationChange", this.onPropertyChange, this);
        style.off("colorChange", this.onPropertyChange, this);
        style.off("backgroundColorChange", this.onPropertyChange, this);
    };
    FormattedString.prototype.onPropertyChange = function (data) {
        this.notifyPropertyChange(data.propertyName, this);
    };
    FormattedString.prototype.eachChild = function (callback) {
        this.spans.forEach(function (v, i, arr) { return callback(v); });
    };
    return FormattedString;
}(view_1.ViewBase));
exports.FormattedString = FormattedString;
//# sourceMappingURL=formatted-string.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/text/span.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var Span = (function (_super) {
    __extends(Span, _super);
    function Span() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Span.prototype, "fontFamily", {
        get: function () {
            return this.style.fontFamily;
        },
        set: function (value) {
            this.style.fontFamily = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "fontSize", {
        get: function () {
            return this.style.fontSize;
        },
        set: function (value) {
            this.style.fontSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "fontStyle", {
        get: function () {
            return this.style.fontStyle;
        },
        set: function (value) {
            this.style.fontStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "fontWeight", {
        get: function () {
            return this.style.fontWeight;
        },
        set: function (value) {
            this.style.fontWeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "textDecoration", {
        get: function () {
            return this.style.textDecoration;
        },
        set: function (value) {
            this.style.textDecoration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "color", {
        get: function () {
            return this.style.color;
        },
        set: function (value) {
            this.style.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "backgroundColor", {
        get: function () {
            return this.style.backgroundColor;
        },
        set: function (value) {
            this.style.backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (value) {
            if (this._text !== value) {
                this._text = value;
                this.notifyPropertyChange("text", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Span.prototype._setTextInternal = function (value) {
        this._text = value;
    };
    return Span;
}(view_1.ViewBase));
exports.Span = Span;
//# sourceMappingURL=span.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/text/text.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var encoding;
(function (encoding) {
    encoding.ISO_8859_1 = 5;
    encoding.US_ASCII = 1;
    encoding.UTF_16 = 10;
    encoding.UTF_16BE = 0x90000100;
    encoding.UTF_16LE = 0x94000100;
    encoding.UTF_8 = 4;
})(encoding = exports.encoding || (exports.encoding = {}));
//# sourceMappingURL=text.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/timer/timer.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var timeoutCallbacks = new Map();
var timerId = 0;
var TimerTargetImpl = (function (_super) {
    __extends(TimerTargetImpl, _super);
    function TimerTargetImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimerTargetImpl.initWithCallback = function (callback, id, shouldRepeat) {
        var handler = TimerTargetImpl.new();
        handler.callback = callback;
        handler.id = id;
        handler.shouldRepeat = shouldRepeat;
        return handler;
    };
    TimerTargetImpl.prototype.tick = function (timer) {
        if (!this.disposed) {
            this.callback();
        }
        if (!this.shouldRepeat) {
            this.unregister();
        }
    };
    TimerTargetImpl.prototype.unregister = function () {
        if (!this.disposed) {
            this.disposed = true;
            var timer = timeoutCallbacks.get(this.id).k;
            timer.invalidate();
            timeoutCallbacks.delete(this.id);
        }
    };
    TimerTargetImpl.ObjCExposedMethods = {
        "tick": { returns: interop.types.void, params: [NSTimer] }
    };
    return TimerTargetImpl;
}(NSObject));
function createTimerAndGetId(callback, milliseconds, shouldRepeat) {
    timerId++;
    var id = timerId;
    var timerTarget = TimerTargetImpl.initWithCallback(callback, id, shouldRepeat);
    var timer = NSTimer.scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(milliseconds / 1000, timerTarget, "tick", null, shouldRepeat);
    NSRunLoop.currentRunLoop.addTimerForMode(timer, NSRunLoopCommonModes);
    var pair = { k: timer, v: timerTarget };
    timeoutCallbacks.set(id, pair);
    return id;
}
function setTimeout(callback, milliseconds) {
    if (milliseconds === void 0) { milliseconds = 0; }
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var invoke = function () { return callback.apply(void 0, args); };
    return createTimerAndGetId(zonedCallback(invoke), milliseconds, false);
}
exports.setTimeout = setTimeout;
function clearTimeout(id) {
    var pair = timeoutCallbacks.get(id);
    if (pair) {
        pair.v.unregister();
    }
}
exports.clearTimeout = clearTimeout;
function setInterval(callback, milliseconds) {
    if (milliseconds === void 0) { milliseconds = 0; }
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var invoke = function () { return callback.apply(void 0, args); };
    return createTimerAndGetId(zonedCallback(invoke), milliseconds, true);
}
exports.setInterval = setInterval;
exports.clearInterval = clearTimeout;
//# sourceMappingURL=timer.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/trace/trace.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var enabled = false;
var _categories = {};
var _writers = [];
var _eventListeners = [];
var _errorHandler;
function enable() {
    enabled = true;
}
exports.enable = enable;
function disable() {
    enabled = false;
}
exports.disable = disable;
function isEnabled() {
    return enabled;
}
exports.isEnabled = isEnabled;
function isCategorySet(category) {
    return category in _categories;
}
exports.isCategorySet = isCategorySet;
function addWriter(writer) {
    _writers.push(writer);
}
exports.addWriter = addWriter;
function removeWriter(writer) {
    var index = _writers.indexOf(writer);
    if (index >= 0) {
        _writers.splice(index, 1);
    }
}
exports.removeWriter = removeWriter;
function clearWriters() {
    if (_writers.length > 0) {
        _writers.splice(0, _writers.length);
    }
}
exports.clearWriters = clearWriters;
function setCategories(categories) {
    _categories = {};
    addCategories(categories);
}
exports.setCategories = setCategories;
function addCategories(categories) {
    var split = categories.split(",");
    for (var i = 0; i < split.length; i++) {
        _categories[split[i].trim()] = true;
    }
}
exports.addCategories = addCategories;
function write(message, category, type) {
    var i;
    if (type === messageType.error) {
        for (i = 0; i < _writers.length; i++) {
            _writers[i].write(message, category, type);
        }
        return;
    }
    if (!enabled) {
        return;
    }
    if (!(category in _categories)) {
        return;
    }
    for (i = 0; i < _writers.length; i++) {
        _writers[i].write(message, category, type);
    }
}
exports.write = write;
function notifyEvent(object, name, data) {
    if (!enabled) {
        return;
    }
    var i, listener, filters;
    for (i = 0; i < _eventListeners.length; i++) {
        listener = _eventListeners[i];
        if (listener.filter) {
            filters = listener.filter.split(",");
            filters.forEach(function (value) {
                if (value.trim() === name) {
                    listener.on(object, name, data);
                }
            });
        }
        else {
            listener.on(object, name, data);
        }
    }
}
exports.notifyEvent = notifyEvent;
function addEventListener(listener) {
    _eventListeners.push(listener);
}
exports.addEventListener = addEventListener;
function removeEventListener(listener) {
    var index = _eventListeners.indexOf(listener);
    if (index >= 0) {
        _eventListeners.splice(index, 1);
    }
}
exports.removeEventListener = removeEventListener;
var messageType;
(function (messageType) {
    messageType.log = 0;
    messageType.info = 1;
    messageType.warn = 2;
    messageType.error = 3;
})(messageType = exports.messageType || (exports.messageType = {}));
var categories;
(function (categories) {
    categories.VisualTreeEvents = "VisualTreeEvents";
    categories.Layout = "Layout";
    categories.Style = "Style";
    categories.ViewHierarchy = "ViewHierarchy";
    categories.NativeLifecycle = "NativeLifecycle";
    categories.Debug = "Debug";
    categories.Navigation = "Navigation";
    categories.Test = "Test";
    categories.Binding = "Binding";
    categories.BindingError = "BindingError";
    categories.Error = "Error";
    categories.Animation = "Animation";
    categories.Transition = "Transition";
    categories.Livesync = "Livesync";
    categories.separator = ",";
    categories.All = categories.VisualTreeEvents + categories.separator
        + categories.Layout + categories.separator
        + categories.Style + categories.separator
        + categories.ViewHierarchy + categories.separator
        + categories.NativeLifecycle + categories.separator
        + categories.Debug + categories.separator
        + categories.Navigation + categories.separator
        + categories.Test + categories.separator
        + categories.Binding + categories.separator
        + categories.Error + categories.separator
        + categories.Animation + categories.separator
        + categories.Transition + categories.separator
        + categories.Livesync;
    function concat() {
        var result;
        for (var i = 0; i < arguments.length; i++) {
            if (!result) {
                result = arguments[i];
                continue;
            }
            result = result.concat(categories.separator, arguments[i]);
        }
        return result;
    }
    categories.concat = concat;
})(categories = exports.categories || (exports.categories = {}));
var ConsoleWriter = (function () {
    function ConsoleWriter() {
    }
    ConsoleWriter.prototype.write = function (message, category, type) {
        if (!console) {
            return;
        }
        var msgType;
        if (type === undefined) {
            msgType = messageType.log;
        }
        else {
            msgType = type;
        }
        switch (msgType) {
            case messageType.log:
                console.log(category + ": " + message);
                break;
            case messageType.info:
                console.info(category + ": " + message);
                break;
            case messageType.warn:
                console.warn(category + ": " + message);
                break;
            case messageType.error:
                console.error(category + ": " + message);
                break;
        }
    };
    return ConsoleWriter;
}());
addWriter(new ConsoleWriter());
var DefaultErrorHandler = (function () {
    function DefaultErrorHandler() {
    }
    DefaultErrorHandler.prototype.handlerError = function (error) {
        throw error;
    };
    return DefaultErrorHandler;
}());
exports.DefaultErrorHandler = DefaultErrorHandler;
setErrorHandler(new DefaultErrorHandler());
function getErrorHandler() {
    return _errorHandler;
}
exports.getErrorHandler = getErrorHandler;
function setErrorHandler(handler) {
    _errorHandler = handler;
}
exports.setErrorHandler = setErrorHandler;
function error(error) {
    if (!_errorHandler) {
        return;
    }
    if (typeof error === "string") {
        error = new Error(error);
    }
    _errorHandler.handlerError(error);
}
exports.error = error;
//# sourceMappingURL=trace.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/animation/animation-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
exports.Color = color_1.Color;
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
exports.traceEnabled = trace_1.isEnabled;
exports.traceWrite = trace_1.write;
exports.traceCategories = trace_1.categories;
exports.traceType = trace_1.messageType;
var Properties;
(function (Properties) {
    Properties.opacity = "opacity";
    Properties.backgroundColor = "backgroundColor";
    Properties.translate = "translate";
    Properties.rotate = "rotate";
    Properties.scale = "scale";
})(Properties = exports.Properties || (exports.Properties = {}));
var CubicBezierAnimationCurve = (function () {
    function CubicBezierAnimationCurve(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    return CubicBezierAnimationCurve;
}());
exports.CubicBezierAnimationCurve = CubicBezierAnimationCurve;
var AnimationBase = (function () {
    function AnimationBase(animationDefinitions, playSequentially) {
        if (!animationDefinitions || animationDefinitions.length === 0) {
            throw new Error("No animation definitions specified");
        }
        if (trace_1.isEnabled()) {
            trace_1.write("Analyzing " + animationDefinitions.length + " animation definitions...", trace_1.categories.Animation);
        }
        this._propertyAnimations = new Array();
        for (var i = 0, length_1 = animationDefinitions.length; i < length_1; i++) {
            if (animationDefinitions[i].curve) {
                animationDefinitions[i].curve = this._resolveAnimationCurve(animationDefinitions[i].curve);
            }
            this._propertyAnimations = this._propertyAnimations.concat(AnimationBase._createPropertyAnimations(animationDefinitions[i]));
        }
        if (this._propertyAnimations.length === 0) {
            throw new Error("Nothing to animate.");
        }
        if (trace_1.isEnabled()) {
            trace_1.write("Created " + this._propertyAnimations.length + " individual property animations.", trace_1.categories.Animation);
        }
        this._playSequentially = playSequentially;
    }
    AnimationBase.prototype._rejectAlreadyPlaying = function () {
        var reason = "Animation is already playing.";
        trace_1.write(reason, trace_1.categories.Animation, trace_1.messageType.warn);
        return new Promise(function (resolve, reject) {
            reject(reason);
        });
    };
    AnimationBase.prototype.play = function () {
        var _this_1 = this;
        var animationFinishedPromise = new Promise(function (resolve, reject) {
            _this_1._resolve = resolve;
            _this_1._reject = reject;
        });
        this.fixupAnimationPromise(animationFinishedPromise);
        this._isPlaying = true;
        return animationFinishedPromise;
    };
    AnimationBase.prototype.fixupAnimationPromise = function (promise) {
        var _this = this;
        promise.cancel = function () {
            _this.cancel();
        };
        var _then = promise.then;
        promise.then = function () {
            var r = _then.apply(promise, arguments);
            _this.fixupAnimationPromise(r);
            return r;
        };
        var _catch = promise.catch;
        promise.catch = function () {
            var r = _catch.apply(promise, arguments);
            _this.fixupAnimationPromise(r);
            return r;
        };
    };
    AnimationBase.prototype.cancel = function () {
    };
    Object.defineProperty(AnimationBase.prototype, "isPlaying", {
        get: function () {
            return this._isPlaying;
        },
        enumerable: true,
        configurable: true
    });
    AnimationBase.prototype._resolveAnimationFinishedPromise = function () {
        this._isPlaying = false;
        this._resolve();
    };
    AnimationBase.prototype._rejectAnimationFinishedPromise = function () {
        this._isPlaying = false;
        this._reject(new Error("Animation cancelled."));
    };
    AnimationBase._createPropertyAnimations = function (animationDefinition) {
        if (!animationDefinition.target) {
            throw new Error("No animation target specified.");
        }
        for (var item in animationDefinition) {
            if (animationDefinition[item] === undefined) {
                continue;
            }
            if ((item === Properties.opacity ||
                item === Properties.rotate ||
                item === "duration" ||
                item === "delay" ||
                item === "iterations") && typeof animationDefinition[item] !== "number") {
                throw new Error("Property " + item + " must be valid number. Value: " + animationDefinition[item]);
            }
            else if ((item === Properties.scale || item === Properties.translate) &&
                (typeof animationDefinition[item].x !== "number" || typeof animationDefinition[item].y !== "number")) {
                throw new Error("Property " + item + " must be valid Pair. Value: " + animationDefinition[item]);
            }
            else if (item === Properties.backgroundColor && !color_1.Color.isValid(animationDefinition.backgroundColor)) {
                throw new Error("Property " + item + " must be valid color. Value: " + animationDefinition[item]);
            }
        }
        var propertyAnimations = new Array();
        if (animationDefinition.opacity !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.opacity,
                value: animationDefinition.opacity,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve
            });
        }
        if (animationDefinition.backgroundColor !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.backgroundColor,
                value: typeof animationDefinition.backgroundColor === "string" ?
                    new color_1.Color(animationDefinition.backgroundColor) : animationDefinition.backgroundColor,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve
            });
        }
        if (animationDefinition.translate !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.translate,
                value: animationDefinition.translate,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve
            });
        }
        if (animationDefinition.scale !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.scale,
                value: animationDefinition.scale,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve
            });
        }
        if (animationDefinition.rotate !== undefined) {
            propertyAnimations.push({
                target: animationDefinition.target,
                property: Properties.rotate,
                value: animationDefinition.rotate,
                duration: animationDefinition.duration,
                delay: animationDefinition.delay,
                iterations: animationDefinition.iterations,
                curve: animationDefinition.curve
            });
        }
        if (propertyAnimations.length === 0) {
            throw new Error("No animation property specified.");
        }
        return propertyAnimations;
    };
    AnimationBase._getAnimationInfo = function (animation) {
        return JSON.stringify({
            target: animation.target.id,
            property: animation.property,
            value: animation.value,
            duration: animation.duration,
            delay: animation.delay,
            iterations: animation.iterations,
            curve: animation.curve
        });
    };
    return AnimationBase;
}());
exports.AnimationBase = AnimationBase;
//# sourceMappingURL=animation-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/animation/animation.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var animation_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/animation/animation-common.js");
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/animation/animation-common.js"));
var _transform = "_transform";
var _skip = "_skip";
var FLT_MAX = 340282346638528859811704183484516925440.000000;
var AnimationInfo = (function () {
    function AnimationInfo() {
    }
    return AnimationInfo;
}());
var AnimationDelegateImpl = (function (_super) {
    __extends(AnimationDelegateImpl, _super);
    function AnimationDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationDelegateImpl.initWithFinishedCallback = function (finishedCallback, propertyAnimation, valueSource) {
        var delegate = AnimationDelegateImpl.new();
        delegate._finishedCallback = finishedCallback;
        delegate._propertyAnimation = propertyAnimation;
        delegate._valueSource = valueSource;
        return delegate;
    };
    AnimationDelegateImpl.prototype.animationDidStart = function (anim) {
        var value = this._propertyAnimation.value;
        var setLocal = this._valueSource === "animation";
        var targetStyle = this._propertyAnimation.target.style;
        this._propertyAnimation.target._suspendPresentationLayerUpdates();
        switch (this._propertyAnimation.property) {
            case animation_common_1.Properties.backgroundColor:
                targetStyle[setLocal ? style_properties_1.backgroundColorProperty.name : style_properties_1.backgroundColorProperty.keyframe] = value;
                break;
            case animation_common_1.Properties.opacity:
                targetStyle[setLocal ? style_properties_1.opacityProperty.name : style_properties_1.opacityProperty.keyframe] = value;
                break;
            case animation_common_1.Properties.rotate:
                targetStyle[setLocal ? style_properties_1.rotateProperty.name : style_properties_1.rotateProperty.keyframe] = value;
                break;
            case animation_common_1.Properties.translate:
                targetStyle[setLocal ? style_properties_1.translateXProperty.name : style_properties_1.translateXProperty.keyframe] = value.x;
                targetStyle[setLocal ? style_properties_1.translateYProperty.name : style_properties_1.translateYProperty.keyframe] = value.y;
                break;
            case animation_common_1.Properties.scale:
                targetStyle[setLocal ? style_properties_1.scaleXProperty.name : style_properties_1.scaleXProperty.keyframe] = value.x === 0 ? 0.001 : value.x;
                targetStyle[setLocal ? style_properties_1.scaleYProperty.name : style_properties_1.scaleYProperty.keyframe] = value.y === 0 ? 0.001 : value.y;
                break;
            case _transform:
                if (value[animation_common_1.Properties.translate] !== undefined) {
                    targetStyle[setLocal ? style_properties_1.translateXProperty.name : style_properties_1.translateXProperty.keyframe] = value[animation_common_1.Properties.translate].x;
                    targetStyle[setLocal ? style_properties_1.translateYProperty.name : style_properties_1.translateYProperty.keyframe] = value[animation_common_1.Properties.translate].y;
                }
                if (value[animation_common_1.Properties.scale] !== undefined) {
                    var x = value[animation_common_1.Properties.scale].x;
                    var y = value[animation_common_1.Properties.scale].y;
                    targetStyle[setLocal ? style_properties_1.scaleXProperty.name : style_properties_1.scaleXProperty.keyframe] = x === 0 ? 0.001 : x;
                    targetStyle[setLocal ? style_properties_1.scaleYProperty.name : style_properties_1.scaleYProperty.keyframe] = y === 0 ? 0.001 : y;
                }
                break;
        }
        this._propertyAnimation.target._resumePresentationLayerUpdates();
    };
    AnimationDelegateImpl.prototype.animationDidStopFinished = function (anim, finished) {
        if (this._finishedCallback) {
            this._finishedCallback(!finished);
        }
        if (finished && this.nextAnimation) {
            this.nextAnimation();
        }
    };
    AnimationDelegateImpl.ObjCProtocols = global.CAAnimationDelegate ? [global.CAAnimationDelegate] : [];
    return AnimationDelegateImpl;
}(NSObject));
function _resolveAnimationCurve(curve) {
    switch (curve) {
        case "easeIn":
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseIn);
        case "easeOut":
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseOut);
        case "easeInOut":
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseInEaseOut);
        case "linear":
            return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionLinear);
        case "spring":
            return curve;
        case "ease":
            return CAMediaTimingFunction.functionWithControlPoints(0.25, 0.1, 0.25, 1.0);
        default:
            if (curve instanceof CAMediaTimingFunction) {
                return curve;
            }
            else if (curve instanceof animation_common_1.CubicBezierAnimationCurve) {
                var animationCurve = curve;
                return CAMediaTimingFunction.functionWithControlPoints(animationCurve.x1, animationCurve.y1, animationCurve.x2, animationCurve.y2);
            }
            else {
                throw new Error("Invalid animation curve: " + curve);
            }
    }
}
exports._resolveAnimationCurve = _resolveAnimationCurve;
var Animation = (function (_super) {
    __extends(Animation, _super);
    function Animation(animationDefinitions, playSequentially) {
        var _this = _super.call(this, animationDefinitions, playSequentially) || this;
        _this._valueSource = "animation";
        if (animationDefinitions.length > 0 && animationDefinitions[0].valueSource !== undefined) {
            _this._valueSource = animationDefinitions[0].valueSource;
        }
        if (!playSequentially) {
            if (animation_common_1.traceEnabled()) {
                animation_common_1.traceWrite("Non-merged Property Animations: " + _this._propertyAnimations.length, animation_common_1.traceCategories.Animation);
            }
            _this._mergedPropertyAnimations = Animation._mergeAffineTransformAnimations(_this._propertyAnimations);
            if (animation_common_1.traceEnabled()) {
                animation_common_1.traceWrite("Merged Property Animations: " + _this._mergedPropertyAnimations.length, animation_common_1.traceCategories.Animation);
            }
        }
        else {
            _this._mergedPropertyAnimations = _this._propertyAnimations;
        }
        var that = _this;
        var animationFinishedCallback = function (cancelled) {
            if (that._playSequentially) {
                if (cancelled) {
                    that._rejectAnimationFinishedPromise();
                }
                else {
                    that._resolveAnimationFinishedPromise();
                }
            }
            else {
                if (cancelled) {
                    that._cancelledAnimations++;
                }
                else {
                    that._finishedAnimations++;
                }
                if (that._cancelledAnimations > 0 && (that._cancelledAnimations + that._finishedAnimations) === that._mergedPropertyAnimations.length) {
                    if (animation_common_1.traceEnabled()) {
                        animation_common_1.traceWrite(that._cancelledAnimations + " animations cancelled.", animation_common_1.traceCategories.Animation);
                    }
                    that._rejectAnimationFinishedPromise();
                }
                else if (that._finishedAnimations === that._mergedPropertyAnimations.length) {
                    if (animation_common_1.traceEnabled()) {
                        animation_common_1.traceWrite(that._finishedAnimations + " animations finished.", animation_common_1.traceCategories.Animation);
                    }
                    that._resolveAnimationFinishedPromise();
                }
            }
        };
        _this._iOSAnimationFunction = Animation._createiOSAnimationFunction(_this._mergedPropertyAnimations, 0, _this._playSequentially, _this._valueSource, animationFinishedCallback);
        return _this;
    }
    Animation.prototype.play = function () {
        if (this.isPlaying) {
            return this._rejectAlreadyPlaying();
        }
        var animationFinishedPromise = _super.prototype.play.call(this);
        this._finishedAnimations = 0;
        this._cancelledAnimations = 0;
        this._iOSAnimationFunction();
        return animationFinishedPromise;
    };
    Animation.prototype.cancel = function () {
        if (!this.isPlaying) {
            animation_common_1.traceWrite("Animation is not currently playing.", animation_common_1.traceCategories.Animation, animation_common_1.traceType.warn);
            return;
        }
        var i = 0;
        var length = this._mergedPropertyAnimations.length;
        for (; i < length; i++) {
            var propertyAnimation = this._mergedPropertyAnimations[i];
            propertyAnimation.target.nativeViewProtected.layer.removeAllAnimations();
            if (propertyAnimation._propertyResetCallback) {
                propertyAnimation._propertyResetCallback(propertyAnimation._originalValue, this._valueSource);
            }
        }
    };
    Animation.prototype._resolveAnimationCurve = function (curve) {
        return _resolveAnimationCurve(curve);
    };
    Animation._createiOSAnimationFunction = function (propertyAnimations, index, playSequentially, valueSource, finishedCallback) {
        return function (cancelled) {
            if (cancelled && finishedCallback) {
                if (animation_common_1.traceEnabled()) {
                    animation_common_1.traceWrite("Animation " + (index - 1).toString() + " was cancelled. Will skip the rest of animations and call finishedCallback(true).", animation_common_1.traceCategories.Animation);
                }
                finishedCallback(cancelled);
                return;
            }
            var animation = propertyAnimations[index];
            var args = Animation._getNativeAnimationArguments(animation, valueSource);
            if (animation.curve === "spring") {
                Animation._createNativeSpringAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback);
            }
            else {
                Animation._createNativeAnimation(propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback);
            }
        };
    };
    Animation._getNativeAnimationArguments = function (animation, valueSource) {
        var nativeView = animation.target.nativeViewProtected;
        var propertyNameToAnimate = animation.property;
        var value = animation.value;
        var originalValue;
        var tempRotate = (animation.target.rotate || 0) * Math.PI / 180;
        var abs;
        var setLocal = valueSource === "animation";
        switch (animation.property) {
            case animation_common_1.Properties.backgroundColor:
                animation._originalValue = animation.target.backgroundColor;
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.backgroundColorProperty.name : style_properties_1.backgroundColorProperty.keyframe] = value;
                };
                originalValue = nativeView.layer.backgroundColor;
                if (nativeView instanceof UILabel) {
                    nativeView.setValueForKey(UIColor.clearColor, "backgroundColor");
                }
                value = value.CGColor;
                break;
            case animation_common_1.Properties.opacity:
                animation._originalValue = animation.target.opacity;
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.opacityProperty.name : style_properties_1.opacityProperty.keyframe] = value;
                };
                originalValue = nativeView.layer.opacity;
                break;
            case animation_common_1.Properties.rotate:
                animation._originalValue = animation.target.rotate !== undefined ? animation.target.rotate : 0;
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.rotateProperty.name : style_properties_1.rotateProperty.keyframe] = value;
                };
                propertyNameToAnimate = "transform.rotation";
                originalValue = nativeView.layer.valueForKeyPath("transform.rotation");
                if (animation.target.rotate !== undefined && animation.target.rotate !== 0 && Math.floor(value / 360) - value / 360 === 0) {
                    originalValue = animation.target.rotate * Math.PI / 180;
                }
                value = value * Math.PI / 180;
                abs = fabs(originalValue - value);
                if (abs < 0.001 && originalValue !== tempRotate) {
                    originalValue = tempRotate;
                }
                break;
            case animation_common_1.Properties.translate:
                animation._originalValue = { x: animation.target.translateX, y: animation.target.translateY };
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.translateXProperty.name : style_properties_1.translateXProperty.keyframe] = value.x;
                    animation.target.style[setLocal ? style_properties_1.translateYProperty.name : style_properties_1.translateYProperty.keyframe] = value.y;
                };
                propertyNameToAnimate = "transform";
                originalValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                value = NSValue.valueWithCATransform3D(CATransform3DTranslate(nativeView.layer.transform, value.x, value.y, 0));
                break;
            case animation_common_1.Properties.scale:
                if (value.x === 0) {
                    value.x = 0.001;
                }
                if (value.y === 0) {
                    value.y = 0.001;
                }
                animation._originalValue = { x: animation.target.scaleX, y: animation.target.scaleY };
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.scaleXProperty.name : style_properties_1.scaleXProperty.keyframe] = value.x;
                    animation.target.style[setLocal ? style_properties_1.scaleYProperty.name : style_properties_1.scaleYProperty.keyframe] = value.y;
                };
                propertyNameToAnimate = "transform";
                originalValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                value = NSValue.valueWithCATransform3D(CATransform3DScale(nativeView.layer.transform, value.x, value.y, 1));
                break;
            case _transform:
                originalValue = NSValue.valueWithCATransform3D(nativeView.layer.transform);
                animation._originalValue = {
                    xs: animation.target.scaleX, ys: animation.target.scaleY,
                    xt: animation.target.translateX, yt: animation.target.translateY
                };
                animation._propertyResetCallback = function (value, valueSource) {
                    animation.target.style[setLocal ? style_properties_1.translateXProperty.name : style_properties_1.translateXProperty.keyframe] = value.xt;
                    animation.target.style[setLocal ? style_properties_1.translateYProperty.name : style_properties_1.translateYProperty.keyframe] = value.yt;
                    animation.target.style[setLocal ? style_properties_1.scaleXProperty.name : style_properties_1.scaleXProperty.keyframe] = value.xs;
                    animation.target.style[setLocal ? style_properties_1.scaleYProperty.name : style_properties_1.scaleYProperty.keyframe] = value.ys;
                };
                propertyNameToAnimate = "transform";
                value = NSValue.valueWithCATransform3D(Animation._createNativeAffineTransform(animation));
                break;
            default:
                throw new Error("Cannot animate " + animation.property);
        }
        var duration = 0.3;
        if (animation.duration !== undefined) {
            duration = animation.duration / 1000.0;
        }
        var delay = undefined;
        if (animation.delay) {
            delay = animation.delay / 1000.0;
        }
        var repeatCount = undefined;
        if (animation.iterations !== undefined) {
            if (animation.iterations === Number.POSITIVE_INFINITY) {
                repeatCount = FLT_MAX;
            }
            else {
                repeatCount = animation.iterations;
            }
        }
        return {
            propertyNameToAnimate: propertyNameToAnimate,
            fromValue: originalValue,
            toValue: value,
            duration: duration,
            repeatCount: repeatCount,
            delay: delay
        };
    };
    Animation._createNativeAnimation = function (propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback) {
        var nativeView = animation.target.nativeViewProtected;
        var nativeAnimation = CABasicAnimation.animationWithKeyPath(args.propertyNameToAnimate);
        nativeAnimation.fromValue = args.fromValue;
        nativeAnimation.toValue = args.toValue;
        nativeAnimation.duration = args.duration;
        if (args.repeatCount !== undefined) {
            nativeAnimation.repeatCount = args.repeatCount;
        }
        if (args.delay !== undefined) {
            nativeAnimation.beginTime = CACurrentMediaTime() + args.delay;
        }
        if (animation.curve !== undefined) {
            nativeAnimation.timingFunction = animation.curve;
        }
        var animationDelegate = AnimationDelegateImpl.initWithFinishedCallback(finishedCallback, animation, valueSource);
        nativeAnimation.setValueForKey(animationDelegate, "delegate");
        nativeView.layer.addAnimationForKey(nativeAnimation, args.propertyNameToAnimate);
        var callback = undefined;
        if (index + 1 < propertyAnimations.length) {
            callback = Animation._createiOSAnimationFunction(propertyAnimations, index + 1, playSequentially, valueSource, finishedCallback);
            if (!playSequentially) {
                callback();
            }
            else {
                animationDelegate.nextAnimation = callback;
            }
        }
    };
    Animation._createNativeSpringAnimation = function (propertyAnimations, index, playSequentially, args, animation, valueSource, finishedCallback) {
        var nativeView = animation.target.nativeViewProtected;
        var callback = undefined;
        var nextAnimation;
        if (index + 1 < propertyAnimations.length) {
            callback = Animation._createiOSAnimationFunction(propertyAnimations, index + 1, playSequentially, valueSource, finishedCallback);
            if (!playSequentially) {
                callback();
            }
            else {
                nextAnimation = callback;
            }
        }
        var delay = 0;
        if (args.delay) {
            delay = args.delay;
        }
        UIView.animateWithDurationDelayUsingSpringWithDampingInitialSpringVelocityOptionsAnimationsCompletion(args.duration, delay, 0.2, 0, 196608, function () {
            if (args.repeatCount !== undefined) {
                UIView.setAnimationRepeatCount(args.repeatCount);
            }
            switch (animation.property) {
                case animation_common_1.Properties.backgroundColor:
                    animation.target.backgroundColor = args.toValue;
                    break;
                case animation_common_1.Properties.opacity:
                    animation.target.opacity = args.toValue;
                    break;
                case animation_common_1.Properties.rotate:
                    nativeView.layer.setValueForKey(args.toValue, args.propertyNameToAnimate);
                    break;
                case _transform:
                    animation._originalValue = nativeView.layer.transform;
                    nativeView.layer.setValueForKey(args.toValue, args.propertyNameToAnimate);
                    animation._propertyResetCallback = function (value) {
                        nativeView.layer.transform = value;
                    };
                    break;
            }
        }, function (finished) {
            if (finished) {
                if (animation.property === _transform) {
                    if (animation.value[animation_common_1.Properties.translate] !== undefined) {
                        animation.target.translateX = animation.value[animation_common_1.Properties.translate].x;
                        animation.target.translateY = animation.value[animation_common_1.Properties.translate].y;
                    }
                    if (animation.value[animation_common_1.Properties.scale] !== undefined) {
                        animation.target.scaleX = animation.value[animation_common_1.Properties.scale].x;
                        animation.target.scaleY = animation.value[animation_common_1.Properties.scale].y;
                    }
                }
            }
            else {
                if (animation._propertyResetCallback) {
                    animation._propertyResetCallback(animation._originalValue);
                }
            }
            if (finishedCallback) {
                var cancelled = !finished;
                finishedCallback(cancelled);
            }
            if (finished && nextAnimation) {
                nextAnimation();
            }
        });
    };
    Animation._createNativeAffineTransform = function (animation) {
        var value = animation.value;
        var result = CATransform3DIdentity;
        if (value[animation_common_1.Properties.translate] !== undefined) {
            var x = value[animation_common_1.Properties.translate].x;
            var y = value[animation_common_1.Properties.translate].y;
            result = CATransform3DTranslate(result, x, y, 0);
        }
        if (value[animation_common_1.Properties.scale] !== undefined) {
            var x = value[animation_common_1.Properties.scale].x;
            var y = value[animation_common_1.Properties.scale].y;
            result = CATransform3DScale(result, x === 0 ? 0.001 : x, y === 0 ? 0.001 : y, 1);
        }
        return result;
    };
    Animation._isAffineTransform = function (property) {
        return property === _transform
            || property === animation_common_1.Properties.translate
            || property === animation_common_1.Properties.scale;
    };
    Animation._canBeMerged = function (animation1, animation2) {
        var result = Animation._isAffineTransform(animation1.property) &&
            Animation._isAffineTransform(animation2.property) &&
            animation1.target === animation2.target &&
            animation1.duration === animation2.duration &&
            animation1.delay === animation2.delay &&
            animation1.iterations === animation2.iterations &&
            animation1.curve === animation2.curve;
        return result;
    };
    Animation._mergeAffineTransformAnimations = function (propertyAnimations) {
        var result = new Array();
        var i = 0;
        var j;
        var length = propertyAnimations.length;
        for (; i < length; i++) {
            if (propertyAnimations[i][_skip]) {
                continue;
            }
            if (!Animation._isAffineTransform(propertyAnimations[i].property)) {
                result.push(propertyAnimations[i]);
            }
            else {
                var newTransformAnimation = {
                    target: propertyAnimations[i].target,
                    property: _transform,
                    value: {},
                    duration: propertyAnimations[i].duration,
                    delay: propertyAnimations[i].delay,
                    iterations: propertyAnimations[i].iterations,
                    curve: propertyAnimations[i].curve
                };
                if (animation_common_1.traceEnabled()) {
                    animation_common_1.traceWrite("Curve: " + propertyAnimations[i].curve, animation_common_1.traceCategories.Animation);
                }
                newTransformAnimation.value[propertyAnimations[i].property] = propertyAnimations[i].value;
                if (animation_common_1.traceEnabled()) {
                    animation_common_1.traceWrite("Created new transform animation: " + Animation._getAnimationInfo(newTransformAnimation), animation_common_1.traceCategories.Animation);
                }
                j = i + 1;
                if (j < length) {
                    for (; j < length; j++) {
                        if (Animation._canBeMerged(propertyAnimations[i], propertyAnimations[j])) {
                            if (animation_common_1.traceEnabled()) {
                                animation_common_1.traceWrite("Merging animations: " + Animation._getAnimationInfo(newTransformAnimation) + " + " + Animation._getAnimationInfo(propertyAnimations[j]) + ";", animation_common_1.traceCategories.Animation);
                            }
                            newTransformAnimation.value[propertyAnimations[j].property] = propertyAnimations[j].value;
                            propertyAnimations[j][_skip] = true;
                        }
                    }
                }
                result.push(newTransformAnimation);
            }
        }
        return result;
    };
    return Animation;
}(animation_common_1.AnimationBase));
exports.Animation = Animation;
function _getTransformMismatchErrorMessage(view) {
    var result = CGAffineTransformIdentity;
    var tx = view.translateX;
    var ty = view.translateY;
    result = CGAffineTransformTranslate(result, tx, ty);
    result = CGAffineTransformRotate(result, (view.rotate || 0) * Math.PI / 180);
    result = CGAffineTransformScale(result, view.scaleX || 1, view.scaleY || 1);
    var viewTransform = NSStringFromCGAffineTransform(result);
    var nativeTransform = NSStringFromCGAffineTransform(view.nativeViewProtected.transform);
    if (viewTransform !== nativeTransform) {
        return "View and Native transforms do not match. View: " + viewTransform + "; Native: " + nativeTransform;
    }
    return undefined;
}
exports._getTransformMismatchErrorMessage = _getTransformMismatchErrorMessage;
//# sourceMappingURL=animation.ios.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/animation/keyframe-animation.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = __webpack_require__("../node_modules/tns-core-modules/ui/enums/enums.js");
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var animation_1 = __webpack_require__("../node_modules/tns-core-modules/ui/animation/animation.js");
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
var Keyframes = (function () {
    function Keyframes() {
    }
    return Keyframes;
}());
exports.Keyframes = Keyframes;
var UnparsedKeyframe = (function () {
    function UnparsedKeyframe() {
    }
    return UnparsedKeyframe;
}());
exports.UnparsedKeyframe = UnparsedKeyframe;
var KeyframeDeclaration = (function () {
    function KeyframeDeclaration() {
    }
    return KeyframeDeclaration;
}());
exports.KeyframeDeclaration = KeyframeDeclaration;
var KeyframeInfo = (function () {
    function KeyframeInfo() {
        this.curve = enums_1.AnimationCurve.ease;
    }
    return KeyframeInfo;
}());
exports.KeyframeInfo = KeyframeInfo;
var KeyframeAnimationInfo = (function () {
    function KeyframeAnimationInfo() {
        this.name = "";
        this.duration = 0.3;
        this.delay = 0;
        this.iterations = 1;
        this.curve = "ease";
        this.isForwards = false;
        this.isReverse = false;
    }
    return KeyframeAnimationInfo;
}());
exports.KeyframeAnimationInfo = KeyframeAnimationInfo;
var KeyframeAnimation = (function () {
    function KeyframeAnimation() {
        this.delay = 0;
        this.iterations = 1;
    }
    KeyframeAnimation.keyframeAnimationFromInfo = function (info) {
        var length = info.keyframes.length;
        var animations = new Array();
        var startDuration = 0;
        if (info.isReverse) {
            for (var index_1 = length - 1; index_1 >= 0; index_1--) {
                var keyframe = info.keyframes[index_1];
                startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
            }
        }
        else {
            for (var index_2 = 0; index_2 < length; index_2++) {
                var keyframe = info.keyframes[index_2];
                startDuration = KeyframeAnimation.parseKeyframe(info, keyframe, animations, startDuration);
            }
            for (var index_3 = length - 1; index_3 > 0; index_3--) {
                var a1 = animations[index_3];
                var a2 = animations[index_3 - 1];
                if (a2["curve"] !== undefined) {
                    a1["curve"] = a2["curve"];
                    a2["curve"] = undefined;
                }
            }
        }
        animations.map(function (a) { return a["curve"] ? a : Object.assign(a, { curve: info.curve }); });
        var animation = new KeyframeAnimation();
        animation.delay = info.delay;
        animation.iterations = info.iterations;
        animation.animations = animations;
        animation._isForwards = info.isForwards;
        return animation;
    };
    KeyframeAnimation.parseKeyframe = function (info, keyframe, animations, startDuration) {
        var animation = {};
        for (var _i = 0, _a = keyframe.declarations; _i < _a.length; _i++) {
            var declaration = _a[_i];
            animation[declaration.property] = declaration.value;
        }
        var duration = keyframe.duration;
        if (duration === 0) {
            duration = 0.01;
        }
        else {
            duration = (info.duration * duration) - startDuration;
            startDuration += duration;
        }
        animation.duration = info.isReverse ? info.duration - duration : duration;
        animation.curve = keyframe.curve;
        animation.forceLayer = true;
        animation.valueSource = "keyframe";
        animations.push(animation);
        return startDuration;
    };
    Object.defineProperty(KeyframeAnimation.prototype, "isPlaying", {
        get: function () {
            return this._isPlaying;
        },
        enumerable: true,
        configurable: true
    });
    KeyframeAnimation.prototype.cancel = function () {
        if (!this.isPlaying) {
            trace_1.write("Keyframe animation is already playing.", trace_1.categories.Animation, trace_1.messageType.warn);
            return;
        }
        this._isPlaying = false;
        for (var i = this._nativeAnimations.length - 1; i >= 0; i--) {
            var animation = this._nativeAnimations[i];
            if (animation.isPlaying) {
                animation.cancel();
            }
        }
        if (this._nativeAnimations.length > 0) {
            var animation = this._nativeAnimations[0];
            this._resetAnimationValues(this._target, animation);
        }
        this._resetAnimations();
    };
    KeyframeAnimation.prototype.play = function (view) {
        var _this = this;
        if (this._isPlaying) {
            trace_1.write("Keyframe animation is already playing.", trace_1.categories.Animation, trace_1.messageType.warn);
            return new Promise(function (resolve) {
                resolve();
            });
        }
        var animationFinishedPromise = new Promise(function (resolve) {
            _this._resolve = resolve;
        });
        this._isPlaying = true;
        this._nativeAnimations = new Array();
        this._target = view;
        if (this.delay !== 0) {
            setTimeout(function () { return _this.animate(view, 0, _this.iterations); }, this.delay);
        }
        else {
            this.animate(view, 0, this.iterations);
        }
        return animationFinishedPromise;
    };
    KeyframeAnimation.prototype.animate = function (view, index, iterations) {
        var _this = this;
        if (!this._isPlaying) {
            return;
        }
        if (index === 0) {
            var animation = this.animations[0];
            if ("backgroundColor" in animation) {
                view.style[style_properties_1.backgroundColorProperty.keyframe] = animation.backgroundColor;
            }
            if ("scale" in animation) {
                view.style[style_properties_1.scaleXProperty.keyframe] = animation.scale.x;
                view.style[style_properties_1.scaleYProperty.keyframe] = animation.scale.y;
            }
            if ("translate" in animation) {
                view.style[style_properties_1.translateXProperty.keyframe] = animation.translate.x;
                view.style[style_properties_1.translateYProperty.keyframe] = animation.translate.y;
            }
            if ("rotate" in animation) {
                view.style[style_properties_1.rotateProperty.keyframe] = animation.rotate;
            }
            if ("opacity" in animation) {
                view.style[style_properties_1.opacityProperty.keyframe] = animation.opacity;
            }
            setTimeout(function () { return _this.animate(view, 1, iterations); }, 1);
        }
        else if (index < 0 || index >= this.animations.length) {
            iterations -= 1;
            if (iterations > 0) {
                this.animate(view, 0, iterations);
            }
            else {
                if (this._isForwards === false) {
                    var animation = this.animations[this.animations.length - 1];
                    this._resetAnimationValues(view, animation);
                }
                this._resolveAnimationFinishedPromise();
            }
        }
        else {
            var animation = void 0;
            var cachedAnimation = this._nativeAnimations[index - 1];
            if (cachedAnimation) {
                animation = cachedAnimation;
            }
            else {
                var animationDef = this.animations[index];
                animationDef.target = view;
                animation = new animation_1.Animation([animationDef]);
                this._nativeAnimations.push(animation);
            }
            var isLastIteration = iterations - 1 <= 0;
            animation.play(isLastIteration).then(function () {
                _this.animate(view, index + 1, iterations);
            }, function (error) {
                trace_1.write(typeof error === "string" ? error : error.message, trace_1.categories.Animation, trace_1.messageType.warn);
            }).catch(function (error) {
                trace_1.write(typeof error === "string" ? error : error.message, trace_1.categories.Animation, trace_1.messageType.warn);
            });
        }
    };
    KeyframeAnimation.prototype._resolveAnimationFinishedPromise = function () {
        this._nativeAnimations = new Array();
        this._isPlaying = false;
        this._target = null;
        this._resolve();
    };
    KeyframeAnimation.prototype._resetAnimations = function () {
        this._nativeAnimations = new Array();
        this._isPlaying = false;
        this._target = null;
    };
    KeyframeAnimation.prototype._resetAnimationValues = function (view, animation) {
        if ("backgroundColor" in animation) {
            view.style[style_properties_1.backgroundColorProperty.keyframe] = properties_1.unsetValue;
        }
        if ("scale" in animation) {
            view.style[style_properties_1.scaleXProperty.keyframe] = properties_1.unsetValue;
            view.style[style_properties_1.scaleYProperty.keyframe] = properties_1.unsetValue;
        }
        if ("translate" in animation) {
            view.style[style_properties_1.translateXProperty.keyframe] = properties_1.unsetValue;
            view.style[style_properties_1.translateYProperty.keyframe] = properties_1.unsetValue;
        }
        if ("rotate" in animation) {
            view.style[style_properties_1.rotateProperty.keyframe] = properties_1.unsetValue;
        }
        if ("opacity" in animation) {
            view.style[style_properties_1.opacityProperty.keyframe] = properties_1.unsetValue;
        }
    };
    return KeyframeAnimation;
}());
exports.KeyframeAnimation = KeyframeAnimation;
//# sourceMappingURL=keyframe-animation.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/builder/binding-builder.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var expressionSymbolsRegex = /[\+\-\*\/%\?:<>=!\|&\(\)^~]/;
var bindingConstants;
(function (bindingConstants) {
    bindingConstants.sourceProperty = "sourceProperty";
    bindingConstants.targetProperty = "targetProperty";
    bindingConstants.expression = "expression";
    bindingConstants.twoWay = "twoWay";
    bindingConstants.source = "source";
    bindingConstants.bindingValueKey = "$value";
    bindingConstants.parentValueKey = "$parent";
    bindingConstants.parentsValueKey = "$parents";
    bindingConstants.newPropertyValueKey = "$newPropertyValue";
})(bindingConstants = exports.bindingConstants || (exports.bindingConstants = {}));
;
var hasEqualSignRegex = /=+/;
var equalSignComparisionOperatorsRegex = /(==|===|>=|<=|!=|!==)/;
exports.parentsRegex = /\$parents\s*\[\s*(['"]*)\w*\1\s*\]/g;
function isNamedParam(value) {
    var equalSignIndex = value.search(hasEqualSignRegex);
    if (equalSignIndex > -1) {
        var equalSignSurround = value.substr(equalSignIndex > 0 ? equalSignIndex - 1 : 0, 3);
        if (equalSignSurround.search(equalSignComparisionOperatorsRegex) === -1) {
            return true;
        }
    }
    return false;
}
function areNamedParams(params) {
    for (var i = 0; i < params.length; i++) {
        if (isNamedParam(params[i])) {
            return true;
        }
    }
    return false;
}
var namedParamConstants = {
    propName: "propName",
    propValue: "propValue"
};
function getPropertyNameValuePair(param, knownOptions, callback) {
    var nameValuePair = {};
    var propertyName = param.substr(0, param.indexOf("=")).trim();
    var propertyValue = param.substr(param.indexOf("=") + 1).trim();
    if (knownOptions) {
        if (!propertyName) {
            propertyName = knownOptions.defaultProperty;
        }
        else {
            propertyName = propertyName in knownOptions ? propertyName : null;
        }
    }
    if (propertyName) {
        if (callback) {
            nameValuePair = callback(propertyName, propertyValue);
        }
        else {
            nameValuePair[namedParamConstants.propName] = propertyName;
            nameValuePair[namedParamConstants.propValue] = propertyValue;
        }
        return nameValuePair;
    }
    return null;
}
function parseNamedProperties(parameterList, knownOptions, callback) {
    var result = {};
    var nameValuePair;
    for (var i = 0; i < parameterList.length; i++) {
        nameValuePair = getPropertyNameValuePair(parameterList[i], knownOptions, callback);
        if (nameValuePair) {
            result[nameValuePair[namedParamConstants.propName]] = nameValuePair[namedParamConstants.propValue];
        }
    }
    return result;
}
function getParamsArray(value) {
    var result = [];
    var skipComma = 0;
    var indexReached = 0;
    var singleQuoteBlock = false;
    var doubleQuoteBlock = false;
    for (var i = 0; i < value.length; i++) {
        if (value[i] === "\"") {
            doubleQuoteBlock = !doubleQuoteBlock;
        }
        if (value[i] === "'") {
            singleQuoteBlock = !singleQuoteBlock;
        }
        if (value[i] === "(" || value[i] === "[") {
            skipComma++;
        }
        if (value[i] === ")" || value[i] === "]") {
            skipComma--;
        }
        if (value[i] === "," && skipComma === 0 && !(singleQuoteBlock || doubleQuoteBlock)) {
            result.push(value.substr(indexReached, i - indexReached));
            indexReached = i + 1;
        }
    }
    result.push(value.substr(indexReached));
    return result;
}
function isExpression(expression) {
    if (expression.search(expressionSymbolsRegex) > -1) {
        var parentsMatches = expression.match(exports.parentsRegex);
        if (parentsMatches) {
            var restOfExpression = expression.substr(expression.indexOf(parentsMatches[0]) + parentsMatches[0].length);
            if (!(restOfExpression.search(expressionSymbolsRegex) > -1)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
function getBindingOptions(name, value) {
    var namedParams = [];
    var params = getParamsArray(value);
    if (!areNamedParams(params)) {
        if (params.length === 1) {
            var trimmedValue = params[0].trim();
            var sourceProp = void 0;
            if (isExpression(trimmedValue)) {
                sourceProp = bindingConstants.bindingValueKey;
                namedParams.push(bindingConstants.expression + " = " + trimmedValue);
            }
            else {
                sourceProp = trimmedValue;
            }
            namedParams.push(bindingConstants.sourceProperty + " = " + sourceProp);
            namedParams.push(bindingConstants.twoWay + " = true");
        }
        else {
            namedParams.push(bindingConstants.sourceProperty + " = " + params[0].trim());
            namedParams.push(bindingConstants.expression + " = " + params[1].trim());
            var twoWay = params[2] ? params[2].toLowerCase().trim() === "true" : true;
            namedParams.push(bindingConstants.twoWay + " = " + twoWay);
        }
    }
    else {
        namedParams = params;
    }
    var bindingPropertyHandler = function (prop, value) {
        var result = {};
        result[namedParamConstants.propName] = prop;
        if (prop === bindingConstants.twoWay) {
            if (value === "true") {
                result[namedParamConstants.propValue] = true;
            }
            else {
                result[namedParamConstants.propValue] = false;
            }
        }
        else {
            result[namedParamConstants.propValue] = value;
        }
        return result;
    };
    var bindingOptionsParameters = parseNamedProperties(namedParams, xmlBindingProperties, bindingPropertyHandler);
    var bindOptions = {
        targetProperty: name
    };
    for (var prop in bindingOptionsParameters) {
        if (bindingOptionsParameters.hasOwnProperty(prop)) {
            bindOptions[prop] = bindingOptionsParameters[prop];
        }
    }
    if (bindOptions[bindingConstants.twoWay] === undefined) {
        bindOptions[bindingConstants.twoWay] = true;
    }
    return bindOptions;
}
exports.getBindingOptions = getBindingOptions;
var xmlBindingProperties = {
    sourceProperty: true,
    expression: true,
    twoWay: true,
    source: true,
    defaultProperty: bindingConstants.sourceProperty
};
//# sourceMappingURL=binding-builder.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/builder/builder.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __webpack_require__("../node_modules/tns-core-modules/utils/debug.js");
var xml = __webpack_require__("../node_modules/tns-core-modules/xml/xml.js");
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var types_1 = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var component_builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/component-builder/component-builder.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var file_name_resolver_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-name-resolver/file-name-resolver.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var ios = platform_1.platformNames.ios.toLowerCase();
var android = platform_1.platformNames.android.toLowerCase();
var defaultNameSpaceMatcher = /tns\.xsd$/i;
var trace;
function ensureTrace() {
    if (!trace) {
        trace = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
    }
}
function parse(value, context) {
    if (typeof value === "function") {
        return value();
    }
    else {
        var exports_1 = context ? getExports(context) : undefined;
        var componentModule = parseInternal(value, exports_1);
        return componentModule && componentModule.component;
    }
}
exports.parse = parse;
function parseMultipleTemplates(value, context) {
    var dummyComponent = "<ListView><ListView.itemTemplates>" + value + "</ListView.itemTemplates></ListView>";
    return parseInternal(dummyComponent, context).component["itemTemplates"];
}
exports.parseMultipleTemplates = parseMultipleTemplates;
function load(pathOrOptions, context) {
    var componentModule;
    if (!context) {
        if (typeof pathOrOptions === "string") {
            componentModule = loadInternal(pathOrOptions);
        }
        else {
            componentModule = loadCustomComponent(pathOrOptions.path, pathOrOptions.name, pathOrOptions.attributes, pathOrOptions.exports, pathOrOptions.page, true);
        }
    }
    else {
        var path_1 = pathOrOptions;
        componentModule = loadInternal(path_1, context);
    }
    return componentModule && componentModule.component;
}
exports.load = load;
function loadPage(moduleNamePath, fileName, context) {
    var componentModule = loadInternal(fileName, context, moduleNamePath);
    var componentView = componentModule && componentModule.component;
    if (componentView && moduleNamePath) {
        markAsModuleRoot(componentView, moduleNamePath);
    }
    return componentView;
}
exports.loadPage = loadPage;
var loadModule = profiling_1.profile("loadModule", function (moduleNamePath, entry) {
    if (global.moduleExists(entry.moduleName)) {
        return global.loadModule(entry.moduleName);
    }
    else {
        var moduleExportsResolvedPath = file_name_resolver_1.resolveFileName(moduleNamePath, "js");
        if (moduleExportsResolvedPath) {
            moduleExportsResolvedPath = moduleExportsResolvedPath.substr(0, moduleExportsResolvedPath.length - 3);
            return global.loadModule(moduleExportsResolvedPath);
        }
    }
    return null;
});
var viewFromBuilder = profiling_1.profile("viewFromBuilder", function (moduleNamePath, moduleExports) {
    var fileName = file_name_resolver_1.resolveFileName(moduleNamePath, "xml");
    return loadPage(moduleNamePath, fileName, moduleExports);
});
exports.createViewFromEntry = profiling_1.profile("createViewFromEntry", function (entry) {
    if (entry.create) {
        return createView(entry);
    }
    else if (entry.moduleName) {
        var currentAppPath = file_system_1.knownFolders.currentApp().path;
        var moduleNamePath = file_system_1.path.join(currentAppPath, entry.moduleName);
        var moduleExports = loadModule(moduleNamePath, entry);
        if (moduleExports && moduleExports.createPage) {
            return moduleCreateView(moduleNamePath, moduleExports);
        }
        else {
            return viewFromBuilder(moduleNamePath, moduleExports);
        }
    }
    throw new Error("Failed to load page XML file for module: " + entry.moduleName);
});
var createView = profiling_1.profile("entry.create", function (entry) {
    var view = entry.create();
    if (!view) {
        throw new Error("Failed to create Page with entry.create() function.");
    }
    return view;
});
var moduleCreateView = profiling_1.profile("module.createView", function (moduleNamePath, moduleExports) {
    var view = moduleExports.createPage();
    var cssFileName = file_name_resolver_1.resolveFileName(moduleNamePath, "css");
    if (cssFileName) {
        view.addCssFile(cssFileName);
    }
    return view;
});
function markAsModuleRoot(componentView, moduleNamePath) {
    var lastIndexOfSeparator = moduleNamePath.lastIndexOf(file_system_1.path.separator);
    var moduleName = moduleNamePath.substring(lastIndexOfSeparator + 1);
    componentView._moduleName = moduleName;
}
function loadInternal(fileName, context, moduleNamePath) {
    var componentModule;
    var appPath = file_system_1.knownFolders.currentApp().path;
    var filePathRelativeToApp = (moduleNamePath && moduleNamePath.startsWith(appPath) ? "./" + moduleNamePath.substr(appPath.length + 1) : moduleNamePath) + ".xml";
    if (global.moduleExists(filePathRelativeToApp)) {
        var text = global.loadModule(filePathRelativeToApp);
        componentModule = parseInternal(text, context, fileName, moduleNamePath);
    }
    else if (fileName && file_system_1.File.exists(fileName)) {
        var file = file_system_1.File.fromPath(fileName);
        var text = file.readTextSync(function (error) { throw new Error("Error loading file " + fileName + " :" + error.message); });
        componentModule = parseInternal(text, context, fileName, moduleNamePath);
    }
    if (componentModule && componentModule.component) {
        componentModule.component.exports = context;
    }
    if (!componentModule) {
        throw new Error("Failed to load component from module: " + filePathRelativeToApp + " or file: " + fileName);
    }
    return componentModule;
}
function loadCustomComponent(componentPath, componentName, attributes, context, parentPage, isRootComponent, moduleNamePath) {
    if (isRootComponent === void 0) { isRootComponent = true; }
    if (!parentPage && context) {
        parentPage = context["_parentPage"];
        delete context["_parentPage"];
    }
    var result;
    componentPath = componentPath.replace("~/", "");
    var moduleName = componentPath + "/" + componentName;
    var xmlModuleName = moduleName + ".xml";
    var fullComponentPathFilePathWithoutExt = componentPath;
    if (!file_system_1.File.exists(componentPath) || componentPath === "." || componentPath === "./") {
        fullComponentPathFilePathWithoutExt = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, componentPath, componentName);
    }
    var xmlFilePath = file_name_resolver_1.resolveFileName(fullComponentPathFilePathWithoutExt, "xml");
    if (xmlFilePath || global.moduleExists(xmlModuleName)) {
        var subExports = context;
        if (global.moduleExists(moduleName)) {
            subExports = global.loadModule(moduleName);
        }
        else {
            var jsFilePath = file_name_resolver_1.resolveFileName(fullComponentPathFilePathWithoutExt, "js");
            if (jsFilePath) {
                subExports = global.loadModule(jsFilePath);
            }
        }
        if (!subExports) {
            subExports = {};
        }
        subExports["_parentPage"] = parentPage;
        result = xmlFilePath ?
            loadInternal(xmlFilePath, subExports) :
            loadInternal(xmlFilePath, subExports, moduleName);
        if (types_1.isDefined(result) && types_1.isDefined(result.component) && types_1.isDefined(attributes)) {
            for (var attr in attributes) {
                component_builder_1.setPropertyValue(result.component, subExports, context, attr, attributes[attr]);
            }
        }
    }
    else {
        result = component_builder_1.getComponentModule(componentName, componentPath, attributes, context, moduleNamePath, isRootComponent);
    }
    var cssModulePath = fullComponentPathFilePathWithoutExt + ".css";
    if (cssModulePath.startsWith("/")) {
        var app = file_system_1.knownFolders.currentApp().path + "/";
        if (cssModulePath.startsWith(app)) {
            cssModulePath = "./" + cssModulePath.substr(app.length);
        }
    }
    if (global.moduleExists(cssModulePath)) {
        parentPage.addCssFile(cssModulePath);
    }
    else {
        var cssFilePath = file_name_resolver_1.resolveFileName(fullComponentPathFilePathWithoutExt, "css");
        if (cssFilePath) {
            if (parentPage && typeof parentPage.addCssFile === "function") {
                parentPage.addCssFile(cssFilePath);
            }
            else {
                ensureTrace();
                trace.write("CSS file found but no page specified. Please specify page in the options!", trace.categories.Error, trace.messageType.error);
            }
        }
    }
    return result;
}
function getExports(instance) {
    var isView = !!instance._domId;
    if (!isView) {
        return instance.exports || instance;
    }
    var exportObject = instance.exports;
    var parent = instance.parent;
    while (exportObject === undefined && parent) {
        exportObject = parent.exports;
        parent = parent.parent;
    }
    return exportObject;
}
function parseInternal(value, context, uri, moduleNamePath) {
    var start;
    var ui;
    var errorFormat = (debug_1.debug && uri) ? xml2ui.SourceErrorFormat(uri) : xml2ui.PositionErrorFormat;
    var componentSourceTracker = (debug_1.debug && uri) ? xml2ui.ComponentSourceTracker(uri) : function () {
    };
    (start = new xml2ui.XmlStringParser(errorFormat))
        .pipe(new xml2ui.PlatformFilter())
        .pipe(new xml2ui.XmlStateParser(ui = new xml2ui.ComponentParser(context, errorFormat, componentSourceTracker, moduleNamePath)));
    start.parse(value);
    return ui.rootComponentModule;
}
var xml2ui;
(function (xml2ui) {
    var XmlProducerBase = (function () {
        function XmlProducerBase() {
        }
        XmlProducerBase.prototype.pipe = function (next) {
            this._next = next;
            return next;
        };
        XmlProducerBase.prototype.next = function (args) {
            this._next.parse(args);
        };
        return XmlProducerBase;
    }());
    xml2ui.XmlProducerBase = XmlProducerBase;
    var XmlStringParser = (function (_super) {
        __extends(XmlStringParser, _super);
        function XmlStringParser(error) {
            var _this = _super.call(this) || this;
            _this.error = error || PositionErrorFormat;
            return _this;
        }
        XmlStringParser.prototype.parse = function (value) {
            var _this = this;
            var xmlParser = new xml.XmlParser(function (args) {
                try {
                    _this.next(args);
                }
                catch (e) {
                    throw _this.error(e, args.position);
                }
            }, function (e, p) {
                throw _this.error(e, p);
            }, true);
            if (types_1.isString(value)) {
                xmlParser.parse(value);
            }
        };
        return XmlStringParser;
    }(XmlProducerBase));
    xml2ui.XmlStringParser = XmlStringParser;
    function PositionErrorFormat(e, p) {
        return new debug_1.ScopeError(e, "Parsing XML at " + p.line + ":" + p.column);
    }
    xml2ui.PositionErrorFormat = PositionErrorFormat;
    function SourceErrorFormat(uri) {
        return function (e, p) {
            var source = p ? new debug_1.Source(uri, p.line, p.column) : new debug_1.Source(uri, -1, -1);
            e = new debug_1.SourceError(e, source, "Building UI from XML.");
            return e;
        };
    }
    xml2ui.SourceErrorFormat = SourceErrorFormat;
    function ComponentSourceTracker(uri) {
        return function (component, p) {
            if (!debug_1.Source.get(component)) {
                var source = p ? new debug_1.Source(uri, p.line, p.column) : new debug_1.Source(uri, -1, -1);
                debug_1.Source.set(component, source);
            }
        };
    }
    xml2ui.ComponentSourceTracker = ComponentSourceTracker;
    var PlatformFilter = (function (_super) {
        __extends(PlatformFilter, _super);
        function PlatformFilter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlatformFilter.prototype.parse = function (args) {
            if (args.eventType === xml.ParserEventType.StartElement) {
                if (PlatformFilter.isPlatform(args.elementName)) {
                    if (this.currentPlatformContext) {
                        throw new Error("Already in '" + this.currentPlatformContext + "' platform context and cannot switch to '" + args.elementName + "' platform! Platform tags cannot be nested.");
                    }
                    this.currentPlatformContext = args.elementName;
                    return;
                }
            }
            if (args.eventType === xml.ParserEventType.EndElement) {
                if (PlatformFilter.isPlatform(args.elementName)) {
                    this.currentPlatformContext = undefined;
                    return;
                }
            }
            if (this.currentPlatformContext && !PlatformFilter.isCurentPlatform(this.currentPlatformContext)) {
                return;
            }
            this.next(args);
        };
        PlatformFilter.isPlatform = function (value) {
            if (value) {
                var toLower = value.toLowerCase();
                return toLower === android || toLower === ios;
            }
            return false;
        };
        PlatformFilter.isCurentPlatform = function (value) {
            return value && value.toLowerCase() === platform_1.device.os.toLowerCase();
        };
        return PlatformFilter;
    }(XmlProducerBase));
    xml2ui.PlatformFilter = PlatformFilter;
    var XmlArgsReplay = (function (_super) {
        __extends(XmlArgsReplay, _super);
        function XmlArgsReplay(args, errorFormat) {
            var _this = _super.call(this) || this;
            _this.args = args;
            _this.error = errorFormat;
            return _this;
        }
        XmlArgsReplay.prototype.replay = function () {
            var _this = this;
            this.args.forEach(function (args) {
                try {
                    _this.next(args);
                }
                catch (e) {
                    throw _this.error(e, args.position);
                }
            });
        };
        return XmlArgsReplay;
    }(XmlProducerBase));
    xml2ui.XmlArgsReplay = XmlArgsReplay;
    var XmlStateParser = (function () {
        function XmlStateParser(state) {
            this.state = state;
        }
        XmlStateParser.prototype.parse = function (args) {
            this.state = this.state.parse(args);
        };
        return XmlStateParser;
    }());
    xml2ui.XmlStateParser = XmlStateParser;
    var TemplateParser = (function () {
        function TemplateParser(parent, templateProperty, setTemplateProperty) {
            if (setTemplateProperty === void 0) { setTemplateProperty = true; }
            this.parent = parent;
            this._context = templateProperty.context;
            this._recordedXmlStream = new Array();
            this._templateProperty = templateProperty;
            this._nestingLevel = 0;
            this._state = 0;
            this._setTemplateProperty = setTemplateProperty;
        }
        TemplateParser.prototype.parse = function (args) {
            if (args.eventType === xml.ParserEventType.StartElement) {
                this.parseStartElement(args.prefix, args.namespace, args.elementName, args.attributes);
            }
            else if (args.eventType === xml.ParserEventType.EndElement) {
                this.parseEndElement(args.prefix, args.elementName);
            }
            this._recordedXmlStream.push(args);
            return this._state === 2 ? this.parent : this;
        };
        Object.defineProperty(TemplateParser.prototype, "elementName", {
            get: function () {
                return this._templateProperty.elementName;
            },
            enumerable: true,
            configurable: true
        });
        TemplateParser.prototype.parseStartElement = function (prefix, namespace, elementName, attributes) {
            if (this._state === 0) {
                this._state = 1;
            }
            else if (this._state === 2) {
                throw new Error("Template must have exactly one root element but multiple elements were found.");
            }
            this._nestingLevel++;
        };
        TemplateParser.prototype.parseEndElement = function (prefix, elementName) {
            if (this._state === 0) {
                throw new Error("Template must have exactly one root element but none was found.");
            }
            else if (this._state === 2) {
                throw new Error("No more closing elements expected for this template.");
            }
            this._nestingLevel--;
            if (this._nestingLevel === 0) {
                this._state = 2;
                if (this._setTemplateProperty && this._templateProperty.name in this._templateProperty.parent.component) {
                    var template = this.buildTemplate();
                    this._templateProperty.parent.component[this._templateProperty.name] = template;
                }
            }
        };
        TemplateParser.prototype.buildTemplate = function () {
            var _this = this;
            var context = this._context;
            var errorFormat = this._templateProperty.errorFormat;
            var sourceTracker = this._templateProperty.sourceTracker;
            var template = profiling_1.profile("Template()", function () {
                var start;
                var ui;
                (start = new xml2ui.XmlArgsReplay(_this._recordedXmlStream, errorFormat))
                    .pipe(new XmlStateParser(ui = new ComponentParser(context, errorFormat, sourceTracker)));
                start.replay();
                return ui.rootComponentModule.component;
            });
            return template;
        };
        return TemplateParser;
    }());
    xml2ui.TemplateParser = TemplateParser;
    var MultiTemplateParser = (function () {
        function MultiTemplateParser(parent, templateProperty) {
            this.parent = parent;
            this.templateProperty = templateProperty;
            this._childParsers = new Array();
        }
        Object.defineProperty(MultiTemplateParser.prototype, "value", {
            get: function () { return this._value; },
            enumerable: true,
            configurable: true
        });
        MultiTemplateParser.prototype.parse = function (args) {
            if (args.eventType === xml.ParserEventType.StartElement && args.elementName === "template") {
                var childParser = new TemplateParser(this, this.templateProperty, false);
                childParser["key"] = args.attributes["key"];
                this._childParsers.push(childParser);
                return childParser;
            }
            if (args.eventType === xml.ParserEventType.EndElement) {
                var name_1 = ComponentParser.getComplexPropertyName(args.elementName);
                if (name_1 === this.templateProperty.name) {
                    var templates = new Array();
                    for (var i = 0; i < this._childParsers.length; i++) {
                        templates.push({
                            key: this._childParsers[i]["key"],
                            createView: this._childParsers[i].buildTemplate()
                        });
                    }
                    this._value = templates;
                    return this.parent.parse(args);
                }
            }
            return this;
        };
        return MultiTemplateParser;
    }());
    xml2ui.MultiTemplateParser = MultiTemplateParser;
    var ComponentParser = (function () {
        function ComponentParser(context, errorFormat, sourceTracker, moduleNamePath) {
            this.moduleNamePath = moduleNamePath;
            this.parents = new Array();
            this.complexProperties = new Array();
            this.context = context;
            this.error = errorFormat;
            this.sourceTracker = sourceTracker;
        }
        ComponentParser.prototype.buildComponent = function (args) {
            if (args.prefix && args.namespace) {
                return loadCustomComponent(args.namespace, args.elementName, args.attributes, this.context, this.currentRootView, !this.currentRootView, this.moduleNamePath);
            }
            else {
                var namespace = args.namespace;
                if (defaultNameSpaceMatcher.test(namespace || "")) {
                    namespace = undefined;
                }
                return component_builder_1.getComponentModule(args.elementName, namespace, args.attributes, this.context, this.moduleNamePath, !this.currentRootView);
            }
        };
        ComponentParser.prototype.parse = function (args) {
            var parent = this.parents[this.parents.length - 1];
            var complexProperty = this.complexProperties[this.complexProperties.length - 1];
            if (args.eventType === xml.ParserEventType.StartElement) {
                if (ComponentParser.isComplexProperty(args.elementName)) {
                    var name_2 = ComponentParser.getComplexPropertyName(args.elementName);
                    var complexProperty_1 = {
                        parent: parent,
                        name: name_2,
                        items: []
                    };
                    this.complexProperties.push(complexProperty_1);
                    if (ComponentParser.isKnownTemplate(name_2, parent.exports)) {
                        return new TemplateParser(this, {
                            context: (parent ? getExports(parent.component) : null) || this.context,
                            parent: parent,
                            name: name_2,
                            elementName: args.elementName,
                            templateItems: [],
                            errorFormat: this.error,
                            sourceTracker: this.sourceTracker
                        });
                    }
                    if (ComponentParser.isKnownMultiTemplate(name_2, parent.exports)) {
                        var parser = new MultiTemplateParser(this, {
                            context: (parent ? getExports(parent.component) : null) || this.context,
                            parent: parent,
                            name: name_2,
                            elementName: args.elementName,
                            templateItems: [],
                            errorFormat: this.error,
                            sourceTracker: this.sourceTracker
                        });
                        complexProperty_1.parser = parser;
                        return parser;
                    }
                }
                else {
                    var componentModule = this.buildComponent(args);
                    if (componentModule) {
                        this.sourceTracker(componentModule.component, args.position);
                        if (parent) {
                            if (complexProperty) {
                                ComponentParser.addToComplexProperty(parent, complexProperty, componentModule);
                            }
                            else if (parent.component._addChildFromBuilder) {
                                parent.component._addChildFromBuilder(args.elementName, componentModule.component);
                            }
                        }
                        else if (this.parents.length === 0) {
                            this.rootComponentModule = componentModule;
                            if (this.rootComponentModule) {
                                this.currentRootView = this.rootComponentModule.component;
                                if (this.currentRootView.exports) {
                                    this.context = this.currentRootView.exports;
                                }
                            }
                        }
                        this.parents.push(componentModule);
                    }
                }
            }
            else if (args.eventType === xml.ParserEventType.EndElement) {
                if (ComponentParser.isComplexProperty(args.elementName)) {
                    if (complexProperty) {
                        if (complexProperty.parser) {
                            parent.component[complexProperty.name] = complexProperty.parser.value;
                        }
                        else if (parent && parent.component._addArrayFromBuilder) {
                            parent.component._addArrayFromBuilder(complexProperty.name, complexProperty.items);
                            complexProperty.items = [];
                        }
                    }
                    this.complexProperties.pop();
                }
                else {
                    this.parents.pop();
                }
            }
            return this;
        };
        ComponentParser.isComplexProperty = function (name) {
            return types_1.isString(name) && name.indexOf(".") !== -1;
        };
        ComponentParser.getComplexPropertyName = function (fullName) {
            var name;
            if (types_1.isString(fullName)) {
                var names = fullName.split(".");
                name = names[names.length - 1];
            }
            return name;
        };
        ComponentParser.isKnownTemplate = function (name, exports) {
            return ComponentParser.KNOWNTEMPLATES in exports && exports[ComponentParser.KNOWNTEMPLATES] && name in exports[ComponentParser.KNOWNTEMPLATES];
        };
        ComponentParser.isKnownMultiTemplate = function (name, exports) {
            return ComponentParser.KNOWNMULTITEMPLATES in exports && exports[ComponentParser.KNOWNMULTITEMPLATES] && name in exports[ComponentParser.KNOWNMULTITEMPLATES];
        };
        ComponentParser.addToComplexProperty = function (parent, complexProperty, elementModule) {
            var parentComponent = parent.component;
            if (ComponentParser.isKnownCollection(complexProperty.name, parent.exports)) {
                complexProperty.items.push(elementModule.component);
            }
            else if (parentComponent._addChildFromBuilder) {
                parentComponent._addChildFromBuilder(complexProperty.name, elementModule.component);
            }
            else {
                parentComponent[complexProperty.name] = elementModule.component;
            }
        };
        ComponentParser.isKnownCollection = function (name, context) {
            return ComponentParser.KNOWNCOLLECTIONS in context && context[ComponentParser.KNOWNCOLLECTIONS] && name in context[ComponentParser.KNOWNCOLLECTIONS];
        };
        ComponentParser.KNOWNCOLLECTIONS = "knownCollections";
        ComponentParser.KNOWNTEMPLATES = "knownTemplates";
        ComponentParser.KNOWNMULTITEMPLATES = "knownMultiTemplates";
        __decorate([
            profiling_1.profile
        ], ComponentParser.prototype, "buildComponent", null);
        return ComponentParser;
    }());
    xml2ui.ComponentParser = ComponentParser;
})(xml2ui || (xml2ui = {}));
//# sourceMappingURL=builder.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/builder/component-builder/component-builder.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var bindable_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/bindable/bindable.js");
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var binding_builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/binding-builder.js");
var file_name_resolver_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-name-resolver/file-name-resolver.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var platform = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var filesystem = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var UI_PATH = "ui/";
var MODULES = {
    "TabViewItem": "ui/tab-view",
    "FormattedString": "text/formatted-string",
    "Span": "text/span",
    "ActionItem": "ui/action-bar",
    "NavigationButton": "ui/action-bar",
    "SegmentedBarItem": "ui/segmented-bar",
};
var CODEFILE = "codeFile";
var CSSFILE = "cssFile";
var IMPORT = "import";
var createComponentInstance = profiling_1.profile("createComponentInstance", function (elementName, namespace) {
    var instance;
    var instanceModule;
    var moduleId = MODULES[elementName] || UI_PATH +
        (elementName.toLowerCase().indexOf("layout") !== -1 ? "layouts/" : "") +
        elementName.split(/(?=[A-Z])/).join("-").toLowerCase();
    try {
        if (typeof namespace === "string") {
            if (global.moduleExists(namespace)) {
                moduleId = namespace;
            }
            else {
                var pathInsideTNSModules = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, "tns_modules", namespace);
                try {
                    instanceModule = global.require(pathInsideTNSModules);
                    moduleId = pathInsideTNSModules;
                }
                catch (e) {
                    moduleId = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, namespace);
                }
            }
        }
        if (!instanceModule) {
            instanceModule = global.loadModule(moduleId);
        }
        var instanceType = instanceModule[elementName] || Object;
        instance = new instanceType();
    }
    catch (ex) {
        var debug = __webpack_require__("../node_modules/tns-core-modules/utils/debug.js");
        throw new debug.ScopeError(ex, "Module '" + moduleId + "' not found for element '" + (namespace ? namespace + ":" : "") + elementName + "'.");
    }
    return { instance: instance, instanceModule: instanceModule };
});
var getComponentModuleExports = profiling_1.profile("getComponentModuleExports", function (instance, moduleExports, attributes) {
    if (attributes) {
        if (attributes[IMPORT]) {
            var importPath = attributes[IMPORT].trim();
            if (importPath.indexOf("~/") === 0) {
                importPath = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, importPath.replace("~/", ""));
            }
            moduleExports = global.loadModule(importPath);
            instance.exports = moduleExports;
        }
        if (attributes[CODEFILE]) {
            var codeFilePath = attributes[CODEFILE].trim();
            if (codeFilePath.indexOf("~/") === 0) {
                codeFilePath = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, codeFilePath.replace("~/", ""));
            }
            var codeFilePathWithExt = codeFilePath.indexOf(".js") !== -1 ? codeFilePath : codeFilePath + ".js";
            if (file_system_1.File.exists(codeFilePathWithExt)) {
                moduleExports = global.loadModule(codeFilePath);
                instance.exports = moduleExports;
            }
            else {
                throw new Error("Code file with path \"" + codeFilePathWithExt + "\" cannot be found!");
            }
        }
    }
    return moduleExports;
});
var applyComponentCss = profiling_1.profile("applyComponentCss", function (instance, moduleNamePath, attributes) {
    var cssApplied = false;
    if (attributes) {
        if (attributes[CSSFILE] && typeof instance.addCssFile === "function") {
            var cssFilePath = attributes[CSSFILE].trim();
            if (cssFilePath.indexOf("~/") === 0) {
                cssFilePath = file_system_1.path.join(file_system_1.knownFolders.currentApp().path, cssFilePath.replace("~/", ""));
            }
            if (file_system_1.File.exists(cssFilePath)) {
                instance.addCssFile(cssFilePath);
                cssApplied = true;
            }
            else {
                throw new Error("Css file with path \"" + cssFilePath + "\" cannot be found!");
            }
        }
    }
    if (typeof instance.addCssFile === "function") {
        if (moduleNamePath && !cssApplied) {
            var appPath = filesystem.knownFolders.currentApp().path;
            var cssPathRelativeToApp = (moduleNamePath.startsWith(appPath) ? "./" + moduleNamePath.substr(appPath.length + 1) : moduleNamePath) + ".css";
            if (global.moduleExists(cssPathRelativeToApp)) {
                instance.addCssFile(cssPathRelativeToApp);
            }
            var cssFilePath = file_name_resolver_1.resolveFileName(moduleNamePath, "css");
            if (cssFilePath) {
                instance.addCssFile(cssFilePath);
                cssApplied = true;
            }
        }
    }
});
var applyComponentAttributes = profiling_1.profile("applyComponentAttributes", function (instance, instanceModule, moduleExports, attributes) {
    if (instance && instanceModule) {
        for (var attr in attributes) {
            var attrValue = attributes[attr];
            if (attr.indexOf(":") !== -1) {
                var platformName = attr.split(":")[0].trim();
                if (platformName.toLowerCase() === platform.device.os.toLowerCase()) {
                    attr = attr.split(":")[1].trim();
                }
                else {
                    continue;
                }
            }
            if (attr.indexOf(".") !== -1) {
                var subObj = instance;
                var properties = attr.split(".");
                var subPropName = properties[properties.length - 1];
                for (var i = 0; i < properties.length - 1; i++) {
                    if (subObj !== undefined && subObj !== null) {
                        subObj = subObj[properties[i]];
                    }
                }
                if (subObj !== undefined && subObj !== null) {
                    setPropertyValue(subObj, instanceModule, moduleExports, subPropName, attrValue);
                }
            }
            else {
                setPropertyValue(instance, instanceModule, moduleExports, attr, attrValue);
            }
        }
    }
});
function getComponentModule(elementName, namespace, attributes, moduleExports, moduleNamePath, isRootComponent) {
    elementName = elementName.split("-").map(function (s) { return s[0].toUpperCase() + s.substring(1); }).join("");
    var _a = createComponentInstance(elementName, namespace), instance = _a.instance, instanceModule = _a.instanceModule;
    moduleExports = getComponentModuleExports(instance, moduleExports, attributes);
    if (isRootComponent) {
        applyComponentCss(instance, moduleNamePath, attributes);
    }
    applyComponentAttributes(instance, instanceModule, moduleExports, attributes);
    var componentModule;
    if (instance && instanceModule) {
        componentModule = { component: instance, exports: instanceModule };
    }
    return componentModule;
}
exports.getComponentModule = getComponentModule;
function setPropertyValue(instance, instanceModule, exports, propertyName, propertyValue) {
    if (isBinding(propertyValue) && instance.bind) {
        var bindOptions = binding_builder_1.getBindingOptions(propertyName, getBindingExpressionFromAttribute(propertyValue));
        instance.bind({
            sourceProperty: bindOptions[binding_builder_1.bindingConstants.sourceProperty],
            targetProperty: bindOptions[binding_builder_1.bindingConstants.targetProperty],
            expression: bindOptions[binding_builder_1.bindingConstants.expression],
            twoWay: bindOptions[binding_builder_1.bindingConstants.twoWay]
        }, bindOptions[binding_builder_1.bindingConstants.source]);
    }
    else if (bindable_1.isEventOrGesture(propertyName, instance)) {
        var handler = exports && exports[propertyValue];
        if (typeof handler === "function") {
            instance.on(propertyName, handler);
        }
    }
    else if (isKnownFunction(propertyName, instance) && exports && typeof exports[propertyValue] === "function") {
        instance[propertyName] = exports[propertyValue];
    }
    else {
        instance[propertyName] = propertyValue;
    }
}
exports.setPropertyValue = setPropertyValue;
function getBindingExpressionFromAttribute(value) {
    return value.replace("{{", "").replace("}}", "").trim();
}
function isBinding(value) {
    var isBinding;
    if (typeof value === "string") {
        var str = value.trim();
        isBinding = str.indexOf("{{") === 0 && str.lastIndexOf("}}") === str.length - 2;
    }
    return isBinding;
}
var KNOWN_FUNCTIONS = "knownFunctions";
function isKnownFunction(name, instance) {
    return instance.constructor
        && KNOWN_FUNCTIONS in instance.constructor
        && instance.constructor[KNOWN_FUNCTIONS].indexOf(name) !== -1;
}
//# sourceMappingURL=component-builder.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/button/button-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var text_base_1 = __webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js"));
var ButtonBase = (function (_super) {
    __extends(ButtonBase, _super);
    function ButtonBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ButtonBase.prototype, "textWrap", {
        get: function () {
            return this.style.whiteSpace === "normal";
        },
        set: function (value) {
            if (typeof value === "string") {
                value = text_base_1.booleanConverter(value);
            }
            this.style.whiteSpace = value ? "normal" : "nowrap";
        },
        enumerable: true,
        configurable: true
    });
    ButtonBase.tapEvent = "tap";
    ButtonBase = __decorate([
        text_base_1.CSSType("Button")
    ], ButtonBase);
    return ButtonBase;
}(text_base_1.TextBase));
exports.ButtonBase = ButtonBase;
ButtonBase.prototype.recycleNativeView = "auto";
//# sourceMappingURL=button-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/button/button.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var control_state_change_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/control-state-change/control-state-change.js");
var button_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/button/button-common.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/button/button-common.js"));
var Button = (function (_super) {
    __extends(Button, _super);
    function Button() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Button.prototype.createNativeView = function () {
        return UIButton.buttonWithType(1);
    };
    Button.prototype.initNativeView = function () {
        _super.prototype.initNativeView.call(this);
        var nativeView = this.nativeViewProtected;
        this._tapHandler = TapHandlerImpl.initWithOwner(new WeakRef(this));
        nativeView.addTargetActionForControlEvents(this._tapHandler, "tap", 64);
    };
    Button.prototype.disposeNativeView = function () {
        this._tapHandler = null;
        _super.prototype.disposeNativeView.call(this);
    };
    Object.defineProperty(Button.prototype, "ios", {
        get: function () {
            return this.nativeViewProtected;
        },
        enumerable: true,
        configurable: true
    });
    Button.prototype.onUnloaded = function () {
        _super.prototype.onUnloaded.call(this);
        if (this._stateChangedHandler) {
            this._stateChangedHandler.stop();
        }
    };
    Button.prototype._updateHandler = function (subscribe) {
        var _this = this;
        if (subscribe) {
            if (!this._stateChangedHandler) {
                this._stateChangedHandler = new control_state_change_1.ControlStateChangeListener(this.nativeViewProtected, function (s) {
                    _this._goToVisualState(s);
                });
            }
            this._stateChangedHandler.start();
        }
        else {
            this._stateChangedHandler.stop();
        }
    };
    Button.prototype[button_common_1.borderTopWidthProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.top,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.borderTopWidthProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var top = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: top, left: inset.left, bottom: inset.bottom, right: inset.right };
    };
    Button.prototype[button_common_1.borderRightWidthProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.right,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.borderRightWidthProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var right = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: inset.left, bottom: inset.bottom, right: right };
    };
    Button.prototype[button_common_1.borderBottomWidthProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.bottom,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.borderBottomWidthProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var bottom = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: inset.left, bottom: bottom, right: inset.right };
    };
    Button.prototype[button_common_1.borderLeftWidthProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.left,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.borderLeftWidthProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var left = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: left, bottom: inset.bottom, right: inset.right };
    };
    Button.prototype[button_common_1.paddingTopProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.top,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.paddingTopProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var top = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingTop + this.effectiveBorderTopWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: top, left: inset.left, bottom: inset.bottom, right: inset.right };
    };
    Button.prototype[button_common_1.paddingRightProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.right,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.paddingRightProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var right = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingRight + this.effectiveBorderRightWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: inset.left, bottom: inset.bottom, right: right };
    };
    Button.prototype[button_common_1.paddingBottomProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.bottom,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.paddingBottomProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var bottom = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingBottom + this.effectiveBorderBottomWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: inset.left, bottom: bottom, right: inset.right };
    };
    Button.prototype[button_common_1.paddingLeftProperty.getDefault] = function () {
        return {
            value: this.nativeViewProtected.contentEdgeInsets.left,
            unit: "px"
        };
    };
    Button.prototype[button_common_1.paddingLeftProperty.setNative] = function (value) {
        var inset = this.nativeViewProtected.contentEdgeInsets;
        var left = button_common_1.layout.toDeviceIndependentPixels(this.effectivePaddingLeft + this.effectiveBorderLeftWidth);
        this.nativeViewProtected.contentEdgeInsets = { top: inset.top, left: left, bottom: inset.bottom, right: inset.right };
    };
    Button.prototype[button_common_1.textAlignmentProperty.setNative] = function (value) {
        switch (value) {
            case "left":
                this.nativeViewProtected.titleLabel.textAlignment = 0;
                this.nativeViewProtected.contentHorizontalAlignment = 1;
                break;
            case "initial":
            case "center":
                this.nativeViewProtected.titleLabel.textAlignment = 1;
                this.nativeViewProtected.contentHorizontalAlignment = 0;
                break;
            case "right":
                this.nativeViewProtected.titleLabel.textAlignment = 2;
                this.nativeViewProtected.contentHorizontalAlignment = 2;
                break;
        }
    };
    Button.prototype[button_common_1.whiteSpaceProperty.setNative] = function (value) {
        var nativeView = this.nativeViewProtected.titleLabel;
        switch (value) {
            case "normal":
                nativeView.lineBreakMode = 0;
                nativeView.numberOfLines = 0;
                break;
            case "nowrap":
            case "initial":
                nativeView.lineBreakMode = 5;
                nativeView.numberOfLines = 1;
                break;
        }
    };
    Button.prototype.onMeasure = function (widthMeasureSpec, heightMeasureSpec) {
        if (!this.textWrap) {
            return _super.prototype.onMeasure.call(this, widthMeasureSpec, heightMeasureSpec);
        }
        var nativeView = this.nativeViewProtected;
        if (nativeView) {
            var width = button_common_1.layout.getMeasureSpecSize(widthMeasureSpec);
            var widthMode = button_common_1.layout.getMeasureSpecMode(widthMeasureSpec);
            var height = button_common_1.layout.getMeasureSpecSize(heightMeasureSpec);
            var heightMode = button_common_1.layout.getMeasureSpecMode(heightMeasureSpec);
            var horizontalPadding = this.effectivePaddingLeft + this.effectiveBorderLeftWidth + this.effectivePaddingRight + this.effectiveBorderRightWidth;
            var verticalPadding = this.effectivePaddingTop + this.effectiveBorderTopWidth + this.effectivePaddingBottom + this.effectiveBorderBottomWidth;
            if (verticalPadding === 0) {
                verticalPadding = button_common_1.layout.toDevicePixels(12);
            }
            var desiredSize = button_common_1.layout.measureNativeView(nativeView.titleLabel, width - horizontalPadding, widthMode, height - verticalPadding, heightMode);
            desiredSize.width = desiredSize.width + horizontalPadding;
            desiredSize.height = desiredSize.height + verticalPadding;
            var measureWidth = Math.max(desiredSize.width, this.effectiveMinWidth);
            var measureHeight = Math.max(desiredSize.height, this.effectiveMinHeight);
            var widthAndState = button_common_1.View.resolveSizeAndState(measureWidth, width, widthMode, 0);
            var heightAndState = button_common_1.View.resolveSizeAndState(measureHeight, height, heightMode, 0);
            this.setMeasuredDimension(widthAndState, heightAndState);
        }
    };
    __decorate([
        button_common_1.PseudoClassHandler("normal", "highlighted", "pressed", "active")
    ], Button.prototype, "_updateHandler", null);
    return Button;
}(button_common_1.ButtonBase));
exports.Button = Button;
var TapHandlerImpl = (function (_super) {
    __extends(TapHandlerImpl, _super);
    function TapHandlerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TapHandlerImpl.initWithOwner = function (owner) {
        var handler = TapHandlerImpl.new();
        handler._owner = owner;
        return handler;
    };
    TapHandlerImpl.prototype.tap = function (args) {
        var owner = this._owner.get();
        if (owner) {
            owner._emit(button_common_1.ButtonBase.tapEvent);
        }
    };
    TapHandlerImpl.ObjCExposedMethods = {
        "tap": { returns: interop.types.void, params: [interop.types.id] }
    };
    return TapHandlerImpl;
}(NSObject));
//# sourceMappingURL=button.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/bindable/bindable.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var observable_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
exports.Observable = observable_1.Observable;
exports.WrappedValue = observable_1.WrappedValue;
var weak_event_listener_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/weak-event-listener/weak-event-listener.js");
var binding_builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/binding-builder.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
exports.traceEnabled = trace_1.isEnabled;
exports.traceWrite = trace_1.write;
exports.traceError = trace_1.error;
exports.traceCategories = trace_1.categories;
exports.traceNotifyEvent = trace_1.notifyEvent;
exports.isCategorySet = trace_1.isCategorySet;
exports.traceMessageType = trace_1.messageType;
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var applicationCommon = __webpack_require__("../node_modules/tns-core-modules/application/application-common.js");
var polymerExpressions = __webpack_require__("../node_modules/tns-core-modules/js-libs/polymer-expressions/polymer-expressions.js");
var contextKey = "context";
var paramsRegex = /\[\s*(['"])*(\w*)\1\s*\]/;
var bc = binding_builder_1.bindingConstants;
var emptyArray = [];
var propertiesCache = {};
function getProperties(property) {
    if (!property) {
        return emptyArray;
    }
    var result = propertiesCache[property];
    if (result) {
        return result;
    }
    var parentsMatches = property.match(binding_builder_1.parentsRegex);
    result = property.replace(binding_builder_1.parentsRegex, "parentsMatch")
        .replace(/\]/g, "")
        .split(/\.|\[/);
    var parentsMatchesCounter = 0;
    for (var i = 0, resultLength = result.length; i < resultLength; i++) {
        if (result[i] === "parentsMatch") {
            result[i] = parentsMatches[parentsMatchesCounter++];
        }
    }
    propertiesCache[property] = result;
    return result;
}
function getEventOrGestureName(name) {
    return name.indexOf("on") === 0 ? name.substr(2, name.length - 2) : name;
}
exports.getEventOrGestureName = getEventOrGestureName;
function isGesture(eventOrGestureName) {
    var t = eventOrGestureName.trim().toLowerCase();
    return t === "tap"
        || t === "doubletap"
        || t === "pinch"
        || t === "pan"
        || t === "swipe"
        || t === "rotation"
        || t === "longpress"
        || t === "touch";
}
exports.isGesture = isGesture;
function isEventOrGesture(name, view) {
    if (typeof name === "string") {
        var eventOrGestureName = getEventOrGestureName(name);
        var evt = eventOrGestureName + "Event";
        return view.constructor && evt in view.constructor || isGesture(eventOrGestureName.toLowerCase());
    }
    return false;
}
exports.isEventOrGesture = isEventOrGesture;
var Binding = (function () {
    function Binding(target, options) {
        this.propertyChangeListeners = new Map();
        this.target = new WeakRef(target);
        this.options = options;
        this.sourceProperties = getProperties(options.sourceProperty);
        this.targetOptions = this.resolveOptions(target, getProperties(options.targetProperty));
        if (!this.targetOptions) {
            throw new Error("Invalid property: " + options.targetProperty + " for target: " + target);
        }
        if (options.twoWay) {
            var target_1 = this.targetOptions.instance.get();
            if (target_1 instanceof observable_1.Observable) {
                target_1.on(this.targetOptions.property + "Change", this.onTargetPropertyChanged, this);
            }
        }
    }
    Binding.prototype.onTargetPropertyChanged = function (data) {
        this.updateTwoWay(data.value);
    };
    Binding.prototype.loadedHandlerVisualTreeBinding = function (args) {
        var target = args.object;
        target.off("loaded", this.loadedHandlerVisualTreeBinding, this);
        var context = target.bindingContext;
        if (context !== undefined && context !== null) {
            this.update(context);
        }
    };
    ;
    Binding.prototype.clearSource = function () {
        var _this = this;
        this.propertyChangeListeners.forEach(function (observable, index, map) {
            weak_event_listener_1.removeWeakEventListener(observable, observable_1.Observable.propertyChangeEvent, _this.onSourcePropertyChanged, _this);
        });
        this.propertyChangeListeners.clear();
        if (this.source) {
            this.source.clear();
        }
        if (this.sourceOptions) {
            this.sourceOptions.instance.clear();
            this.sourceOptions = undefined;
        }
    };
    Binding.prototype.sourceAsObject = function (source) {
        var objectType = typeof source;
        if (objectType === "number") {
            source = new Number(source);
        }
        else if (objectType === "boolean") {
            source = new Boolean(source);
        }
        else if (objectType === "string") {
            source = new String(source);
        }
        return source;
    };
    Binding.prototype.bindingContextChanged = function (data) {
        var target = this.targetOptions.instance.get();
        if (!target) {
            this.unbind();
            return;
        }
        var value = data.value;
        if (value !== null && value !== undefined) {
            this.update(value);
        }
        else {
            this.clearBinding();
        }
    };
    Binding.prototype.bind = function (source) {
        var target = this.targetOptions.instance.get();
        if (this.sourceIsBindingContext && target instanceof observable_1.Observable && this.targetOptions.property !== "bindingContext") {
            target.on("bindingContextChange", this.bindingContextChanged, this);
        }
        this.update(source);
    };
    Binding.prototype.update = function (source) {
        this.clearSource();
        source = this.sourceAsObject(source);
        if (!types.isNullOrUndefined(source)) {
            this.source = new WeakRef(source);
            this.sourceOptions = this.resolveOptions(source, this.sourceProperties);
            var sourceValue = this.getSourcePropertyValue();
            this.updateTarget(sourceValue);
            this.addPropertyChangeListeners(this.source, this.sourceProperties);
        }
        else if (!this.sourceIsBindingContext) {
            var sourceValue = this.getSourcePropertyValue();
            this.updateTarget(sourceValue ? sourceValue : source);
        }
    };
    Binding.prototype.unbind = function () {
        var target = this.targetOptions.instance.get();
        if (target instanceof observable_1.Observable) {
            if (this.options.twoWay) {
                target.off(this.targetOptions.property + "Change", this.onTargetPropertyChanged, this);
            }
            if (this.sourceIsBindingContext && this.targetOptions.property !== "bindingContext") {
                target.off("bindingContextChange", this.bindingContextChanged, this);
            }
        }
        if (this.targetOptions) {
            this.targetOptions = undefined;
        }
        this.sourceProperties = undefined;
        if (!this.source) {
            return;
        }
        this.clearSource();
    };
    Binding.prototype.resolveObjectsAndProperties = function (source, properties) {
        var result = [];
        var currentObject = source;
        var currentObjectChanged = false;
        for (var i = 0, propsArrayLength = properties.length; i < propsArrayLength; i++) {
            var property = properties[i];
            if (property === bc.bindingValueKey) {
                currentObjectChanged = true;
            }
            if (property === bc.parentValueKey || property.indexOf(bc.parentsValueKey) === 0) {
                var parentView = this.getParentView(this.target.get(), property).view;
                if (parentView) {
                    currentObject = parentView.bindingContext;
                }
                else {
                    var targetInstance = this.target.get();
                    targetInstance.off("loaded", this.loadedHandlerVisualTreeBinding, this);
                    targetInstance.on("loaded", this.loadedHandlerVisualTreeBinding, this);
                }
                currentObjectChanged = true;
            }
            if (currentObject) {
                result.push({ instance: currentObject, property: property });
            }
            else {
                break;
            }
            if (!currentObjectChanged && (i < propsArrayLength - 1)) {
                currentObject = currentObject ? currentObject[properties[i]] : null;
            }
            currentObjectChanged = false;
        }
        return result;
    };
    Binding.prototype.addPropertyChangeListeners = function (source, sourceProperty, parentProperies) {
        var objectsAndProperties = this.resolveObjectsAndProperties(source.get(), sourceProperty);
        var prop = parentProperies || "";
        for (var i = 0, length_1 = objectsAndProperties.length; i < length_1; i++) {
            var propName = objectsAndProperties[i].property;
            prop += "$" + propName;
            var currentObject = objectsAndProperties[i].instance;
            if (!this.propertyChangeListeners.has(prop) && currentObject instanceof observable_1.Observable && currentObject._isViewBase) {
                weak_event_listener_1.addWeakEventListener(currentObject, propName + "Change", this.onSourcePropertyChanged, this);
                weak_event_listener_1.addWeakEventListener(currentObject, observable_1.Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
                this.propertyChangeListeners.set(prop, currentObject);
            }
            else if (!this.propertyChangeListeners.has(prop) && currentObject instanceof observable_1.Observable) {
                weak_event_listener_1.addWeakEventListener(currentObject, observable_1.Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
                this.propertyChangeListeners.set(prop, currentObject);
            }
        }
    };
    Binding.prototype.prepareExpressionForUpdate = function () {
        var escapedSourceProperty = utils_1.escapeRegexSymbols(this.options.sourceProperty);
        var expRegex = new RegExp(escapedSourceProperty, "g");
        var resultExp = this.options.expression.replace(expRegex, bc.newPropertyValueKey);
        return resultExp;
    };
    Binding.prototype.updateTwoWay = function (value) {
        if (this.updating || !this.options.twoWay) {
            return;
        }
        var newValue = value;
        if (this.options.expression) {
            var changedModel = {};
            changedModel[bc.bindingValueKey] = value;
            changedModel[bc.newPropertyValueKey] = value;
            var sourcePropertyName = "";
            if (this.sourceOptions) {
                sourcePropertyName = this.sourceOptions.property;
            }
            else if (typeof this.options.sourceProperty === "string" && this.options.sourceProperty.indexOf(".") === -1) {
                sourcePropertyName = this.options.sourceProperty;
            }
            if (sourcePropertyName !== "") {
                changedModel[sourcePropertyName] = value;
            }
            var updateExpression = this.prepareExpressionForUpdate();
            this.prepareContextForExpression(changedModel, updateExpression, undefined);
            var expressionValue = this._getExpressionValue(updateExpression, true, changedModel);
            if (expressionValue instanceof Error) {
                trace_1.write(expressionValue.message, trace_1.categories.Binding, trace_1.messageType.error);
            }
            newValue = expressionValue;
        }
        this.updateSource(newValue);
    };
    Binding.prototype._getExpressionValue = function (expression, isBackConvert, changedModel) {
        try {
            var exp_1 = polymerExpressions.PolymerExpressions.getExpression(expression);
            if (exp_1) {
                var context_1 = this.source && this.source.get && this.source.get() || global;
                var model = {};
                var addedProps = [];
                var resources = applicationCommon.getResources();
                for (var prop in resources) {
                    if (resources.hasOwnProperty(prop) && !context_1.hasOwnProperty(prop)) {
                        context_1[prop] = resources[prop];
                        addedProps.push(prop);
                    }
                }
                this.prepareContextForExpression(context_1, expression, addedProps);
                model[contextKey] = context_1;
                var result = exp_1.getValue(model, isBackConvert, changedModel ? changedModel : model);
                var addedPropsLength = addedProps.length;
                for (var i = 0; i < addedPropsLength; i++) {
                    delete context_1[addedProps[i]];
                }
                addedProps.length = 0;
                return result;
            }
            return new Error(expression + " is not a valid expression.");
        }
        catch (e) {
            var errorMessage = "Run-time error occured in file: " + e.sourceURL + " at line: " + e.line + " and column: " + e.column;
            return new Error(errorMessage);
        }
    };
    Binding.prototype.onSourcePropertyChanged = function (data) {
        var sourceProps = this.sourceProperties;
        var sourcePropsLength = sourceProps.length;
        var changedPropertyIndex = sourceProps.indexOf(data.propertyName);
        var parentProps = "";
        if (changedPropertyIndex > -1) {
            parentProps = "$" + sourceProps.slice(0, changedPropertyIndex + 1).join("$");
            while (this.propertyChangeListeners.get(parentProps) !== data.object) {
                changedPropertyIndex += sourceProps.slice(changedPropertyIndex + 1).indexOf(data.propertyName) + 1;
                parentProps = "$" + sourceProps.slice(0, changedPropertyIndex + 1).join("$");
            }
        }
        if (this.options.expression) {
            var expressionValue = this._getExpressionValue(this.options.expression, false, undefined);
            if (expressionValue instanceof Error) {
                trace_1.write(expressionValue.message, trace_1.categories.Binding, trace_1.messageType.error);
            }
            else {
                this.updateTarget(expressionValue);
            }
        }
        else {
            if (changedPropertyIndex > -1) {
                var props = sourceProps.slice(changedPropertyIndex + 1);
                var propsLength = props.length;
                if (propsLength > 0) {
                    var value = data.value;
                    for (var i = 0; i < propsLength; i++) {
                        value = value[props[i]];
                    }
                    this.updateTarget(value);
                }
                else if (data.propertyName === this.sourceOptions.property) {
                    this.updateTarget(data.value);
                }
            }
        }
        if (changedPropertyIndex > -1 && changedPropertyIndex < sourcePropsLength - 1) {
            var probablyChangedObject = this.propertyChangeListeners.get(parentProps);
            if (probablyChangedObject &&
                probablyChangedObject !== data.object[sourceProps[changedPropertyIndex]]) {
                for (var i = sourcePropsLength - 1; i > changedPropertyIndex; i--) {
                    var prop = "$" + sourceProps.slice(0, i + 1).join("$");
                    if (this.propertyChangeListeners.has(prop)) {
                        weak_event_listener_1.removeWeakEventListener(this.propertyChangeListeners.get(prop), observable_1.Observable.propertyChangeEvent, this.onSourcePropertyChanged, this);
                        this.propertyChangeListeners.delete(prop);
                    }
                }
                var newProps = sourceProps.slice(changedPropertyIndex + 1);
                var newObject = data.object[sourceProps[changedPropertyIndex]];
                if (!types.isNullOrUndefined(newObject) && typeof newObject === "object") {
                    this.addPropertyChangeListeners(new WeakRef(newObject), newProps, parentProps);
                }
            }
        }
    };
    Binding.prototype.prepareContextForExpression = function (model, expression, newProps) {
        var parentViewAndIndex;
        var parentView;
        var addedProps = newProps || [];
        if (expression.indexOf(bc.bindingValueKey) > -1) {
            model[bc.bindingValueKey] = model;
            addedProps.push(bc.bindingValueKey);
        }
        if (expression.indexOf(bc.parentValueKey) > -1) {
            parentView = this.getParentView(this.target.get(), bc.parentValueKey).view;
            if (parentView) {
                model[bc.parentValueKey] = parentView.bindingContext;
                addedProps.push(bc.parentValueKey);
            }
        }
        var parentsArray = expression.match(binding_builder_1.parentsRegex);
        if (parentsArray) {
            for (var i = 0; i < parentsArray.length; i++) {
                parentViewAndIndex = this.getParentView(this.target.get(), parentsArray[i]);
                if (parentViewAndIndex.view) {
                    model[bc.parentsValueKey] = model[bc.parentsValueKey] || {};
                    model[bc.parentsValueKey][parentViewAndIndex.index] = parentViewAndIndex.view.bindingContext;
                    addedProps.push(bc.parentsValueKey);
                }
            }
        }
    };
    Binding.prototype.getSourcePropertyValue = function () {
        if (this.options.expression) {
            var changedModel = {};
            changedModel[bc.bindingValueKey] = this.source ? this.source.get() : undefined;
            var expressionValue = this._getExpressionValue(this.options.expression, false, changedModel);
            if (expressionValue instanceof Error) {
                trace_1.write(expressionValue.message, trace_1.categories.Binding, trace_1.messageType.error);
            }
            else {
                return expressionValue;
            }
        }
        if (this.sourceOptions) {
            var sourceOptionsInstance = this.sourceOptions.instance.get();
            if (this.sourceOptions.property === bc.bindingValueKey) {
                return sourceOptionsInstance;
            }
            else if ((sourceOptionsInstance instanceof observable_1.Observable) && (this.sourceOptions.property && this.sourceOptions.property !== "")) {
                return sourceOptionsInstance.get(this.sourceOptions.property);
            }
            else if (sourceOptionsInstance && this.sourceOptions.property && this.sourceOptions.property !== "" &&
                this.sourceOptions.property in sourceOptionsInstance) {
                return sourceOptionsInstance[this.sourceOptions.property];
            }
            else {
                trace_1.write("Property: '" + this.sourceOptions.property + "' is invalid or does not exist. SourceProperty: '" + this.options.sourceProperty + "'", trace_1.categories.Binding, trace_1.messageType.error);
            }
        }
        return null;
    };
    Binding.prototype.clearBinding = function () {
        this.clearSource();
        this.updateTarget(properties_1.unsetValue);
    };
    Binding.prototype.updateTarget = function (value) {
        if (this.updating) {
            return;
        }
        this.updateOptions(this.targetOptions, types.isNullOrUndefined(value) ? properties_1.unsetValue : value);
    };
    Binding.prototype.updateSource = function (value) {
        if (this.updating || !this.source || !this.source.get()) {
            return;
        }
        this.updateOptions(this.sourceOptions, value);
    };
    Binding.prototype.getParentView = function (target, property) {
        if (!target) {
            return { view: null, index: null };
        }
        var result;
        if (property === bc.parentValueKey) {
            result = target.parent;
        }
        var index = null;
        if (property.indexOf(bc.parentsValueKey) === 0) {
            result = target.parent;
            var indexParams = paramsRegex.exec(property);
            if (indexParams && indexParams.length > 1) {
                index = indexParams[2];
            }
            if (!isNaN(index)) {
                var indexAsInt = parseInt(index);
                while (indexAsInt > 0) {
                    result = result.parent;
                    indexAsInt--;
                }
            }
            else if (types.isString(index)) {
                while (result && result.typeName !== index) {
                    result = result.parent;
                }
            }
        }
        return { view: result, index: index };
    };
    Binding.prototype.resolveOptions = function (obj, properties) {
        var objectsAndProperties = this.resolveObjectsAndProperties(obj, properties);
        if (objectsAndProperties.length > 0) {
            var resolvedObj = objectsAndProperties[objectsAndProperties.length - 1].instance;
            var prop = objectsAndProperties[objectsAndProperties.length - 1].property;
            return {
                instance: new WeakRef(this.sourceAsObject(resolvedObj)),
                property: prop
            };
        }
        return null;
    };
    Binding.prototype.updateOptions = function (options, value) {
        var optionsInstance;
        if (options && options.instance) {
            optionsInstance = options.instance.get();
        }
        if (!optionsInstance) {
            return;
        }
        this.updating = true;
        try {
            if (isEventOrGesture(options.property, optionsInstance) &&
                types.isFunction(value)) {
                optionsInstance.off(options.property, null, optionsInstance.bindingContext);
                optionsInstance.on(options.property, value, optionsInstance.bindingContext);
            }
            else if (optionsInstance instanceof observable_1.Observable) {
                optionsInstance.set(options.property, value);
            }
            else {
                optionsInstance[options.property] = value;
            }
        }
        catch (ex) {
            trace_1.write("Binding error while setting property " + options.property + " of " + optionsInstance + ": " + ex, trace_1.categories.Binding, trace_1.messageType.error);
        }
        this.updating = false;
    };
    return Binding;
}());
exports.Binding = Binding;
//# sourceMappingURL=bindable.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/control-state-change/control-state-change.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var ObserverClass = (function (_super) {
    __extends(ObserverClass, _super);
    function ObserverClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ObserverClass.prototype.observeValueForKeyPathOfObjectChangeContext = function (path) {
        if (path === "selected") {
            this["_owner"]._onSelectedChanged();
        }
        else if (path === "enabled") {
            this["_owner"]._onEnabledChanged();
        }
        else if (path === "highlighted") {
            this["_owner"]._onHighlightedChanged();
        }
    };
    return ObserverClass;
}(NSObject));
var ControlStateChangeListener = (function () {
    function ControlStateChangeListener(control, callback) {
        this._observing = false;
        this._observer = ObserverClass.alloc();
        this._observer["_owner"] = this;
        this._control = control;
        this._callback = callback;
    }
    ControlStateChangeListener.prototype.start = function () {
        if (!this._observing) {
            this._control.addObserverForKeyPathOptionsContext(this._observer, "highlighted", 1, null);
            this._observing = true;
            this._updateState();
        }
    };
    ControlStateChangeListener.prototype.stop = function () {
        if (this._observing) {
            this._observing = false;
            this._control.removeObserverForKeyPath(this._observer, "highlighted");
        }
    };
    ControlStateChangeListener.prototype._onEnabledChanged = function () {
        this._updateState();
    };
    ControlStateChangeListener.prototype._onSelectedChanged = function () {
        this._updateState();
    };
    ControlStateChangeListener.prototype._onHighlightedChanged = function () {
        this._updateState();
    };
    ControlStateChangeListener.prototype._updateState = function () {
        var state = "normal";
        if (this._control.highlighted) {
            state = "highlighted";
        }
        this._callback(state);
    };
    return ControlStateChangeListener;
}());
exports.ControlStateChangeListener = ControlStateChangeListener;
//# sourceMappingURL=control-state-change.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/properties/properties.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
var style_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style/style.js");
exports.Style = style_1.Style;
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
exports.unsetValue = new Object();
var cssPropertyNames = [];
var symbolPropertyMap = {};
var cssSymbolPropertyMap = {};
var inheritableProperties = new Array();
var inheritableCssProperties = new Array();
function print(map) {
    var symbols = Object.getOwnPropertySymbols(map);
    for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
        var symbol = symbols_1[_i];
        var prop = map[symbol];
        if (!prop.registered) {
            console.log("Property " + prop.name + " not Registered!!!!!");
        }
    }
}
function _printUnregisteredProperties() {
    print(symbolPropertyMap);
    print(cssSymbolPropertyMap);
}
exports._printUnregisteredProperties = _printUnregisteredProperties;
function _getProperties() {
    return getPropertiesFromMap(symbolPropertyMap);
}
exports._getProperties = _getProperties;
function _getStyleProperties() {
    return getPropertiesFromMap(cssSymbolPropertyMap);
}
exports._getStyleProperties = _getStyleProperties;
function getPropertiesFromMap(map) {
    var props = [];
    Object.getOwnPropertySymbols(map).forEach(function (symbol) { return props.push(map[symbol]); });
    return props;
}
var Property = (function () {
    function Property(options) {
        this.enumerable = true;
        this.configurable = true;
        var propertyName = options.name;
        this.name = propertyName;
        var key = Symbol(propertyName + ":propertyKey");
        this.key = key;
        var getDefault = Symbol(propertyName + ":getDefault");
        this.getDefault = getDefault;
        var setNative = Symbol(propertyName + ":setNative");
        this.setNative = setNative;
        var defaultValueKey = Symbol(propertyName + ":nativeDefaultValue");
        this.defaultValueKey = defaultValueKey;
        var defaultValue = options.defaultValue;
        this.defaultValue = defaultValue;
        var eventName = propertyName + "Change";
        var equalityComparer = options.equalityComparer;
        var affectsLayout = options.affectsLayout;
        var valueChanged = options.valueChanged;
        var valueConverter = options.valueConverter;
        var property = this;
        this.set = function (boxedValue) {
            var reset = boxedValue === exports.unsetValue;
            var value;
            var wrapped;
            if (reset) {
                value = defaultValue;
            }
            else {
                wrapped = boxedValue && boxedValue.wrapped;
                value = wrapped ? observable_1.WrappedValue.unwrap(boxedValue) : boxedValue;
                if (valueConverter && typeof value === "string") {
                    value = valueConverter(value);
                }
            }
            var oldValue = key in this ? this[key] : defaultValue;
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (wrapped || changed) {
                if (affectsLayout) {
                    this.requestLayout();
                }
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                this[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                this[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
                            }
                            this[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (this.domNode) {
                    if (reset) {
                        this.domNode.attributeRemoved(propertyName);
                    }
                    else {
                        this.domNode.attributeModified(propertyName, value);
                    }
                }
            }
        };
        this.get = function () {
            return key in this ? this[key] : defaultValue;
        };
        this.nativeValueChange = function (owner, value) {
            var oldValue = key in owner ? owner[key] : defaultValue;
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                owner[key] = value;
                if (valueChanged) {
                    valueChanged(owner, oldValue, value);
                }
                if (owner.nativeViewProtected && !(defaultValueKey in owner)) {
                    owner[defaultValueKey] = owner[getDefault] ? owner[getDefault]() : defaultValue;
                }
                if (owner.hasListeners(eventName)) {
                    owner.notify({ object: owner, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (affectsLayout) {
                    owner.requestLayout();
                }
                if (owner.domNode) {
                    owner.domNode.attributeModified(propertyName, value);
                }
            }
        };
        symbolPropertyMap[key] = this;
    }
    Property.prototype.register = function (cls) {
        if (this.registered) {
            throw new Error("Property " + this.name + " already registered.");
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this);
    };
    Property.prototype.isSet = function (instance) {
        return this.key in instance;
    };
    return Property;
}());
exports.Property = Property;
Property.prototype.isStyleProperty = false;
var CoercibleProperty = (function (_super) {
    __extends(CoercibleProperty, _super);
    function CoercibleProperty(options) {
        var _this = _super.call(this, options) || this;
        var propertyName = options.name;
        var key = _this.key;
        var getDefault = _this.getDefault;
        var setNative = _this.setNative;
        var defaultValueKey = _this.defaultValueKey;
        var defaultValue = _this.defaultValue;
        var coerceKey = Symbol(propertyName + ":coerceKey");
        var eventName = propertyName + "Change";
        var affectsLayout = options.affectsLayout;
        var equalityComparer = options.equalityComparer;
        var valueChanged = options.valueChanged;
        var valueConverter = options.valueConverter;
        var coerceCallback = options.coerceValue;
        var property = _this;
        _this.coerce = function (target) {
            var originalValue = coerceKey in target ? target[coerceKey] : defaultValue;
            target[propertyName] = originalValue;
        };
        _this.set = function (boxedValue) {
            var reset = boxedValue === exports.unsetValue;
            var value;
            var wrapped;
            if (reset) {
                value = defaultValue;
                delete this[coerceKey];
            }
            else {
                wrapped = boxedValue && boxedValue.wrapped;
                value = wrapped ? observable_1.WrappedValue.unwrap(boxedValue) : boxedValue;
                if (valueConverter && typeof value === "string") {
                    value = valueConverter(value);
                }
                this[coerceKey] = value;
                value = coerceCallback(this, value);
            }
            var oldValue = key in this ? this[key] : defaultValue;
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (wrapped || changed) {
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                this[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                this[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (this[setNative]) {
                        if (this._suspendNativeUpdatesCount) {
                            if (this._suspendedUpdates) {
                                this._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = this[getDefault] ? this[getDefault]() : defaultValue;
                            }
                            this[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (affectsLayout) {
                    this.requestLayout();
                }
                if (this.domNode) {
                    if (reset) {
                        this.domNode.attributeRemoved(propertyName);
                    }
                    else {
                        this.domNode.attributeModified(propertyName, value);
                    }
                }
            }
        };
        return _this;
    }
    return CoercibleProperty;
}(Property));
exports.CoercibleProperty = CoercibleProperty;
var InheritedProperty = (function (_super) {
    __extends(InheritedProperty, _super);
    function InheritedProperty(options) {
        var _this = _super.call(this, options) || this;
        var name = options.name;
        var key = _this.key;
        var defaultValue = options.defaultValue;
        var sourceKey = Symbol(name + ":valueSourceKey");
        _this.sourceKey = sourceKey;
        var setBase = _this.set;
        var setFunc = function (valueSource) { return function (value) {
            var that = this;
            var unboxedValue;
            var newValueSource;
            if (value === exports.unsetValue) {
                var parent_1 = that.parent;
                if (parent_1 && parent_1[sourceKey] !== 0) {
                    unboxedValue = parent_1[name];
                    newValueSource = 1;
                }
                else {
                    unboxedValue = defaultValue;
                    newValueSource = 0;
                }
            }
            else {
                unboxedValue = value;
                newValueSource = valueSource;
            }
            var currentValue = that[key];
            setBase.call(that, unboxedValue);
            var newValue = that[key];
            that[sourceKey] = newValueSource;
            if (currentValue !== newValue) {
                var reset_1 = newValueSource === 0;
                that.eachChild(function (child) {
                    var childValueSource = child[sourceKey] || 0;
                    if (reset_1) {
                        if (childValueSource === 1) {
                            setFunc.call(child, exports.unsetValue);
                        }
                    }
                    else {
                        if (childValueSource <= 1) {
                            setInheritedValue.call(child, newValue);
                        }
                    }
                    return true;
                });
            }
        }; };
        var setInheritedValue = setFunc(1);
        _this.setInheritedValue = setInheritedValue;
        _this.set = setFunc(3);
        inheritableProperties.push(_this);
        return _this;
    }
    return InheritedProperty;
}(Property));
exports.InheritedProperty = InheritedProperty;
var CssProperty = (function () {
    function CssProperty(options) {
        var propertyName = options.name;
        this.name = propertyName;
        cssPropertyNames.push(options.cssName);
        this.cssName = "css:" + options.cssName;
        this.cssLocalName = options.cssName;
        var key = Symbol(propertyName + ":propertyKey");
        this.key = key;
        var sourceKey = Symbol(propertyName + ":valueSourceKey");
        this.sourceKey = sourceKey;
        var getDefault = Symbol(propertyName + ":getDefault");
        this.getDefault = getDefault;
        var setNative = Symbol(propertyName + ":setNative");
        this.setNative = setNative;
        var defaultValueKey = Symbol(propertyName + ":nativeDefaultValue");
        this.defaultValueKey = defaultValueKey;
        var defaultValue = options.defaultValue;
        this.defaultValue = defaultValue;
        var eventName = propertyName + "Change";
        var affectsLayout = options.affectsLayout;
        var equalityComparer = options.equalityComparer;
        var valueChanged = options.valueChanged;
        var valueConverter = options.valueConverter;
        var property = this;
        function setLocalValue(newValue) {
            var reset = newValue === exports.unsetValue || newValue === "";
            var value;
            if (reset) {
                value = defaultValue;
                delete this[sourceKey];
            }
            else {
                this[sourceKey] = 3;
                value = (valueConverter && typeof newValue === "string") ?
                    valueConverter(newValue) :
                    newValue;
            }
            var oldValue = key in this ? this[key] : defaultValue;
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                var view = this.view;
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                view[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                            }
                            view[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (affectsLayout) {
                    view.requestLayout();
                }
            }
        }
        function setCssValue(newValue) {
            var currentValueSource = this[sourceKey] || 0;
            if (currentValueSource === 3) {
                return;
            }
            var reset = newValue === exports.unsetValue || newValue === "";
            var value;
            if (reset) {
                value = defaultValue;
                delete this[sourceKey];
            }
            else {
                value = valueConverter && typeof newValue === "string" ?
                    valueConverter(newValue) :
                    newValue;
                this[sourceKey] = 2;
            }
            var oldValue = key in this ? this[key] : defaultValue;
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                var view = this.view;
                if (reset) {
                    delete this[key];
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (defaultValueKey in this) {
                                view[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view[setNative](defaultValue);
                            }
                        }
                    }
                }
                else {
                    this[key] = value;
                    if (valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    if (view[setNative]) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                            }
                            view[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (affectsLayout) {
                    view.requestLayout();
                }
            }
        }
        function get() {
            return key in this ? this[key] : defaultValue;
        }
        this.cssValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: get,
            set: setCssValue
        };
        this.localValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: get,
            set: setLocalValue
        };
        cssSymbolPropertyMap[key] = this;
    }
    CssProperty.prototype.register = function (cls) {
        if (this.registered) {
            throw new Error("Property " + this.name + " already registered.");
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
        Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
        if (this.cssLocalName !== this.cssName) {
            Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
        }
    };
    CssProperty.prototype.isSet = function (instance) {
        return this.key in instance;
    };
    return CssProperty;
}());
exports.CssProperty = CssProperty;
CssProperty.prototype.isStyleProperty = true;
var CssAnimationProperty = (function () {
    function CssAnimationProperty(options) {
        var valueConverter = options.valueConverter, equalityComparer = options.equalityComparer, valueChanged = options.valueChanged, defaultValue = options.defaultValue;
        var propertyName = options.name;
        this.name = propertyName;
        cssPropertyNames.push(options.cssName);
        CssAnimationProperty.properties[propertyName] = this;
        if (options.cssName && options.cssName !== propertyName) {
            CssAnimationProperty.properties[options.cssName] = this;
        }
        this._valueConverter = options.valueConverter;
        var cssLocalName = (options.cssName || propertyName);
        this.cssLocalName = cssLocalName;
        var cssName = "css:" + cssLocalName;
        this.cssName = cssName;
        var keyframeName = "keyframe:" + propertyName;
        this.keyframe = keyframeName;
        var defaultName = "default:" + propertyName;
        var defaultValueKey = Symbol(defaultName);
        this.defaultValueKey = defaultValueKey;
        this.defaultValue = defaultValue;
        var cssValue = Symbol(cssName);
        var styleValue = Symbol("local:" + propertyName);
        var keyframeValue = Symbol(keyframeName);
        var computedValue = Symbol("computed-value:" + propertyName);
        this.key = computedValue;
        var computedSource = Symbol("computed-source:" + propertyName);
        this.source = computedSource;
        this.getDefault = Symbol(propertyName + ":getDefault");
        var getDefault = this.getDefault;
        var setNative = this.setNative = Symbol(propertyName + ":setNative");
        var eventName = propertyName + "Change";
        var property = this;
        function descriptor(symbol, propertySource, enumerable, configurable, getsComputed) {
            return {
                enumerable: enumerable, configurable: configurable,
                get: getsComputed ? function () { return this[computedValue]; } : function () { return this[symbol]; },
                set: function (boxedValue) {
                    var oldValue = this[computedValue];
                    var oldSource = this[computedSource];
                    var wasSet = oldSource !== 0;
                    var reset = boxedValue === exports.unsetValue || boxedValue === "";
                    if (reset) {
                        this[symbol] = exports.unsetValue;
                        if (this[computedSource] === propertySource) {
                            if (this[styleValue] !== exports.unsetValue) {
                                this[computedSource] = 3;
                                this[computedValue] = this[styleValue];
                            }
                            else if (this[cssValue] !== exports.unsetValue) {
                                this[computedSource] = 2;
                                this[computedValue] = this[cssValue];
                            }
                            else {
                                delete this[computedSource];
                                delete this[computedValue];
                            }
                        }
                    }
                    else {
                        if (valueConverter && typeof boxedValue === "string") {
                            boxedValue = valueConverter(boxedValue);
                        }
                        this[symbol] = boxedValue;
                        if (this[computedSource] <= propertySource) {
                            this[computedSource] = propertySource;
                            this[computedValue] = boxedValue;
                        }
                    }
                    var value = this[computedValue];
                    var source = this[computedSource];
                    var isSet = source !== 0;
                    var computedValueChanged = oldValue !== value && (!equalityComparer || !equalityComparer(oldValue, value));
                    if (computedValueChanged && valueChanged) {
                        valueChanged(this, oldValue, value);
                    }
                    var view = this.view;
                    if (view[setNative] && (computedValueChanged || isSet !== wasSet)) {
                        if (view._suspendNativeUpdatesCount) {
                            if (view._suspendedUpdates) {
                                view._suspendedUpdates[propertyName] = property;
                            }
                        }
                        else {
                            if (isSet) {
                                if (!wasSet && !(defaultValueKey in this)) {
                                    this[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                                }
                                view[setNative](value);
                            }
                            else if (wasSet) {
                                if (defaultValueKey in this) {
                                    view[setNative](this[defaultValueKey]);
                                }
                                else {
                                    view[setNative](defaultValue);
                                }
                            }
                        }
                    }
                    if (computedValueChanged && this.hasListeners(eventName)) {
                        this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                    }
                }
            };
        }
        var defaultPropertyDescriptor = descriptor(defaultValueKey, 0, false, false, false);
        var cssPropertyDescriptor = descriptor(cssValue, 2, false, false, false);
        var stylePropertyDescriptor = descriptor(styleValue, 3, true, true, true);
        var keyframePropertyDescriptor = descriptor(keyframeValue, 4, false, false, false);
        symbolPropertyMap[computedValue] = this;
        cssSymbolPropertyMap[computedValue] = this;
        this.register = function (cls) {
            cls.prototype[computedValue] = options.defaultValue;
            cls.prototype[computedSource] = 0;
            cls.prototype[cssValue] = exports.unsetValue;
            cls.prototype[styleValue] = exports.unsetValue;
            cls.prototype[keyframeValue] = exports.unsetValue;
            Object.defineProperty(cls.prototype, defaultName, defaultPropertyDescriptor);
            Object.defineProperty(cls.prototype, cssName, cssPropertyDescriptor);
            Object.defineProperty(cls.prototype, propertyName, stylePropertyDescriptor);
            if (options.cssName && options.cssName !== options.name) {
                Object.defineProperty(cls.prototype, options.cssName, stylePropertyDescriptor);
            }
            Object.defineProperty(cls.prototype, keyframeName, keyframePropertyDescriptor);
        };
    }
    CssAnimationProperty.prototype._initDefaultNativeValue = function (target) {
        var defaultValueKey = this.defaultValueKey;
        if (!(defaultValueKey in target)) {
            var view = target.view;
            var getDefault = this.getDefault;
            target[defaultValueKey] = view[getDefault] ? view[getDefault]() : this.defaultValue;
        }
    };
    CssAnimationProperty._getByCssName = function (name) {
        return this.properties[name];
    };
    CssAnimationProperty._getPropertyNames = function () {
        return Object.keys(CssAnimationProperty.properties);
    };
    CssAnimationProperty.prototype.isSet = function (instance) {
        return instance[this.source] !== 0;
    };
    CssAnimationProperty.properties = {};
    return CssAnimationProperty;
}());
exports.CssAnimationProperty = CssAnimationProperty;
CssAnimationProperty.prototype.isStyleProperty = true;
var InheritedCssProperty = (function (_super) {
    __extends(InheritedCssProperty, _super);
    function InheritedCssProperty(options) {
        var _this = _super.call(this, options) || this;
        var propertyName = options.name;
        var key = _this.key;
        var sourceKey = _this.sourceKey;
        var getDefault = _this.getDefault;
        var setNative = _this.setNative;
        var defaultValueKey = _this.defaultValueKey;
        var eventName = propertyName + "Change";
        var defaultValue = options.defaultValue;
        var affectsLayout = options.affectsLayout;
        var equalityComparer = options.equalityComparer;
        var valueChanged = options.valueChanged;
        var valueConverter = options.valueConverter;
        var property = _this;
        var setFunc = function (valueSource) { return function (boxedValue) {
            var reset = boxedValue === exports.unsetValue || boxedValue === "";
            var currentValueSource = this[sourceKey] || 0;
            if (reset) {
                if (valueSource === 2 && currentValueSource === 3) {
                    return;
                }
            }
            else {
                if (currentValueSource > valueSource) {
                    return;
                }
            }
            var oldValue = key in this ? this[key] : defaultValue;
            var view = this.view;
            var value;
            var unsetNativeValue = false;
            if (reset) {
                var parent_2 = view.parent;
                var style = parent_2 ? parent_2.style : null;
                if (style && style[sourceKey] > 0) {
                    value = style[propertyName];
                    this[sourceKey] = 1;
                    this[key] = value;
                }
                else {
                    value = defaultValue;
                    delete this[sourceKey];
                    delete this[key];
                    unsetNativeValue = true;
                }
            }
            else {
                this[sourceKey] = valueSource;
                if (valueConverter && typeof boxedValue === "string") {
                    value = valueConverter(boxedValue);
                }
                else {
                    value = boxedValue;
                }
                this[key] = value;
            }
            var changed = equalityComparer ? !equalityComparer(oldValue, value) : oldValue !== value;
            if (changed) {
                var view_1 = this.view;
                if (valueChanged) {
                    valueChanged(this, oldValue, value);
                }
                if (view_1[setNative]) {
                    if (view_1._suspendNativeUpdatesCount) {
                        if (view_1._suspendedUpdates) {
                            view_1._suspendedUpdates[propertyName] = property;
                        }
                    }
                    else {
                        if (unsetNativeValue) {
                            if (defaultValueKey in this) {
                                view_1[setNative](this[defaultValueKey]);
                                delete this[defaultValueKey];
                            }
                            else {
                                view_1[setNative](defaultValue);
                            }
                        }
                        else {
                            if (!(defaultValueKey in this)) {
                                this[defaultValueKey] = view_1[getDefault] ? view_1[getDefault]() : defaultValue;
                            }
                            view_1[setNative](value);
                        }
                    }
                }
                if (this.hasListeners(eventName)) {
                    this.notify({ object: this, eventName: eventName, propertyName: propertyName, value: value, oldValue: oldValue });
                }
                if (affectsLayout) {
                    view_1.requestLayout();
                }
                view_1.eachChild(function (child) {
                    var childStyle = child.style;
                    var childValueSource = childStyle[sourceKey] || 0;
                    if (reset) {
                        if (childValueSource === 1) {
                            setDefaultFunc.call(childStyle, exports.unsetValue);
                        }
                    }
                    else {
                        if (childValueSource <= 1) {
                            setInheritedFunc.call(childStyle, value);
                        }
                    }
                    return true;
                });
            }
        }; };
        var setDefaultFunc = setFunc(0);
        var setInheritedFunc = setFunc(1);
        _this.setInheritedValue = setInheritedFunc;
        _this.cssValueDescriptor.set = setFunc(2);
        _this.localValueDescriptor.set = setFunc(3);
        inheritableCssProperties.push(_this);
        return _this;
    }
    return InheritedCssProperty;
}(CssProperty));
exports.InheritedCssProperty = InheritedCssProperty;
var ShorthandProperty = (function () {
    function ShorthandProperty(options) {
        this.name = options.name;
        var key = Symbol(this.name + ":propertyKey");
        this.key = key;
        this.cssName = "css:" + options.cssName;
        this.cssLocalName = "" + options.cssName;
        var converter = options.converter;
        function setLocalValue(value) {
            var _this = this;
            this.view._batchUpdate(function () {
                for (var _i = 0, _a = converter(value); _i < _a.length; _i++) {
                    var _b = _a[_i], p = _b[0], v = _b[1];
                    _this[p.name] = v;
                }
            });
        }
        function setCssValue(value) {
            var _this = this;
            this.view._batchUpdate(function () {
                for (var _i = 0, _a = converter(value); _i < _a.length; _i++) {
                    var _b = _a[_i], p = _b[0], v = _b[1];
                    _this[p.cssName] = v;
                }
            });
        }
        this.cssValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: options.getter,
            set: setCssValue
        };
        this.localValueDescriptor = {
            enumerable: true,
            configurable: true,
            get: options.getter,
            set: setLocalValue
        };
        this.propertyBagDescriptor = {
            enumerable: false,
            configurable: true,
            set: function (value) {
                var _this = this;
                converter(value).forEach(function (_a) {
                    var property = _a[0], value = _a[1];
                    _this[property.cssLocalName] = value;
                });
            }
        };
        cssSymbolPropertyMap[key] = this;
    }
    ShorthandProperty.prototype.register = function (cls) {
        if (this.registered) {
            throw new Error("Property " + this.name + " already registered.");
        }
        this.registered = true;
        Object.defineProperty(cls.prototype, this.name, this.localValueDescriptor);
        Object.defineProperty(cls.prototype, this.cssName, this.cssValueDescriptor);
        if (this.cssLocalName !== this.cssName) {
            Object.defineProperty(cls.prototype, this.cssLocalName, this.localValueDescriptor);
        }
        Object.defineProperty(cls.prototype.PropertyBag, this.cssLocalName, this.propertyBagDescriptor);
    };
    return ShorthandProperty;
}());
exports.ShorthandProperty = ShorthandProperty;
function inheritablePropertyValuesOn(view) {
    var array = new Array();
    for (var _i = 0, inheritableProperties_1 = inheritableProperties; _i < inheritableProperties_1.length; _i++) {
        var prop = inheritableProperties_1[_i];
        var sourceKey = prop.sourceKey;
        var valueSource = view[sourceKey] || 0;
        if (valueSource !== 0) {
            array.push({ property: prop, value: view[prop.name] });
        }
    }
    return array;
}
function inheritableCssPropertyValuesOn(style) {
    var array = new Array();
    for (var _i = 0, inheritableCssProperties_1 = inheritableCssProperties; _i < inheritableCssProperties_1.length; _i++) {
        var prop = inheritableCssProperties_1[_i];
        var sourceKey = prop.sourceKey;
        var valueSource = style[sourceKey] || 0;
        if (valueSource !== 0) {
            array.push({ property: prop, value: style[prop.name] });
        }
    }
    return array;
}
exports.initNativeView = profiling_1.profile("\"properties\".initNativeView", function initNativeView(view) {
    if (view._suspendedUpdates) {
        applyPendingNativeSetters(view);
    }
    else {
        applyAllNativeSetters(view);
    }
    view._suspendedUpdates = {};
});
function applyPendingNativeSetters(view) {
    var suspendedUpdates = view._suspendedUpdates;
    for (var propertyName in suspendedUpdates) {
        var property = suspendedUpdates[propertyName];
        var setNative = property.setNative;
        if (view[setNative]) {
            var getDefault = property.getDefault, isStyleProperty = property.isStyleProperty, defaultValueKey = property.defaultValueKey, defaultValue = property.defaultValue;
            var value = void 0;
            if (isStyleProperty) {
                var style = view.style;
                if (property.isSet(view.style)) {
                    if (!(defaultValueKey in style)) {
                        style[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                    }
                    value = view.style[propertyName];
                }
                else {
                    value = style[defaultValueKey];
                }
            }
            else {
                if (property.isSet(view)) {
                    if (!(defaultValueKey in view)) {
                        view[defaultValueKey] = view[getDefault] ? view[getDefault]() : defaultValue;
                    }
                    value = view[propertyName];
                }
                else {
                    value = view[defaultValueKey];
                }
            }
            view[setNative](value);
        }
    }
}
exports.applyPendingNativeSetters = applyPendingNativeSetters;
function applyAllNativeSetters(view) {
    var symbols = Object.getOwnPropertySymbols(view);
    for (var _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {
        var symbol = symbols_2[_i];
        var property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        var setNative = property.setNative;
        var getDefault = property.getDefault;
        if (setNative in view) {
            var defaultValueKey = property.defaultValueKey;
            if (!(defaultValueKey in view)) {
                view[defaultValueKey] = view[getDefault] ? view[getDefault]() : property.defaultValue;
            }
            var value = view[symbol];
            view[setNative](value);
        }
    }
    var style = view.style;
    symbols = Object.getOwnPropertySymbols(style);
    for (var _a = 0, symbols_3 = symbols; _a < symbols_3.length; _a++) {
        var symbol = symbols_3[_a];
        var property = cssSymbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            var defaultValueKey = property.defaultValueKey;
            if (!(defaultValueKey in style)) {
                style[defaultValueKey] = view[property.getDefault] ? view[property.getDefault]() : property.defaultValue;
            }
            var value = style[symbol];
            view[property.setNative](value);
        }
    }
}
exports.applyAllNativeSetters = applyAllNativeSetters;
function resetNativeView(view) {
    var symbols = Object.getOwnPropertySymbols(view);
    for (var _i = 0, symbols_4 = symbols; _i < symbols_4.length; _i++) {
        var symbol = symbols_4[_i];
        var property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            if (property.defaultValueKey in view) {
                view[property.setNative](view[property.defaultValueKey]);
                delete view[property.defaultValueKey];
            }
            else {
                view[property.setNative](property.defaultValue);
            }
        }
    }
    var style = view.style;
    symbols = Object.getOwnPropertySymbols(style);
    for (var _a = 0, symbols_5 = symbols; _a < symbols_5.length; _a++) {
        var symbol = symbols_5[_a];
        var property = cssSymbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        if (view[property.setNative]) {
            if (property.defaultValueKey in style) {
                view[property.setNative](style[property.defaultValueKey]);
                delete style[property.defaultValueKey];
            }
            else {
                view[property.setNative](property.defaultValue);
            }
        }
    }
}
exports.resetNativeView = resetNativeView;
function clearInheritedProperties(view) {
    for (var _i = 0, inheritableProperties_2 = inheritableProperties; _i < inheritableProperties_2.length; _i++) {
        var prop = inheritableProperties_2[_i];
        var sourceKey = prop.sourceKey;
        if (view[sourceKey] === 1) {
            prop.set.call(view, exports.unsetValue);
        }
    }
    var style = view.style;
    for (var _a = 0, inheritableCssProperties_2 = inheritableCssProperties; _a < inheritableCssProperties_2.length; _a++) {
        var prop = inheritableCssProperties_2[_a];
        var sourceKey = prop.sourceKey;
        if (style[sourceKey] === 1) {
            prop.setInheritedValue.call(style, exports.unsetValue);
        }
    }
}
exports.clearInheritedProperties = clearInheritedProperties;
function resetCSSProperties(style) {
    var symbols = Object.getOwnPropertySymbols(style);
    for (var _i = 0, symbols_6 = symbols; _i < symbols_6.length; _i++) {
        var symbol = symbols_6[_i];
        var cssProperty = void 0;
        if (cssProperty = cssSymbolPropertyMap[symbol]) {
            style[cssProperty.cssName] = exports.unsetValue;
            if (cssProperty instanceof CssAnimationProperty) {
                style[cssProperty.keyframe] = exports.unsetValue;
            }
        }
    }
}
exports.resetCSSProperties = resetCSSProperties;
function propagateInheritableProperties(view, child) {
    var inheritablePropertyValues = inheritablePropertyValuesOn(view);
    for (var _i = 0, inheritablePropertyValues_1 = inheritablePropertyValues; _i < inheritablePropertyValues_1.length; _i++) {
        var pair = inheritablePropertyValues_1[_i];
        var prop = pair.property;
        var sourceKey = prop.sourceKey;
        var currentValueSource = child[sourceKey] || 0;
        if (currentValueSource <= 1) {
            prop.setInheritedValue.call(child, pair.value);
        }
    }
}
exports.propagateInheritableProperties = propagateInheritableProperties;
function propagateInheritableCssProperties(parentStyle, childStyle) {
    var inheritableCssPropertyValues = inheritableCssPropertyValuesOn(parentStyle);
    for (var _i = 0, inheritableCssPropertyValues_1 = inheritableCssPropertyValues; _i < inheritableCssPropertyValues_1.length; _i++) {
        var pair = inheritableCssPropertyValues_1[_i];
        var prop = pair.property;
        var sourceKey = prop.sourceKey;
        var currentValueSource = childStyle[sourceKey] || 0;
        if (currentValueSource <= 1) {
            prop.setInheritedValue.call(childStyle, pair.value, 1);
        }
    }
}
exports.propagateInheritableCssProperties = propagateInheritableCssProperties;
function makeValidator() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    var set = new Set(values);
    return function (value) { return set.has(value); };
}
exports.makeValidator = makeValidator;
function makeParser(isValid) {
    return function (value) {
        var lower = value && value.toLowerCase();
        if (isValid(lower)) {
            return lower;
        }
        else {
            throw new Error("Invalid value: " + value);
        }
    };
}
exports.makeParser = makeParser;
function getSetProperties(view) {
    var result = [];
    Object.getOwnPropertyNames(view).forEach(function (prop) {
        result.push([prop, view[prop]]);
    });
    var symbols = Object.getOwnPropertySymbols(view);
    for (var _i = 0, symbols_7 = symbols; _i < symbols_7.length; _i++) {
        var symbol = symbols_7[_i];
        var property = symbolPropertyMap[symbol];
        if (!property) {
            continue;
        }
        var value = view[property.key];
        result.push([property.name, value]);
    }
    return result;
}
exports.getSetProperties = getSetProperties;
function getComputedCssValues(view) {
    var result = [];
    var style = view.style;
    for (var _i = 0, cssPropertyNames_1 = cssPropertyNames; _i < cssPropertyNames_1.length; _i++) {
        var prop = cssPropertyNames_1[_i];
        result.push([prop, style[prop]]);
    }
    result.push(["top", "auto"]);
    result.push(["left", "auto"]);
    result.push(["bottom", "auto"]);
    result.push(["right", "auto"]);
    return result;
}
exports.getComputedCssValues = getComputedCssValues;
//# sourceMappingURL=properties.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/view-base/view-base.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var debug_1 = __webpack_require__("../node_modules/tns-core-modules/utils/debug.js");
var bindable_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/bindable/bindable.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
exports.isIOS = platform_1.isIOS;
exports.isAndroid = platform_1.isAndroid;
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
exports.layout = utils_1.layout;
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
exports.Color = color_1.Color;
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/bindable/bindable.js"));
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js"));
var ssm = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-scope.js");
var domNodeModule;
function ensuredomNodeModule() {
    if (!domNodeModule) {
        domNodeModule = __webpack_require__("../node_modules/tns-core-modules/debugger/dom-node.js");
    }
}
var styleScopeModule;
function ensureStyleScopeModule() {
    if (!styleScopeModule) {
        styleScopeModule = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-scope.js");
    }
}
var defaultBindingSource = {};
function getAncestor(view, criterion) {
    var matcher = null;
    if (typeof criterion === "string") {
        matcher = function (view) { return view.typeName === criterion; };
    }
    else {
        matcher = function (view) { return view instanceof criterion; };
    }
    for (var parent_1 = view.parent; parent_1 != null; parent_1 = parent_1.parent) {
        if (matcher(parent_1)) {
            return parent_1;
        }
    }
    return null;
}
exports.getAncestor = getAncestor;
function getViewById(view, id) {
    if (!view) {
        return undefined;
    }
    if (view.id === id) {
        return view;
    }
    var retVal;
    var descendantsCallback = function (child) {
        if (child.id === id) {
            retVal = child;
            return false;
        }
        return true;
    };
    eachDescendant(view, descendantsCallback);
    return retVal;
}
exports.getViewById = getViewById;
function eachDescendant(view, callback) {
    if (!callback || !view) {
        return;
    }
    var continueIteration;
    var localCallback = function (child) {
        continueIteration = callback(child);
        if (continueIteration) {
            child.eachChild(localCallback);
        }
        return continueIteration;
    };
    view.eachChild(localCallback);
}
exports.eachDescendant = eachDescendant;
var viewIdCounter = 1;
var Flags;
(function (Flags) {
    Flags["superOnLoadedCalled"] = "Loaded";
    Flags["superOnUnloadedCalled"] = "Unloaded";
})(Flags || (Flags = {}));
var SuspendType;
(function (SuspendType) {
    SuspendType[SuspendType["Incremental"] = 0] = "Incremental";
    SuspendType[SuspendType["Loaded"] = 1048576] = "Loaded";
    SuspendType[SuspendType["NativeView"] = 2097152] = "NativeView";
    SuspendType[SuspendType["UISetup"] = 4194304] = "UISetup";
    SuspendType[SuspendType["IncrementalCountMask"] = -7340033] = "IncrementalCountMask";
})(SuspendType || (SuspendType = {}));
(function (SuspendType) {
    function toString(type) {
        return (type ? "suspended" : "resumed") + "(" +
            "Incremental: " + (type & SuspendType.IncrementalCountMask) + ", " +
            "Loaded: " + !(type & SuspendType.Loaded) + ", " +
            "NativeView: " + !(type & SuspendType.NativeView) + ", " +
            "UISetup: " + !(type & SuspendType.UISetup) +
            ")";
    }
    SuspendType.toString = toString;
})(SuspendType || (SuspendType = {}));
var ViewBase = (function (_super) {
    __extends(ViewBase, _super);
    function ViewBase() {
        var _this = _super.call(this) || this;
        _this._onLoadedCalled = false;
        _this._onUnloadedCalled = false;
        _this._cssState = new ssm.CssState(_this);
        _this.pseudoClassAliases = {
            "highlighted": [
                "active",
                "pressed"
            ]
        };
        _this.cssClasses = new Set();
        _this.cssPseudoClasses = new Set();
        _this._domId = viewIdCounter++;
        _this._style = new properties_1.Style(_this);
        return _this;
    }
    Object.defineProperty(ViewBase.prototype, "parentNode", {
        get: function () {
            return this._templateParent || this.parent;
        },
        set: function (node) {
            this._templateParent = node;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "nativeView", {
        get: function () {
            return this.nativeViewProtected;
        },
        set: function (value) {
            this.setNativeView(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "typeName", {
        get: function () {
            return types.getClass(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "style", {
        get: function () {
            return this._style;
        },
        set: function (inlineStyle) {
            if (typeof inlineStyle === "string") {
                this.setInlineStyle(inlineStyle);
            }
            else {
                throw new Error("View.style property is read-only.");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "android", {
        get: function () {
            return this._androidView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "ios", {
        get: function () {
            return this._iosView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "isLoaded", {
        get: function () {
            return this._isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewBase.prototype, "class", {
        get: function () {
            return this.className;
        },
        set: function (v) {
            this.className = v;
        },
        enumerable: true,
        configurable: true
    });
    ViewBase.prototype.getViewById = function (id) {
        return getViewById(this, id);
    };
    Object.defineProperty(ViewBase.prototype, "page", {
        get: function () {
            if (this.parent) {
                return this.parent.page;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    ViewBase.prototype.ensureDomNode = function () {
        if (!this.domNode) {
            ensuredomNodeModule();
            this.domNode = new domNodeModule.DOMNode(this);
        }
    };
    ViewBase.prototype.set = function (name, value) {
        this[name] = bindable_1.WrappedValue.unwrap(value);
    };
    ViewBase.prototype.onLoaded = function () {
        var _this = this;
        this.setFlag(Flags.superOnLoadedCalled, true);
        if (this._isLoaded) {
            return;
        }
        this._isLoaded = true;
        this._cssState.onLoaded();
        this._resumeNativeUpdates(SuspendType.Loaded);
        this.eachChild(function (child) {
            _this.loadView(child);
            return true;
        });
        this._emit("loaded");
    };
    ViewBase.prototype.onUnloaded = function () {
        var _this = this;
        this.setFlag(Flags.superOnUnloadedCalled, true);
        if (!this._isLoaded) {
            return;
        }
        this._suspendNativeUpdates(SuspendType.Loaded);
        this.eachChild(function (child) {
            _this.unloadView(child);
            return true;
        });
        this._isLoaded = false;
        this._cssState.onUnloaded();
        this._emit("unloaded");
    };
    ViewBase.prototype._suspendNativeUpdates = function (type) {
        if (type) {
            this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount | type;
        }
        else {
            this._suspendNativeUpdatesCount++;
        }
    };
    ViewBase.prototype._resumeNativeUpdates = function (type) {
        if (type) {
            this._suspendNativeUpdatesCount = this._suspendNativeUpdatesCount & ~type;
        }
        else {
            if ((this._suspendNativeUpdatesCount & SuspendType.IncrementalCountMask) === 0) {
                throw new Error("Invalid call to " + this + "._resumeNativeUpdates");
            }
            this._suspendNativeUpdatesCount--;
        }
        if (!this._suspendNativeUpdatesCount) {
            this.onResumeNativeUpdates();
        }
    };
    ViewBase.prototype._batchUpdate = function (callback) {
        try {
            this._suspendNativeUpdates(SuspendType.Incremental);
            return callback();
        }
        finally {
            this._resumeNativeUpdates(SuspendType.Incremental);
        }
    };
    ViewBase.prototype.setFlag = function (flag, value) {
        switch (flag) {
            case Flags.superOnLoadedCalled:
                this._onLoadedCalled = value;
                break;
            case Flags.superOnUnloadedCalled:
                this._onUnloadedCalled = value;
                break;
        }
    };
    ViewBase.prototype.isFlagSet = function (flag) {
        switch (flag) {
            case Flags.superOnLoadedCalled:
                return this._onLoadedCalled;
            case Flags.superOnUnloadedCalled:
                return this._onUnloadedCalled;
        }
    };
    ViewBase.prototype.callFunctionWithSuper = function (flag, func) {
        this.setFlag(flag, false);
        func();
        if (!this.isFlagSet(flag)) {
            throw new Error("super." + flag + " not called in " + this);
        }
    };
    ViewBase.prototype.callLoaded = function () {
        var _this = this;
        this.callFunctionWithSuper(Flags.superOnLoadedCalled, function () { return _this.onLoaded(); });
    };
    ViewBase.prototype.callUnloaded = function () {
        var _this = this;
        this.callFunctionWithSuper(Flags.superOnUnloadedCalled, function () { return _this.onUnloaded(); });
    };
    ViewBase.prototype.notifyPseudoClassChanged = function (pseudoClass) {
        this.notify({ eventName: ":" + pseudoClass, object: this });
    };
    ViewBase.prototype.getAllAliasedStates = function (name) {
        var allStates = [];
        allStates.push(name);
        if (name in this.pseudoClassAliases) {
            for (var i = 0; i < this.pseudoClassAliases[name].length; i++) {
                allStates.push(this.pseudoClassAliases[name][i]);
            }
        }
        return allStates;
    };
    ViewBase.prototype.addPseudoClass = function (name) {
        var allStates = this.getAllAliasedStates(name);
        for (var i = 0; i < allStates.length; i++) {
            if (!this.cssPseudoClasses.has(allStates[i])) {
                this.cssPseudoClasses.add(allStates[i]);
                this.notifyPseudoClassChanged(allStates[i]);
            }
        }
    };
    ViewBase.prototype.deletePseudoClass = function (name) {
        var allStates = this.getAllAliasedStates(name);
        for (var i = 0; i < allStates.length; i++) {
            if (this.cssPseudoClasses.has(allStates[i])) {
                this.cssPseudoClasses.delete(allStates[i]);
                this.notifyPseudoClassChanged(allStates[i]);
            }
        }
    };
    ViewBase.prototype.bindingContextChanged = function (data) {
        this.bindings.get("bindingContext").bind(data.value);
    };
    ViewBase.prototype.bind = function (options, source) {
        if (source === void 0) { source = defaultBindingSource; }
        var targetProperty = options.targetProperty;
        this.unbind(targetProperty);
        if (!this.bindings) {
            this.bindings = new Map();
        }
        var binding = new bindable_1.Binding(this, options);
        this.bindings.set(targetProperty, binding);
        var bindingSource = source;
        if (bindingSource === defaultBindingSource) {
            bindingSource = this.bindingContext;
            binding.sourceIsBindingContext = true;
            if (targetProperty === "bindingContext") {
                this.bindingContextBoundToParentBindingContextChanged = true;
                var parent_2 = this.parent;
                if (parent_2) {
                    parent_2.on("bindingContextChange", this.bindingContextChanged, this);
                }
                else {
                    this.shouldAddHandlerToParentBindingContextChanged = true;
                }
            }
        }
        binding.bind(bindingSource);
    };
    ViewBase.prototype.unbind = function (property) {
        var bindings = this.bindings;
        if (!bindings) {
            return;
        }
        var binding = bindings.get(property);
        if (binding) {
            binding.unbind();
            bindings.delete(property);
            if (binding.sourceIsBindingContext) {
                if (property === "bindingContext") {
                    this.shouldAddHandlerToParentBindingContextChanged = false;
                    this.bindingContextBoundToParentBindingContextChanged = false;
                    var parent_3 = this.parent;
                    if (parent_3) {
                        parent_3.off("bindingContextChange", this.bindingContextChanged, this);
                    }
                }
            }
        }
    };
    ViewBase.prototype.requestLayout = function () {
        var parent = this.parent;
        if (parent) {
            parent.requestLayout();
        }
    };
    ViewBase.prototype.eachChild = function (callback) {
    };
    ViewBase.prototype._addView = function (view, atIndex) {
        if (bindable_1.traceEnabled()) {
            bindable_1.traceWrite(this + "._addView(" + view + ", " + atIndex + ")", bindable_1.traceCategories.ViewHierarchy);
        }
        if (!view) {
            throw new Error("Expecting a valid View instance.");
        }
        if (!(view instanceof ViewBase)) {
            throw new Error(view + " is not a valid View instance.");
        }
        if (view.parent) {
            throw new Error("View already has a parent. View: " + view + " Parent: " + view.parent);
        }
        view.parent = this;
        this._addViewCore(view, atIndex);
        view._parentChanged(null);
        if (this.domNode) {
            this.domNode.onChildAdded(view);
        }
    };
    ViewBase.prototype._addViewCore = function (view, atIndex) {
        properties_1.propagateInheritableProperties(this, view);
        view._inheritStyleScope(this._styleScope);
        properties_1.propagateInheritableCssProperties(this.style, view.style);
        if (this._context) {
            view._setupUI(this._context, atIndex);
        }
        if (this._isLoaded) {
            this.loadView(view);
        }
    };
    ViewBase.prototype.loadView = function (view) {
        if (view && !view.isLoaded) {
            view.callLoaded();
        }
    };
    ViewBase.prototype.unloadView = function (view) {
        if (view && view.isLoaded) {
            view.callUnloaded();
        }
    };
    ViewBase.prototype._removeView = function (view) {
        if (bindable_1.traceEnabled()) {
            bindable_1.traceWrite(this + "._removeView(" + view + ")", bindable_1.traceCategories.ViewHierarchy);
        }
        if (view.parent !== this) {
            throw new Error("View not added to this instance. View: " + view + " CurrentParent: " + view.parent + " ExpectedParent: " + this);
        }
        if (this.domNode) {
            this.domNode.onChildRemoved(view);
        }
        this._removeViewCore(view);
        view.parent = undefined;
        view._parentChanged(this);
    };
    ViewBase.prototype._removeViewCore = function (view) {
        this.unloadView(view);
        if (view._context) {
            view._tearDownUI();
        }
    };
    ViewBase.prototype.createNativeView = function () {
        return undefined;
    };
    ViewBase.prototype.disposeNativeView = function () {
    };
    ViewBase.prototype.initNativeView = function () {
    };
    ViewBase.prototype.resetNativeView = function () {
    };
    ViewBase.prototype.resetNativeViewInternal = function () {
    };
    ViewBase.prototype._setupAsRootView = function (context) {
        this._setupUI(context);
    };
    ViewBase.prototype._setupUI = function (context, atIndex, parentIsLoaded) {
        if (this._context === context) {
            return;
        }
        else if (this._context) {
            this._tearDownUI(true);
        }
        this._context = context;
        var nativeView = this.nativeViewProtected;
        if (!nativeView) {
            nativeView = this.createNativeView();
        }
        if (platform_1.isAndroid) {
            this._androidView = nativeView;
            if (nativeView) {
                if (this._isPaddingRelative === undefined) {
                    this._isPaddingRelative = nativeView.isPaddingRelative();
                }
                var result = nativeView.defaultPaddings;
                if (result === undefined) {
                    result = org.nativescript.widgets.ViewHelper.getPadding(nativeView);
                    nativeView.defaultPaddings = result;
                }
                this._defaultPaddingTop = result.top;
                this._defaultPaddingRight = result.right;
                this._defaultPaddingBottom = result.bottom;
                this._defaultPaddingLeft = result.left;
                var style = this.style;
                if (!style_properties_1.paddingTopProperty.isSet(style)) {
                    this.effectivePaddingTop = this._defaultPaddingTop;
                }
                if (!style_properties_1.paddingRightProperty.isSet(style)) {
                    this.effectivePaddingRight = this._defaultPaddingRight;
                }
                if (!style_properties_1.paddingBottomProperty.isSet(style)) {
                    this.effectivePaddingBottom = this._defaultPaddingBottom;
                }
                if (!style_properties_1.paddingLeftProperty.isSet(style)) {
                    this.effectivePaddingLeft = this._defaultPaddingLeft;
                }
            }
        }
        else {
            this._iosView = nativeView;
        }
        this.setNativeView(nativeView);
        if (this.parent) {
            var nativeIndex = this.parent._childIndexToNativeChildIndex(atIndex);
            this._isAddedToNativeVisualTree = this.parent._addViewToNativeVisualTree(this, nativeIndex);
        }
        this._resumeNativeUpdates(SuspendType.UISetup);
        this.eachChild(function (child) {
            child._setupUI(context);
            return true;
        });
    };
    ViewBase.prototype.setNativeView = function (value) {
        if (this.__nativeView === value) {
            return;
        }
        if (this.__nativeView) {
            this._suspendNativeUpdates(SuspendType.NativeView);
        }
        this.__nativeView = this.nativeViewProtected = value;
        if (this.__nativeView) {
            this._suspendedUpdates = undefined;
            this.initNativeView();
            this._resumeNativeUpdates(SuspendType.NativeView);
        }
    };
    ViewBase.prototype._tearDownUI = function (force) {
        if (!this._context) {
            return;
        }
        this.resetNativeViewInternal();
        this.eachChild(function (child) {
            child._tearDownUI(force);
            return true;
        });
        if (this.parent) {
            this.parent._removeViewFromNativeVisualTree(this);
        }
        this.disposeNativeView();
        this._suspendNativeUpdates(SuspendType.UISetup);
        if (platform_1.isAndroid) {
            this.setNativeView(null);
            this._androidView = null;
        }
        this._context = null;
        if (this.domNode) {
            this.domNode.dispose();
            this.domNode = undefined;
        }
    };
    ViewBase.prototype._childIndexToNativeChildIndex = function (index) {
        return index;
    };
    ViewBase.prototype._addViewToNativeVisualTree = function (view, atIndex) {
        if (view._isAddedToNativeVisualTree) {
            throw new Error("Child already added to the native visual tree.");
        }
        return true;
    };
    ViewBase.prototype._removeViewFromNativeVisualTree = function (view) {
        view._isAddedToNativeVisualTree = false;
    };
    ViewBase.prototype._goToVisualState = function (state) {
        if (bindable_1.traceEnabled()) {
            bindable_1.traceWrite(this + " going to state: " + state, bindable_1.traceCategories.Style);
        }
        if (state === this._visualState) {
            return;
        }
        this.deletePseudoClass(this._visualState);
        this._visualState = state;
        this.addPseudoClass(state);
    };
    ViewBase.prototype._applyXmlAttribute = function (attribute, value) {
        if (attribute === "style" || attribute === "rows" || attribute === "columns" || attribute === "fontAttributes") {
            this[attribute] = value;
            return true;
        }
        return false;
    };
    ViewBase.prototype.setInlineStyle = function (style) {
        if (typeof style !== "string") {
            throw new Error("Parameter should be valid CSS string!");
        }
        ensureStyleScopeModule();
        styleScopeModule.applyInlineStyle(this, style);
    };
    ViewBase.prototype._parentChanged = function (oldParent) {
        var newParent = this.parent;
        if (oldParent) {
            properties_1.clearInheritedProperties(this);
            if (this.bindingContextBoundToParentBindingContextChanged) {
                oldParent.off("bindingContextChange", this.bindingContextChanged, this);
            }
        }
        else if (this.shouldAddHandlerToParentBindingContextChanged) {
            newParent.on("bindingContextChange", this.bindingContextChanged, this);
            this.bindings.get("bindingContext").bind(newParent.bindingContext);
        }
    };
    ViewBase.prototype.onResumeNativeUpdates = function () {
        properties_1.initNativeView(this);
    };
    ViewBase.prototype.toString = function () {
        var str = this.typeName;
        if (this.id) {
            str += "<" + this.id + ">";
        }
        else {
            str += "(" + this._domId + ")";
        }
        var source = debug_1.Source.get(this);
        if (source) {
            str += "@" + source + ";";
        }
        return str;
    };
    ViewBase.prototype._onCssStateChange = function () {
        this._cssState.onChange();
        eachDescendant(this, function (child) {
            child._cssState.onChange();
            return true;
        });
    };
    ViewBase.prototype._inheritStyleScope = function (styleScope) {
        if (this._isStyleScopeHost) {
            return;
        }
        if (this._styleScope !== styleScope) {
            this._styleScope = styleScope;
            this._onCssStateChange();
            this.eachChild(function (child) {
                child._inheritStyleScope(styleScope);
                return true;
            });
        }
    };
    ViewBase.prototype.showModal = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var parent = this.parent;
        return parent && parent.showModal.apply(parent, args);
    };
    ViewBase.prototype.closeModal = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var parent = this.parent;
        if (parent) {
            parent.closeModal.apply(parent, args);
        }
    };
    ViewBase.prototype._dialogClosed = function () {
        eachDescendant(this, function (child) {
            child._dialogClosed();
            return true;
        });
    };
    ViewBase.prototype._onRootViewReset = function () {
        eachDescendant(this, function (child) {
            child._onRootViewReset();
            return true;
        });
    };
    ViewBase.loadedEvent = "loaded";
    ViewBase.unloadedEvent = "unloaded";
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "onLoaded", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "onUnloaded", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "addPseudoClass", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "deletePseudoClass", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "requestLayout", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "_addView", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "_setupUI", null);
    __decorate([
        profiling_1.profile
    ], ViewBase.prototype, "_tearDownUI", null);
    return ViewBase;
}(bindable_1.Observable));
exports.ViewBase = ViewBase;
ViewBase.prototype.isCollapsed = false;
ViewBase.prototype._oldLeft = 0;
ViewBase.prototype._oldTop = 0;
ViewBase.prototype._oldRight = 0;
ViewBase.prototype._oldBottom = 0;
ViewBase.prototype.effectiveMinWidth = 0;
ViewBase.prototype.effectiveMinHeight = 0;
ViewBase.prototype.effectiveWidth = 0;
ViewBase.prototype.effectiveHeight = 0;
ViewBase.prototype.effectiveMarginTop = 0;
ViewBase.prototype.effectiveMarginRight = 0;
ViewBase.prototype.effectiveMarginBottom = 0;
ViewBase.prototype.effectiveMarginLeft = 0;
ViewBase.prototype.effectivePaddingTop = 0;
ViewBase.prototype.effectivePaddingRight = 0;
ViewBase.prototype.effectivePaddingBottom = 0;
ViewBase.prototype.effectivePaddingLeft = 0;
ViewBase.prototype.effectiveBorderTopWidth = 0;
ViewBase.prototype.effectiveBorderRightWidth = 0;
ViewBase.prototype.effectiveBorderBottomWidth = 0;
ViewBase.prototype.effectiveBorderLeftWidth = 0;
ViewBase.prototype._defaultPaddingTop = 0;
ViewBase.prototype._defaultPaddingRight = 0;
ViewBase.prototype._defaultPaddingBottom = 0;
ViewBase.prototype._defaultPaddingLeft = 0;
ViewBase.prototype._isViewBase = true;
ViewBase.prototype.recycleNativeView = "never";
ViewBase.prototype._suspendNativeUpdatesCount =
    SuspendType.Loaded |
        SuspendType.NativeView |
        SuspendType.UISetup;
exports.bindingContextProperty = new properties_1.InheritedProperty({ name: "bindingContext" });
exports.bindingContextProperty.register(ViewBase);
exports.classNameProperty = new properties_1.Property({
    name: "className",
    valueChanged: function (view, oldValue, newValue) {
        var classes = view.cssClasses;
        classes.clear();
        if (typeof newValue === "string" && newValue !== "") {
            newValue.split(" ").forEach(function (c) { return classes.add(c); });
        }
        view._onCssStateChange();
    }
});
exports.classNameProperty.register(ViewBase);
exports.idProperty = new properties_1.Property({ name: "id", valueChanged: function (view, oldValue, newValue) { return view._onCssStateChange(); } });
exports.idProperty.register(ViewBase);
function booleanConverter(v) {
    var lowercase = (v + "").toLowerCase();
    if (lowercase === "true") {
        return true;
    }
    else if (lowercase === "false") {
        return false;
    }
    throw new Error("Invalid boolean: " + v);
}
exports.booleanConverter = booleanConverter;
//# sourceMappingURL=view-base.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/view/view-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var view_base_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view-base/view-base.js");
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
var gestures_1 = __webpack_require__("../node_modules/tns-core-modules/ui/gestures/gestures.js");
var builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/builder.js");
var style_scope_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-scope.js");
var linear_gradient_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/linear-gradient.js");
exports.LinearGradient = linear_gradient_1.LinearGradient;
__export(__webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js"));
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/view-base/view-base.js"));
var animationModule;
function ensureAnimationModule() {
    if (!animationModule) {
        animationModule = __webpack_require__("../node_modules/tns-core-modules/ui/animation/animation.js");
    }
}
function CSSType(type) {
    return function (cls) {
        cls.prototype.cssType = type;
    };
}
exports.CSSType = CSSType;
function viewMatchesModuleContext(view, context, types) {
    return context &&
        view._moduleName &&
        context.type &&
        types.some(function (type) { return type === context.type; }) &&
        context.path &&
        context.path.includes(view._moduleName);
}
exports.viewMatchesModuleContext = viewMatchesModuleContext;
function PseudoClassHandler() {
    var pseudoClasses = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        pseudoClasses[_i] = arguments[_i];
    }
    var stateEventNames = pseudoClasses.map(function (s) { return ":" + s; });
    var listeners = Symbol("listeners");
    return function (target, propertyKey, descriptor) {
        function update(change) {
            var prev = this[listeners] || 0;
            var next = prev + change;
            if (prev <= 0 && next > 0) {
                this[propertyKey](true);
            }
            else if (prev > 0 && next <= 0) {
                this[propertyKey](false);
            }
        }
        stateEventNames.forEach(function (s) { return target[s] = update; });
    };
}
exports.PseudoClassHandler = PseudoClassHandler;
exports._rootModalViews = new Array();
var ViewCommon = (function (_super) {
    __extends(ViewCommon, _super);
    function ViewCommon() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._gestureObservers = {};
        return _this;
    }
    Object.defineProperty(ViewCommon.prototype, "css", {
        get: function () {
            var scope = this._styleScope;
            return scope && scope.css;
        },
        set: function (value) {
            this._updateStyleScope(undefined, undefined, value);
        },
        enumerable: true,
        configurable: true
    });
    ViewCommon.prototype.addCss = function (cssString) {
        this._updateStyleScope(undefined, cssString);
    };
    ViewCommon.prototype.addCssFile = function (cssFileName) {
        this._updateStyleScope(cssFileName);
    };
    ViewCommon.prototype.changeCssFile = function (cssFileName) {
        var scope = this._styleScope;
        if (scope && cssFileName) {
            scope.changeCssFile(cssFileName);
            this._onCssStateChange();
        }
    };
    ViewCommon.prototype._updateStyleScope = function (cssFileName, cssString, css) {
        var scope = this._styleScope;
        if (!scope) {
            scope = new style_scope_1.StyleScope();
            this.setScopeProperty(scope, cssFileName, cssString, css);
            this._inheritStyleScope(scope);
            this._isStyleScopeHost = true;
        }
        else {
            this.setScopeProperty(scope, cssFileName, cssString, css);
            this._onCssStateChange();
        }
    };
    ViewCommon.prototype.setScopeProperty = function (scope, cssFileName, cssString, css) {
        if (cssFileName !== undefined) {
            scope.addCssFile(cssFileName);
        }
        else if (cssString !== undefined) {
            scope.addCss(cssString);
        }
        else if (css !== undefined) {
            scope.css = css;
        }
    };
    ViewCommon.prototype._onLivesync = function (context) {
        if (view_base_1.traceEnabled()) {
            view_base_1.traceWrite(this + "._onLivesync(" + JSON.stringify(context) + ")", view_base_1.traceCategories.Livesync);
        }
        if (this._handleLivesync(context)) {
            return true;
        }
        var handled = false;
        this.eachChildView(function (child) {
            if (child._onLivesync(context)) {
                handled = true;
                return false;
            }
        });
        return handled;
    };
    ViewCommon.prototype._handleLivesync = function (context) {
        if (view_base_1.traceEnabled()) {
            view_base_1.traceWrite(this + "._handleLivesync(" + JSON.stringify(context) + ")", view_base_1.traceCategories.Livesync);
        }
        if (viewMatchesModuleContext(this, context, ["style"])) {
            if (view_base_1.traceEnabled()) {
                view_base_1.traceWrite("Change Handled: Changing CSS for " + this, view_base_1.traceCategories.Livesync);
            }
            this.changeCssFile(context.path);
            return true;
        }
        return false;
    };
    ViewCommon.prototype._setupAsRootView = function (context) {
        _super.prototype._setupAsRootView.call(this, context);
        if (!this._styleScope) {
            this._updateStyleScope();
        }
    };
    ViewCommon.prototype.observe = function (type, callback, thisArg) {
        if (!this._gestureObservers[type]) {
            this._gestureObservers[type] = [];
        }
        this._gestureObservers[type].push(gestures_1.observe(this, type, callback, thisArg));
    };
    ViewCommon.prototype.getGestureObservers = function (type) {
        return this._gestureObservers[type];
    };
    ViewCommon.prototype.addEventListener = function (arg, callback, thisArg) {
        if (typeof arg === "string") {
            arg = view_base_1.getEventOrGestureName(arg);
            var gesture = gestures_1.fromString(arg);
            if (gesture && !this._isEvent(arg)) {
                this.observe(gesture, callback, thisArg);
            }
            else {
                var events = (arg).split(",");
                if (events.length > 0) {
                    for (var i = 0; i < events.length; i++) {
                        var evt = events[i].trim();
                        var gst = gestures_1.fromString(evt);
                        if (gst && !this._isEvent(arg)) {
                            this.observe(gst, callback, thisArg);
                        }
                        else {
                            _super.prototype.addEventListener.call(this, evt, callback, thisArg);
                        }
                    }
                }
                else {
                    _super.prototype.addEventListener.call(this, arg, callback, thisArg);
                }
            }
        }
        else if (typeof arg === "number") {
            this.observe(arg, callback, thisArg);
        }
    };
    ViewCommon.prototype.removeEventListener = function (arg, callback, thisArg) {
        if (typeof arg === "string") {
            var gesture = gestures_1.fromString(arg);
            if (gesture && !this._isEvent(arg)) {
                this._disconnectGestureObservers(gesture);
            }
            else {
                var events = arg.split(",");
                if (events.length > 0) {
                    for (var i = 0; i < events.length; i++) {
                        var evt = events[i].trim();
                        var gst = gestures_1.fromString(evt);
                        if (gst && !this._isEvent(arg)) {
                            this._disconnectGestureObservers(gst);
                        }
                        else {
                            _super.prototype.removeEventListener.call(this, evt, callback, thisArg);
                        }
                    }
                }
                else {
                    _super.prototype.removeEventListener.call(this, arg, callback, thisArg);
                }
            }
        }
        else if (typeof arg === "number") {
            this._disconnectGestureObservers(arg);
        }
    };
    ViewCommon.prototype.onBackPressed = function () {
        return false;
    };
    ViewCommon.prototype._getFragmentManager = function () {
        return undefined;
    };
    ViewCommon.prototype.getModalOptions = function (args) {
        if (args.length === 0) {
            throw new Error("showModal without parameters is deprecated. Please call showModal on a view instance instead.");
        }
        else {
            var options = null;
            if (args.length === 2) {
                options = args[1];
            }
            else {
                if (args[0] instanceof ViewCommon) {
                    console.log("showModal(view: ViewBase, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) " +
                        "is deprecated. Use showModal(view: ViewBase, modalOptions: ShowModalOptions) instead.");
                }
                else {
                    console.log("showModal(moduleName: string, context: any, closeCallback: Function, fullscreen?: boolean, animated?: boolean, stretched?: boolean) " +
                        "is deprecated. Use showModal(moduleName: string, modalOptions: ShowModalOptions) instead.");
                }
                options = {
                    context: args[1],
                    closeCallback: args[2],
                    fullscreen: args[3],
                    animated: args[4],
                    stretched: args[5]
                };
            }
            var firstArgument = args[0];
            var view = firstArgument instanceof ViewCommon
                ? firstArgument : builder_1.createViewFromEntry({ moduleName: firstArgument });
            return { view: view, options: options };
        }
    };
    ViewCommon.prototype.showModal = function () {
        var _a = this.getModalOptions(arguments), view = _a.view, options = _a.options;
        view._showNativeModalView(this, options);
        return view;
    };
    ViewCommon.prototype.closeModal = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var closeCallback = this._closeModalCallback;
        if (closeCallback) {
            closeCallback.apply(undefined, arguments);
        }
        else {
            var parent_1 = this.parent;
            if (parent_1) {
                parent_1.closeModal.apply(parent_1, args);
            }
        }
    };
    Object.defineProperty(ViewCommon.prototype, "modal", {
        get: function () {
            return this._modal;
        },
        enumerable: true,
        configurable: true
    });
    ViewCommon.prototype._showNativeModalView = function (parent, options) {
        exports._rootModalViews.push(this);
        parent._modal = this;
        this._modalParent = parent;
        this._modalContext = options.context;
        var that = this;
        this._closeModalCallback = function () {
            var originalArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                originalArgs[_i] = arguments[_i];
            }
            if (that._closeModalCallback) {
                var modalIndex = exports._rootModalViews.indexOf(that);
                exports._rootModalViews.splice(modalIndex);
                that._modalParent = null;
                that._modalContext = null;
                that._closeModalCallback = null;
                that._dialogClosed();
                parent._modal = null;
                var whenClosedCallback = function () {
                    if (typeof options.closeCallback === "function") {
                        options.closeCallback.apply(undefined, originalArgs);
                    }
                };
                that._hideNativeModalView(parent, whenClosedCallback);
            }
        };
    };
    ViewCommon.prototype._raiseLayoutChangedEvent = function () {
        var args = {
            eventName: ViewCommon.layoutChangedEvent,
            object: this
        };
        this.notify(args);
    };
    ViewCommon.prototype._raiseShownModallyEvent = function () {
        var args = {
            eventName: ViewCommon.shownModallyEvent,
            object: this,
            context: this._modalContext,
            closeCallback: this._closeModalCallback
        };
        this.notify(args);
    };
    ViewCommon.prototype._raiseShowingModallyEvent = function () {
        var args = {
            eventName: ViewCommon.showingModallyEvent,
            object: this,
            context: this._modalContext,
            closeCallback: this._closeModalCallback
        };
        this.notify(args);
    };
    ViewCommon.prototype._isEvent = function (name) {
        return this.constructor && name + "Event" in this.constructor;
    };
    ViewCommon.prototype._disconnectGestureObservers = function (type) {
        var observers = this.getGestureObservers(type);
        if (observers) {
            for (var i = 0; i < observers.length; i++) {
                observers[i].disconnect();
            }
        }
    };
    Object.defineProperty(ViewCommon.prototype, "borderColor", {
        get: function () {
            return this.style.borderColor;
        },
        set: function (value) {
            this.style.borderColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderTopColor", {
        get: function () {
            return this.style.borderTopColor;
        },
        set: function (value) {
            this.style.borderTopColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderRightColor", {
        get: function () {
            return this.style.borderRightColor;
        },
        set: function (value) {
            this.style.borderRightColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderBottomColor", {
        get: function () {
            return this.style.borderBottomColor;
        },
        set: function (value) {
            this.style.borderBottomColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderLeftColor", {
        get: function () {
            return this.style.borderLeftColor;
        },
        set: function (value) {
            this.style.borderLeftColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderWidth", {
        get: function () {
            return this.style.borderWidth;
        },
        set: function (value) {
            this.style.borderWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderTopWidth", {
        get: function () {
            return this.style.borderTopWidth;
        },
        set: function (value) {
            this.style.borderTopWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderRightWidth", {
        get: function () {
            return this.style.borderRightWidth;
        },
        set: function (value) {
            this.style.borderRightWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderBottomWidth", {
        get: function () {
            return this.style.borderBottomWidth;
        },
        set: function (value) {
            this.style.borderBottomWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderLeftWidth", {
        get: function () {
            return this.style.borderLeftWidth;
        },
        set: function (value) {
            this.style.borderLeftWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderRadius", {
        get: function () {
            return this.style.borderRadius;
        },
        set: function (value) {
            this.style.borderRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderTopLeftRadius", {
        get: function () {
            return this.style.borderTopLeftRadius;
        },
        set: function (value) {
            this.style.borderTopLeftRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderTopRightRadius", {
        get: function () {
            return this.style.borderTopRightRadius;
        },
        set: function (value) {
            this.style.borderTopRightRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderBottomRightRadius", {
        get: function () {
            return this.style.borderBottomRightRadius;
        },
        set: function (value) {
            this.style.borderBottomRightRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "borderBottomLeftRadius", {
        get: function () {
            return this.style.borderBottomLeftRadius;
        },
        set: function (value) {
            this.style.borderBottomLeftRadius = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "color", {
        get: function () {
            return this.style.color;
        },
        set: function (value) {
            this.style.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "background", {
        get: function () {
            return this.style.background;
        },
        set: function (value) {
            this.style.background = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "backgroundColor", {
        get: function () {
            return this.style.backgroundColor;
        },
        set: function (value) {
            this.style.backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "backgroundImage", {
        get: function () {
            return this.style.backgroundImage;
        },
        set: function (value) {
            this.style.backgroundImage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "backgroundSize", {
        get: function () {
            return this.style.backgroundSize;
        },
        set: function (value) {
            this.style.backgroundSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "backgroundPosition", {
        get: function () {
            return this.style.backgroundPosition;
        },
        set: function (value) {
            this.style.backgroundPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "backgroundRepeat", {
        get: function () {
            return this.style.backgroundRepeat;
        },
        set: function (value) {
            this.style.backgroundRepeat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "minWidth", {
        get: function () {
            return this.style.minWidth;
        },
        set: function (value) {
            this.style.minWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "minHeight", {
        get: function () {
            return this.style.minHeight;
        },
        set: function (value) {
            this.style.minHeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "width", {
        get: function () {
            return this.style.width;
        },
        set: function (value) {
            this.style.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "height", {
        get: function () {
            return this.style.height;
        },
        set: function (value) {
            this.style.height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "margin", {
        get: function () {
            return this.style.margin;
        },
        set: function (value) {
            this.style.margin = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "marginLeft", {
        get: function () {
            return this.style.marginLeft;
        },
        set: function (value) {
            this.style.marginLeft = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "marginTop", {
        get: function () {
            return this.style.marginTop;
        },
        set: function (value) {
            this.style.marginTop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "marginRight", {
        get: function () {
            return this.style.marginRight;
        },
        set: function (value) {
            this.style.marginRight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "marginBottom", {
        get: function () {
            return this.style.marginBottom;
        },
        set: function (value) {
            this.style.marginBottom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "horizontalAlignment", {
        get: function () {
            return this.style.horizontalAlignment;
        },
        set: function (value) {
            this.style.horizontalAlignment = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "verticalAlignment", {
        get: function () {
            return this.style.verticalAlignment;
        },
        set: function (value) {
            this.style.verticalAlignment = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "visibility", {
        get: function () {
            return this.style.visibility;
        },
        set: function (value) {
            this.style.visibility = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "opacity", {
        get: function () {
            return this.style.opacity;
        },
        set: function (value) {
            this.style.opacity = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "rotate", {
        get: function () {
            return this.style.rotate;
        },
        set: function (value) {
            this.style.rotate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "translateX", {
        get: function () {
            return this.style.translateX;
        },
        set: function (value) {
            this.style.translateX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "translateY", {
        get: function () {
            return this.style.translateY;
        },
        set: function (value) {
            this.style.translateY = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "scaleX", {
        get: function () {
            return this.style.scaleX;
        },
        set: function (value) {
            this.style.scaleX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "scaleY", {
        get: function () {
            return this.style.scaleY;
        },
        set: function (value) {
            this.style.scaleY = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "androidElevation", {
        get: function () {
            return this.style.androidElevation;
        },
        set: function (value) {
            this.style.androidElevation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "androidDynamicElevationOffset", {
        get: function () {
            return this.style.androidDynamicElevationOffset;
        },
        set: function (value) {
            this.style.androidDynamicElevationOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "isLayoutValid", {
        get: function () {
            return this._isLayoutValid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "cssType", {
        get: function () {
            if (!this._cssType) {
                this._cssType = this.typeName.toLowerCase();
            }
            return this._cssType;
        },
        set: function (type) {
            this._cssType = type.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewCommon.prototype, "isLayoutRequired", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    ViewCommon.prototype.measure = function (widthMeasureSpec, heightMeasureSpec) {
        this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
    };
    ViewCommon.prototype.layout = function (left, top, right, bottom) {
        this._setCurrentLayoutBounds(left, top, right, bottom);
    };
    ViewCommon.prototype.getMeasuredWidth = function () {
        return this._measuredWidth & view_base_1.layout.MEASURED_SIZE_MASK || 0;
    };
    ViewCommon.prototype.getMeasuredHeight = function () {
        return this._measuredHeight & view_base_1.layout.MEASURED_SIZE_MASK || 0;
    };
    ViewCommon.prototype.getMeasuredState = function () {
        return (this._measuredWidth & view_base_1.layout.MEASURED_STATE_MASK)
            | ((this._measuredHeight >> view_base_1.layout.MEASURED_HEIGHT_STATE_SHIFT)
                & (view_base_1.layout.MEASURED_STATE_MASK >> view_base_1.layout.MEASURED_HEIGHT_STATE_SHIFT));
    };
    ViewCommon.prototype.setMeasuredDimension = function (measuredWidth, measuredHeight) {
        this._measuredWidth = measuredWidth;
        this._measuredHeight = measuredHeight;
        if (view_base_1.traceEnabled()) {
            view_base_1.traceWrite(this + " :setMeasuredDimension: " + measuredWidth + ", " + measuredHeight, view_base_1.traceCategories.Layout);
        }
    };
    ViewCommon.prototype.requestLayout = function () {
        this._isLayoutValid = false;
        _super.prototype.requestLayout.call(this);
    };
    ViewCommon.resolveSizeAndState = function (size, specSize, specMode, childMeasuredState) {
        var result = size;
        switch (specMode) {
            case view_base_1.layout.UNSPECIFIED:
                result = Math.ceil(size);
                break;
            case view_base_1.layout.AT_MOST:
                if (specSize < size) {
                    result = Math.ceil(specSize) | view_base_1.layout.MEASURED_STATE_TOO_SMALL;
                }
                break;
            case view_base_1.layout.EXACTLY:
                result = Math.ceil(specSize);
                break;
        }
        return result | (childMeasuredState & view_base_1.layout.MEASURED_STATE_MASK);
    };
    ViewCommon.combineMeasuredStates = function (curState, newState) {
        return curState | newState;
    };
    ViewCommon.layoutChild = function (parent, child, left, top, right, bottom, setFrame) {
        if (setFrame === void 0) { setFrame = true; }
        if (!child || child.isCollapsed) {
            return;
        }
        var childStyle = child.style;
        var childTop;
        var childLeft;
        var childWidth = child.getMeasuredWidth();
        var childHeight = child.getMeasuredHeight();
        var effectiveMarginTop = child.effectiveMarginTop;
        var effectiveMarginBottom = child.effectiveMarginBottom;
        var vAlignment;
        if (child.effectiveHeight >= 0 && childStyle.verticalAlignment === "stretch") {
            vAlignment = "middle";
        }
        else {
            vAlignment = childStyle.verticalAlignment;
        }
        switch (vAlignment) {
            case "top":
                childTop = top + effectiveMarginTop;
                break;
            case "middle":
                childTop = top + (bottom - top - childHeight + (effectiveMarginTop - effectiveMarginBottom)) / 2;
                break;
            case "bottom":
                childTop = bottom - childHeight - effectiveMarginBottom;
                break;
            case "stretch":
            default:
                childTop = top + effectiveMarginTop;
                childHeight = bottom - top - (effectiveMarginTop + effectiveMarginBottom);
                break;
        }
        var effectiveMarginLeft = child.effectiveMarginLeft;
        var effectiveMarginRight = child.effectiveMarginRight;
        var hAlignment;
        if (child.effectiveWidth >= 0 && childStyle.horizontalAlignment === "stretch") {
            hAlignment = "center";
        }
        else {
            hAlignment = childStyle.horizontalAlignment;
        }
        switch (hAlignment) {
            case "left":
                childLeft = left + effectiveMarginLeft;
                break;
            case "center":
                childLeft = left + (right - left - childWidth + (effectiveMarginLeft - effectiveMarginRight)) / 2;
                break;
            case "right":
                childLeft = right - childWidth - effectiveMarginRight;
                break;
            case "stretch":
            default:
                childLeft = left + effectiveMarginLeft;
                childWidth = right - left - (effectiveMarginLeft + effectiveMarginRight);
                break;
        }
        var childRight = Math.round(childLeft + childWidth);
        var childBottom = Math.round(childTop + childHeight);
        childLeft = Math.round(childLeft);
        childTop = Math.round(childTop);
        if (view_base_1.traceEnabled()) {
            view_base_1.traceWrite(child.parent + " :layoutChild: " + child + " " + childLeft + ", " + childTop + ", " + childRight + ", " + childBottom, view_base_1.traceCategories.Layout);
        }
        child.layout(childLeft, childTop, childRight, childBottom, setFrame);
    };
    ViewCommon.measureChild = function (parent, child, widthMeasureSpec, heightMeasureSpec) {
        var measureWidth = 0;
        var measureHeight = 0;
        if (child && !child.isCollapsed) {
            var widthSpec = parent ? parent._currentWidthMeasureSpec : widthMeasureSpec;
            var heightSpec = parent ? parent._currentHeightMeasureSpec : heightMeasureSpec;
            var width = view_base_1.layout.getMeasureSpecSize(widthSpec);
            var widthMode = view_base_1.layout.getMeasureSpecMode(widthSpec);
            var height = view_base_1.layout.getMeasureSpecSize(heightSpec);
            var heightMode = view_base_1.layout.getMeasureSpecMode(heightSpec);
            child._updateEffectiveLayoutValues(width, widthMode, height, heightMode);
            var style = child.style;
            var horizontalMargins = child.effectiveMarginLeft + child.effectiveMarginRight;
            var verticalMargins = child.effectiveMarginTop + child.effectiveMarginBottom;
            var childWidthMeasureSpec = ViewCommon.getMeasureSpec(widthMeasureSpec, horizontalMargins, child.effectiveWidth, style.horizontalAlignment === "stretch");
            var childHeightMeasureSpec = ViewCommon.getMeasureSpec(heightMeasureSpec, verticalMargins, child.effectiveHeight, style.verticalAlignment === "stretch");
            if (view_base_1.traceEnabled()) {
                view_base_1.traceWrite(child.parent + " :measureChild: " + child + " " + view_base_1.layout.measureSpecToString(childWidthMeasureSpec) + ", " + view_base_1.layout.measureSpecToString(childHeightMeasureSpec) + "}", view_base_1.traceCategories.Layout);
            }
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            measureWidth = Math.round(child.getMeasuredWidth() + horizontalMargins);
            measureHeight = Math.round(child.getMeasuredHeight() + verticalMargins);
        }
        return { measuredWidth: measureWidth, measuredHeight: measureHeight };
    };
    ViewCommon.getMeasureSpec = function (parentSpec, margins, childLength, stretched) {
        var parentLength = view_base_1.layout.getMeasureSpecSize(parentSpec);
        var parentSpecMode = view_base_1.layout.getMeasureSpecMode(parentSpec);
        var resultSize;
        var resultMode;
        if (childLength >= 0) {
            resultSize = parentSpecMode === view_base_1.layout.UNSPECIFIED ? childLength : Math.min(parentLength, childLength);
            resultMode = view_base_1.layout.EXACTLY;
        }
        else {
            switch (parentSpecMode) {
                case view_base_1.layout.EXACTLY:
                    resultSize = Math.max(0, parentLength - margins);
                    resultMode = stretched ? view_base_1.layout.EXACTLY : view_base_1.layout.AT_MOST;
                    break;
                case view_base_1.layout.AT_MOST:
                    resultSize = Math.max(0, parentLength - margins);
                    resultMode = view_base_1.layout.AT_MOST;
                    break;
                case view_base_1.layout.UNSPECIFIED:
                    resultSize = 0;
                    resultMode = view_base_1.layout.UNSPECIFIED;
                    break;
            }
        }
        return view_base_1.layout.makeMeasureSpec(resultSize, resultMode);
    };
    ViewCommon.prototype._setCurrentMeasureSpecs = function (widthMeasureSpec, heightMeasureSpec) {
        var changed = this._currentWidthMeasureSpec !== widthMeasureSpec || this._currentHeightMeasureSpec !== heightMeasureSpec;
        this._currentWidthMeasureSpec = widthMeasureSpec;
        this._currentHeightMeasureSpec = heightMeasureSpec;
        return changed;
    };
    ViewCommon.prototype._getCurrentLayoutBounds = function () {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    };
    ViewCommon.prototype._setCurrentLayoutBounds = function (left, top, right, bottom) {
        this._isLayoutValid = true;
        var boundsChanged = this._oldLeft !== left || this._oldTop !== top || this._oldRight !== right || this._oldBottom !== bottom;
        var sizeChanged = (this._oldRight - this._oldLeft !== right - left) || (this._oldBottom - this._oldTop !== bottom - top);
        this._oldLeft = left;
        this._oldTop = top;
        this._oldRight = right;
        this._oldBottom = bottom;
        return { boundsChanged: boundsChanged, sizeChanged: sizeChanged };
    };
    ViewCommon.prototype.eachChild = function (callback) {
        this.eachChildView(callback);
    };
    ViewCommon.prototype.eachChildView = function (callback) {
    };
    ViewCommon.prototype._getNativeViewsCount = function () {
        return this._isAddedToNativeVisualTree ? 1 : 0;
    };
    ViewCommon.prototype._eachLayoutView = function (callback) {
        return callback(this);
    };
    ViewCommon.prototype.focus = function () {
        return undefined;
    };
    ViewCommon.prototype.getSafeAreaInsets = function () {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    };
    ViewCommon.prototype.getLocationInWindow = function () {
        return undefined;
    };
    ViewCommon.prototype.getLocationOnScreen = function () {
        return undefined;
    };
    ViewCommon.prototype.getLocationRelativeTo = function (otherView) {
        return undefined;
    };
    ViewCommon.prototype.getActualSize = function () {
        var currentBounds = this._getCurrentLayoutBounds();
        if (!currentBounds) {
            return undefined;
        }
        return {
            width: view_base_1.layout.toDeviceIndependentPixels(currentBounds.right - currentBounds.left),
            height: view_base_1.layout.toDeviceIndependentPixels(currentBounds.bottom - currentBounds.top),
        };
    };
    ViewCommon.prototype.animate = function (animation) {
        return this.createAnimation(animation).play();
    };
    ViewCommon.prototype.createAnimation = function (animation) {
        ensureAnimationModule();
        if (!this._localAnimations) {
            this._localAnimations = new Set();
        }
        animation.target = this;
        var anim = new animationModule.Animation([animation]);
        this._localAnimations.add(anim);
        return anim;
    };
    ViewCommon.prototype._removeAnimation = function (animation) {
        var localAnimations = this._localAnimations;
        if (localAnimations && localAnimations.has(animation)) {
            localAnimations.delete(animation);
            if (animation.isPlaying) {
                animation.cancel();
            }
            return true;
        }
        return false;
    };
    ViewCommon.prototype.resetNativeView = function () {
        var _this = this;
        if (this._localAnimations) {
            this._localAnimations.forEach(function (a) { return _this._removeAnimation(a); });
        }
        _super.prototype.resetNativeView.call(this);
    };
    ViewCommon.prototype._setNativeViewFrame = function (nativeView, frame) {
    };
    ViewCommon.prototype._getValue = function () {
        throw new Error("The View._getValue is obsolete. There is a new property system.");
    };
    ViewCommon.prototype._setValue = function () {
        throw new Error("The View._setValue is obsolete. There is a new property system.");
    };
    ViewCommon.prototype._updateEffectiveLayoutValues = function (parentWidthMeasureSize, parentWidthMeasureMode, parentHeightMeasureSize, parentHeightMeasureMode) {
        var style = this.style;
        var availableWidth = parentWidthMeasureMode === view_base_1.layout.UNSPECIFIED ? -1 : parentWidthMeasureSize;
        this.effectiveWidth = style_properties_1.PercentLength.toDevicePixels(style.width, -2, availableWidth);
        this.effectiveMarginLeft = style_properties_1.PercentLength.toDevicePixels(style.marginLeft, 0, availableWidth);
        this.effectiveMarginRight = style_properties_1.PercentLength.toDevicePixels(style.marginRight, 0, availableWidth);
        var availableHeight = parentHeightMeasureMode === view_base_1.layout.UNSPECIFIED ? -1 : parentHeightMeasureSize;
        this.effectiveHeight = style_properties_1.PercentLength.toDevicePixels(style.height, -2, availableHeight);
        this.effectiveMarginTop = style_properties_1.PercentLength.toDevicePixels(style.marginTop, 0, availableHeight);
        this.effectiveMarginBottom = style_properties_1.PercentLength.toDevicePixels(style.marginBottom, 0, availableHeight);
    };
    ViewCommon.prototype._setNativeClipToBounds = function () {
    };
    ViewCommon.prototype._redrawNativeBackground = function (value) {
    };
    ViewCommon.prototype._onAttachedToWindow = function () {
    };
    ViewCommon.prototype._onDetachedFromWindow = function () {
    };
    ViewCommon.prototype._hasAncestorView = function (ancestorView) {
        var matcher = function (view) { return view === ancestorView; };
        for (var parent_2 = this.parent; parent_2 != null; parent_2 = parent_2.parent) {
            if (matcher(parent_2)) {
                return true;
            }
        }
        return false;
    };
    ViewCommon.layoutChangedEvent = "layoutChanged";
    ViewCommon.shownModallyEvent = "shownModally";
    ViewCommon.showingModallyEvent = "showingModally";
    return ViewCommon;
}(view_base_1.ViewBase));
exports.ViewCommon = ViewCommon;
exports.automationTextProperty = new view_base_1.Property({ name: "automationText" });
exports.automationTextProperty.register(ViewCommon);
exports.originXProperty = new view_base_1.Property({ name: "originX", defaultValue: 0.5, valueConverter: function (v) { return parseFloat(v); } });
exports.originXProperty.register(ViewCommon);
exports.originYProperty = new view_base_1.Property({ name: "originY", defaultValue: 0.5, valueConverter: function (v) { return parseFloat(v); } });
exports.originYProperty.register(ViewCommon);
exports.isEnabledProperty = new view_base_1.Property({
    name: "isEnabled",
    defaultValue: true,
    valueConverter: view_base_1.booleanConverter,
    valueChanged: function (target, oldValue, newValue) {
        target._goToVisualState(newValue ? "normal" : "disabled");
    }
});
exports.isEnabledProperty.register(ViewCommon);
exports.isUserInteractionEnabledProperty = new view_base_1.Property({ name: "isUserInteractionEnabled", defaultValue: true, valueConverter: view_base_1.booleanConverter });
exports.isUserInteractionEnabledProperty.register(ViewCommon);
exports.iosOverflowSafeAreaProperty = new view_base_1.Property({ name: "iosOverflowSafeArea", defaultValue: false, valueConverter: view_base_1.booleanConverter });
exports.iosOverflowSafeAreaProperty.register(ViewCommon);
exports.iosOverflowSafeAreaEnabledProperty = new view_base_1.InheritedProperty({ name: "iosOverflowSafeAreaEnabled", defaultValue: true, valueConverter: view_base_1.booleanConverter });
exports.iosOverflowSafeAreaEnabledProperty.register(ViewCommon);
//# sourceMappingURL=view-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/view/view.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var view_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view-common.js");
var background_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/background.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/view/view-common.js"));
var PFLAG_FORCE_LAYOUT = 1;
var PFLAG_MEASURED_DIMENSION_SET = 1 << 1;
var PFLAG_LAYOUT_REQUIRED = 1 << 2;
var majorVersion = utils_1.ios.MajorVersion;
var View = (function (_super) {
    __extends(View, _super);
    function View() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._isLaidOut = false;
        _this._hasTransfrom = false;
        _this._privateFlags = PFLAG_LAYOUT_REQUIRED | PFLAG_FORCE_LAYOUT;
        _this._suspendCATransaction = false;
        return _this;
    }
    Object.defineProperty(View.prototype, "isLayoutRequired", {
        get: function () {
            return (this._privateFlags & PFLAG_LAYOUT_REQUIRED) === PFLAG_LAYOUT_REQUIRED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "isLayoutRequested", {
        get: function () {
            return (this._privateFlags & PFLAG_FORCE_LAYOUT) === PFLAG_FORCE_LAYOUT;
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.requestLayout = function () {
        _super.prototype.requestLayout.call(this);
        this._privateFlags |= PFLAG_FORCE_LAYOUT;
        var nativeView = this.nativeViewProtected;
        if (nativeView) {
            nativeView.setNeedsLayout();
        }
        if (this.viewController && this.viewController.view !== nativeView) {
            this.viewController.view.setNeedsLayout();
        }
    };
    View.prototype.measure = function (widthMeasureSpec, heightMeasureSpec) {
        var measureSpecsChanged = this._setCurrentMeasureSpecs(widthMeasureSpec, heightMeasureSpec);
        var forceLayout = (this._privateFlags & PFLAG_FORCE_LAYOUT) === PFLAG_FORCE_LAYOUT;
        if (forceLayout || measureSpecsChanged) {
            this._privateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
            this.onMeasure(widthMeasureSpec, heightMeasureSpec);
            this._privateFlags |= PFLAG_LAYOUT_REQUIRED;
            if ((this._privateFlags & PFLAG_MEASURED_DIMENSION_SET) !== PFLAG_MEASURED_DIMENSION_SET) {
                throw new Error("onMeasure() did not set the measured dimension by calling setMeasuredDimension() " + this);
            }
        }
    };
    View.prototype.layout = function (left, top, right, bottom, setFrame) {
        if (setFrame === void 0) { setFrame = true; }
        var _a = this._setCurrentLayoutBounds(left, top, right, bottom), boundsChanged = _a.boundsChanged, sizeChanged = _a.sizeChanged;
        if (setFrame) {
            this.layoutNativeView(left, top, right, bottom);
        }
        if (boundsChanged || (this._privateFlags & PFLAG_LAYOUT_REQUIRED) === PFLAG_LAYOUT_REQUIRED) {
            var position = { left: left, top: top, right: right, bottom: bottom };
            if (this.nativeViewProtected && majorVersion > 10) {
                var frame = this.nativeViewProtected.frame;
                position = ios.getPositionFromFrame(frame);
            }
            this.onLayout(position.left, position.top, position.right, position.bottom);
            this._privateFlags &= ~PFLAG_LAYOUT_REQUIRED;
        }
        this.updateBackground(sizeChanged);
        this._privateFlags &= ~PFLAG_FORCE_LAYOUT;
    };
    View.prototype.updateBackground = function (sizeChanged) {
        if (sizeChanged) {
            this._onSizeChanged();
        }
        else if (this._nativeBackgroundState === "invalid") {
            var background = this.style.backgroundInternal;
            this._redrawNativeBackground(background);
        }
    };
    View.prototype.setMeasuredDimension = function (measuredWidth, measuredHeight) {
        _super.prototype.setMeasuredDimension.call(this, measuredWidth, measuredHeight);
        this._privateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    };
    View.prototype.onMeasure = function (widthMeasureSpec, heightMeasureSpec) {
        var view = this.nativeViewProtected;
        var width = view_common_1.layout.getMeasureSpecSize(widthMeasureSpec);
        var widthMode = view_common_1.layout.getMeasureSpecMode(widthMeasureSpec);
        var height = view_common_1.layout.getMeasureSpecSize(heightMeasureSpec);
        var heightMode = view_common_1.layout.getMeasureSpecMode(heightMeasureSpec);
        var nativeWidth = 0;
        var nativeHeight = 0;
        if (view) {
            var nativeSize = view_common_1.layout.measureNativeView(view, width, widthMode, height, heightMode);
            nativeWidth = nativeSize.width;
            nativeHeight = nativeSize.height;
        }
        var measureWidth = Math.max(nativeWidth, this.effectiveMinWidth);
        var measureHeight = Math.max(nativeHeight, this.effectiveMinHeight);
        var widthAndState = View.resolveSizeAndState(measureWidth, width, widthMode, 0);
        var heightAndState = View.resolveSizeAndState(measureHeight, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    };
    View.prototype.onLayout = function (left, top, right, bottom) {
    };
    View.prototype._setNativeViewFrame = function (nativeView, frame) {
        var oldFrame = this._cachedFrame || nativeView.frame;
        if (!CGRectEqualToRect(oldFrame, frame)) {
            if (view_common_1.traceEnabled()) {
                view_common_1.traceWrite(this + " :_setNativeViewFrame: " + JSON.stringify(ios.getPositionFromFrame(frame)), view_common_1.traceCategories.Layout);
            }
            this._cachedFrame = frame;
            var adjustedFrame = null;
            var transform = null;
            if (this._hasTransfrom) {
                transform = nativeView.transform;
                nativeView.transform = CGAffineTransformIdentity;
                nativeView.frame = frame;
            }
            else {
                nativeView.frame = frame;
            }
            adjustedFrame = this.applySafeAreaInsets(frame);
            if (adjustedFrame) {
                nativeView.frame = adjustedFrame;
            }
            if (this._hasTransfrom) {
                nativeView.transform = transform;
            }
            var boundsOrigin = nativeView.bounds.origin;
            var boundsFrame = adjustedFrame || frame;
            nativeView.bounds = CGRectMake(boundsOrigin.x, boundsOrigin.y, boundsFrame.size.width, boundsFrame.size.height);
            this._raiseLayoutChangedEvent();
            this._isLaidOut = true;
        }
        else if (!this._isLaidOut) {
            this._raiseLayoutChangedEvent();
            this._isLaidOut = true;
        }
    };
    Object.defineProperty(View.prototype, "isLayoutValid", {
        get: function () {
            if (this.nativeViewProtected) {
                return this._isLayoutValid;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.layoutNativeView = function (left, top, right, bottom) {
        if (!this.nativeViewProtected) {
            return;
        }
        var nativeView = this.nativeViewProtected;
        var frame = ios.getFrameFromPosition({ left: left, top: top, right: right, bottom: bottom });
        this._setNativeViewFrame(nativeView, frame);
    };
    View.prototype._setLayoutFlags = function (left, top, right, bottom) {
        var width = right - left;
        var height = bottom - top;
        var widthSpec = view_common_1.layout.makeMeasureSpec(width, view_common_1.layout.EXACTLY);
        var heightSpec = view_common_1.layout.makeMeasureSpec(height, view_common_1.layout.EXACTLY);
        this._setCurrentMeasureSpecs(widthSpec, heightSpec);
        this._privateFlags &= ~PFLAG_FORCE_LAYOUT;
        this.setMeasuredDimension(width, height);
        var sizeChanged = this._setCurrentLayoutBounds(left, top, right, bottom).sizeChanged;
        this.updateBackground(sizeChanged);
        this._privateFlags &= ~PFLAG_LAYOUT_REQUIRED;
    };
    View.prototype.focus = function () {
        if (this.ios) {
            return this.ios.becomeFirstResponder();
        }
        return false;
    };
    View.prototype.applySafeAreaInsets = function (frame) {
        if (majorVersion <= 10) {
            return null;
        }
        if (!this.iosOverflowSafeArea || !this.iosOverflowSafeAreaEnabled) {
            return ios.shrinkToSafeArea(this, frame);
        }
        else if (this.nativeViewProtected && this.nativeViewProtected.window) {
            return ios.expandBeyondSafeArea(this, frame);
        }
        return null;
    };
    View.prototype.getSafeAreaInsets = function () {
        var safeAreaInsets = this.nativeViewProtected && this.nativeViewProtected.safeAreaInsets;
        var insets = { left: 0, top: 0, right: 0, bottom: 0 };
        if (safeAreaInsets) {
            insets.left = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaInsets.left));
            insets.top = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaInsets.top));
            insets.right = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaInsets.right));
            insets.bottom = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaInsets.bottom));
        }
        return insets;
    };
    View.prototype.getLocationInWindow = function () {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window) {
            return undefined;
        }
        var pointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        return {
            x: pointInWindow.x,
            y: pointInWindow.y
        };
    };
    View.prototype.getLocationOnScreen = function () {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window) {
            return undefined;
        }
        var pointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        var pointOnScreen = this.nativeViewProtected.window.convertPointToWindow(pointInWindow, null);
        return {
            x: pointOnScreen.x,
            y: pointOnScreen.y
        };
    };
    View.prototype.getLocationRelativeTo = function (otherView) {
        if (!this.nativeViewProtected || !this.nativeViewProtected.window ||
            !otherView.nativeViewProtected || !otherView.nativeViewProtected.window ||
            this.nativeViewProtected.window !== otherView.nativeViewProtected.window) {
            return undefined;
        }
        var myPointInWindow = this.nativeViewProtected.convertPointToView(this.nativeViewProtected.bounds.origin, null);
        var otherPointInWindow = otherView.nativeViewProtected.convertPointToView(otherView.nativeViewProtected.bounds.origin, null);
        return {
            x: myPointInWindow.x - otherPointInWindow.x,
            y: myPointInWindow.y - otherPointInWindow.y
        };
    };
    View.prototype._onSizeChanged = function () {
        var nativeView = this.nativeViewProtected;
        if (!nativeView) {
            return;
        }
        var background = this.style.backgroundInternal;
        var backgroundDependsOnSize = background.image
            || !background.hasUniformBorder()
            || background.hasBorderRadius();
        if (this._nativeBackgroundState === "invalid" || (this._nativeBackgroundState === "drawn" && backgroundDependsOnSize)) {
            this._redrawNativeBackground(background);
        }
        var clipPath = this.style.clipPath;
        if (clipPath !== "" && this[style_properties_1.clipPathProperty.setNative]) {
            this[style_properties_1.clipPathProperty.setNative](clipPath);
        }
    };
    View.prototype.updateNativeTransform = function () {
        var scaleX = this.scaleX || 1e-6;
        var scaleY = this.scaleY || 1e-6;
        var rotate = this.rotate || 0;
        var newTransform = CGAffineTransformIdentity;
        newTransform = CGAffineTransformTranslate(newTransform, this.translateX, this.translateY);
        newTransform = CGAffineTransformRotate(newTransform, rotate * Math.PI / 180);
        newTransform = CGAffineTransformScale(newTransform, scaleX, scaleY);
        if (!CGAffineTransformEqualToTransform(this.nativeViewProtected.transform, newTransform)) {
            var updateSuspended = this._isPresentationLayerUpdateSuspeneded();
            if (!updateSuspended) {
                CATransaction.begin();
            }
            this.nativeViewProtected.transform = newTransform;
            this._hasTransfrom = this.nativeViewProtected && !CGAffineTransformEqualToTransform(this.nativeViewProtected.transform, CGAffineTransformIdentity);
            if (!updateSuspended) {
                CATransaction.commit();
            }
        }
    };
    View.prototype.updateOriginPoint = function (originX, originY) {
        var newPoint = CGPointMake(originX, originY);
        this.nativeViewProtected.layer.anchorPoint = newPoint;
        if (this._cachedFrame) {
            this._setNativeViewFrame(this.nativeViewProtected, this._cachedFrame);
        }
    };
    View.prototype._suspendPresentationLayerUpdates = function () {
        this._suspendCATransaction = true;
    };
    View.prototype._resumePresentationLayerUpdates = function () {
        this._suspendCATransaction = false;
    };
    View.prototype._isPresentationLayerUpdateSuspeneded = function () {
        return this._suspendCATransaction || this._suspendNativeUpdatesCount;
    };
    View.prototype._showNativeModalView = function (parent, options) {
        var _this = this;
        var parentWithController = ios.getParentWithViewController(parent);
        if (!parentWithController) {
            view_common_1.traceWrite("Could not find parent with viewController for " + parent + " while showing modal view.", view_common_1.traceCategories.ViewHierarchy, view_common_1.traceMessageType.error);
            return;
        }
        var parentController = parentWithController.viewController;
        if (parentController.presentedViewController) {
            view_common_1.traceWrite("Parent is already presenting view controller. Close the current modal page before showing another one!", view_common_1.traceCategories.ViewHierarchy, view_common_1.traceMessageType.error);
            return;
        }
        if (!parentController.view || !parentController.view.window) {
            view_common_1.traceWrite("Parent page is not part of the window hierarchy.", view_common_1.traceCategories.ViewHierarchy, view_common_1.traceMessageType.error);
            return;
        }
        this._setupAsRootView({});
        _super.prototype._showNativeModalView.call(this, parentWithController, options);
        var controller = this.viewController;
        if (!controller) {
            var nativeView = this.ios || this.nativeViewProtected;
            controller = ios.UILayoutViewController.initWithOwner(new WeakRef(this));
            if (nativeView instanceof UIView) {
                controller.view.addSubview(nativeView);
            }
            this.viewController = controller;
        }
        if (options.fullscreen) {
            controller.modalPresentationStyle = 0;
        }
        else {
            controller.modalPresentationStyle = 2;
        }
        if (options.ios && options.ios.presentationStyle) {
            var presentationStyle = options.ios.presentationStyle;
            controller.modalPresentationStyle = presentationStyle;
            if (presentationStyle === 7) {
                var popoverPresentationController = controller.popoverPresentationController;
                this._popoverPresentationDelegate = ios.UIPopoverPresentationControllerDelegateImp.initWithOwnerAndCallback(new WeakRef(this), this._closeModalCallback);
                popoverPresentationController.delegate = this._popoverPresentationDelegate;
                var view = parent.nativeViewProtected;
                popoverPresentationController.sourceView = view;
                popoverPresentationController.sourceRect = CGRectMake(0, 0, view.frame.size.width, view.frame.size.height);
            }
        }
        this.horizontalAlignment = "stretch";
        this.verticalAlignment = "stretch";
        this._raiseShowingModallyEvent();
        var animated = options.animated === undefined ? true : !!options.animated;
        controller.animated = animated;
        parentController.presentViewControllerAnimatedCompletion(controller, animated, null);
        var transitionCoordinator = parentController.transitionCoordinator;
        if (transitionCoordinator) {
            UIViewControllerTransitionCoordinator.prototype.animateAlongsideTransitionCompletion
                .call(transitionCoordinator, null, function () { return _this._raiseShownModallyEvent(); });
        }
        else {
            this._raiseShownModallyEvent();
        }
    };
    View.prototype._hideNativeModalView = function (parent, whenClosedCallback) {
        if (!parent || !parent.viewController) {
            view_common_1.traceError("Trying to hide modal view but no parent with viewController specified.");
            return;
        }
        if (!parent.viewController.presentedViewController) {
            whenClosedCallback();
            return;
        }
        var parentController = parent.viewController;
        var animated = this.viewController.animated;
        parentController.dismissViewControllerAnimatedCompletion(animated, whenClosedCallback);
    };
    View.prototype[view_common_1.isEnabledProperty.getDefault] = function () {
        var nativeView = this.nativeViewProtected;
        return nativeView instanceof UIControl ? nativeView.enabled : true;
    };
    View.prototype[view_common_1.isEnabledProperty.setNative] = function (value) {
        var nativeView = this.nativeViewProtected;
        if (nativeView instanceof UIControl) {
            nativeView.enabled = value;
        }
    };
    View.prototype[view_common_1.originXProperty.getDefault] = function () {
        return this.nativeViewProtected.layer.anchorPoint.x;
    };
    View.prototype[view_common_1.originXProperty.setNative] = function (value) {
        this.updateOriginPoint(value, this.originY);
    };
    View.prototype[view_common_1.originYProperty.getDefault] = function () {
        return this.nativeViewProtected.layer.anchorPoint.y;
    };
    View.prototype[view_common_1.originYProperty.setNative] = function (value) {
        this.updateOriginPoint(this.originX, value);
    };
    View.prototype[view_common_1.automationTextProperty.getDefault] = function () {
        return this.nativeViewProtected.accessibilityLabel;
    };
    View.prototype[view_common_1.automationTextProperty.setNative] = function (value) {
        this.nativeViewProtected.accessibilityIdentifier = value;
        this.nativeViewProtected.accessibilityLabel = value;
    };
    View.prototype[view_common_1.isUserInteractionEnabledProperty.getDefault] = function () {
        return this.nativeViewProtected.userInteractionEnabled;
    };
    View.prototype[view_common_1.isUserInteractionEnabledProperty.setNative] = function (value) {
        this.nativeViewProtected.userInteractionEnabled = value;
    };
    View.prototype[style_properties_1.visibilityProperty.getDefault] = function () {
        return this.nativeViewProtected.hidden ? style_properties_1.Visibility.COLLAPSE : style_properties_1.Visibility.VISIBLE;
    };
    View.prototype[style_properties_1.visibilityProperty.setNative] = function (value) {
        switch (value) {
            case style_properties_1.Visibility.VISIBLE:
                this.nativeViewProtected.hidden = false;
                break;
            case style_properties_1.Visibility.HIDDEN:
            case style_properties_1.Visibility.COLLAPSE:
                this.nativeViewProtected.hidden = true;
                break;
            default:
                throw new Error("Invalid visibility value: " + value + ". Valid values are: \"" + style_properties_1.Visibility.VISIBLE + "\", \"" + style_properties_1.Visibility.HIDDEN + "\", \"" + style_properties_1.Visibility.COLLAPSE + "\".");
        }
    };
    View.prototype[style_properties_1.opacityProperty.getDefault] = function () {
        return this.nativeViewProtected.alpha;
    };
    View.prototype[style_properties_1.opacityProperty.setNative] = function (value) {
        var nativeView = this.nativeViewProtected;
        var updateSuspended = this._isPresentationLayerUpdateSuspeneded();
        if (!updateSuspended) {
            CATransaction.begin();
        }
        nativeView.alpha = value;
        if (!updateSuspended) {
            CATransaction.commit();
        }
    };
    View.prototype[style_properties_1.rotateProperty.getDefault] = function () {
        return 0;
    };
    View.prototype[style_properties_1.rotateProperty.setNative] = function (value) {
        this.updateNativeTransform();
    };
    View.prototype[style_properties_1.scaleXProperty.getDefault] = function () {
        return 1;
    };
    View.prototype[style_properties_1.scaleXProperty.setNative] = function (value) {
        this.updateNativeTransform();
    };
    View.prototype[style_properties_1.scaleYProperty.getDefault] = function () {
        return 1;
    };
    View.prototype[style_properties_1.scaleYProperty.setNative] = function (value) {
        this.updateNativeTransform();
    };
    View.prototype[style_properties_1.translateXProperty.getDefault] = function () {
        return 0;
    };
    View.prototype[style_properties_1.translateXProperty.setNative] = function (value) {
        this.updateNativeTransform();
    };
    View.prototype[style_properties_1.translateYProperty.getDefault] = function () {
        return 0;
    };
    View.prototype[style_properties_1.translateYProperty.setNative] = function (value) {
        this.updateNativeTransform();
    };
    View.prototype[style_properties_1.zIndexProperty.getDefault] = function () {
        return 0;
    };
    View.prototype[style_properties_1.zIndexProperty.setNative] = function (value) {
        this.nativeViewProtected.layer.zPosition = value;
    };
    View.prototype[style_properties_1.backgroundInternalProperty.getDefault] = function () {
        return this.nativeViewProtected.backgroundColor;
    };
    View.prototype[style_properties_1.backgroundInternalProperty.setNative] = function (value) {
        this._nativeBackgroundState = "invalid";
        if (this.isLayoutValid) {
            this._redrawNativeBackground(value);
        }
    };
    View.prototype._getCurrentLayoutBounds = function () {
        var nativeView = this.nativeViewProtected;
        if (nativeView && !this.isCollapsed) {
            var frame = nativeView.frame;
            var origin_1 = frame.origin;
            var size = frame.size;
            return {
                left: Math.round(view_common_1.layout.toDevicePixels(origin_1.x)),
                top: Math.round(view_common_1.layout.toDevicePixels(origin_1.y)),
                right: Math.round(view_common_1.layout.toDevicePixels(origin_1.x + size.width)),
                bottom: Math.round(view_common_1.layout.toDevicePixels(origin_1.y + size.height))
            };
        }
        else {
            return { left: 0, top: 0, right: 0, bottom: 0 };
        }
    };
    View.prototype._redrawNativeBackground = function (value) {
        var _this = this;
        var updateSuspended = this._isPresentationLayerUpdateSuspeneded();
        if (!updateSuspended) {
            CATransaction.begin();
        }
        if (value instanceof UIColor) {
            this.nativeViewProtected.backgroundColor = value;
        }
        else {
            background_1.ios.createBackgroundUIColor(this, function (color) {
                _this.nativeViewProtected.backgroundColor = color;
            });
            this._setNativeClipToBounds();
        }
        if (!updateSuspended) {
            CATransaction.commit();
        }
        this._nativeBackgroundState = "drawn";
    };
    View.prototype._setNativeClipToBounds = function () {
        var backgroundInternal = this.style.backgroundInternal;
        this.nativeViewProtected.clipsToBounds =
            this.nativeViewProtected instanceof UIScrollView ||
                backgroundInternal.hasBorderWidth() ||
                backgroundInternal.hasBorderRadius();
    };
    __decorate([
        profiling_1.profile
    ], View.prototype, "layout", null);
    __decorate([
        profiling_1.profile
    ], View.prototype, "onMeasure", null);
    return View;
}(view_common_1.ViewCommon));
exports.View = View;
View.prototype._nativeBackgroundState = "unset";
var ContainerView = (function (_super) {
    __extends(ContainerView, _super);
    function ContainerView() {
        var _this = _super.call(this) || this;
        _this.iosOverflowSafeArea = true;
        return _this;
    }
    return ContainerView;
}(View));
exports.ContainerView = ContainerView;
var CustomLayoutView = (function (_super) {
    __extends(CustomLayoutView, _super);
    function CustomLayoutView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CustomLayoutView.prototype.createNativeView = function () {
        return UIView.alloc().initWithFrame(UIScreen.mainScreen.bounds);
    };
    Object.defineProperty(CustomLayoutView.prototype, "ios", {
        get: function () {
            return this.nativeViewProtected;
        },
        enumerable: true,
        configurable: true
    });
    CustomLayoutView.prototype.onMeasure = function (widthMeasureSpec, heightMeasureSpec) {
    };
    CustomLayoutView.prototype._addViewToNativeVisualTree = function (child, atIndex) {
        _super.prototype._addViewToNativeVisualTree.call(this, child, atIndex);
        var parentNativeView = this.nativeViewProtected;
        var childNativeView = child.nativeViewProtected;
        if (parentNativeView && childNativeView) {
            if (typeof atIndex !== "number" || atIndex >= parentNativeView.subviews.count) {
                parentNativeView.addSubview(childNativeView);
            }
            else {
                parentNativeView.insertSubviewAtIndex(childNativeView, atIndex);
            }
            return true;
        }
        return false;
    };
    CustomLayoutView.prototype._removeViewFromNativeVisualTree = function (child) {
        _super.prototype._removeViewFromNativeVisualTree.call(this, child);
        if (child.nativeViewProtected) {
            child.nativeViewProtected.removeFromSuperview();
        }
    };
    return CustomLayoutView;
}(ContainerView));
exports.CustomLayoutView = CustomLayoutView;
var ios;
(function (ios) {
    function getParentWithViewController(view) {
        while (view && !view.viewController) {
            view = view.parent;
        }
        return view;
    }
    ios.getParentWithViewController = getParentWithViewController;
    function updateAutoAdjustScrollInsets(controller, owner) {
        if (majorVersion <= 10) {
            owner._automaticallyAdjustsScrollViewInsets = false;
            controller.automaticallyAdjustsScrollViewInsets = false;
        }
    }
    ios.updateAutoAdjustScrollInsets = updateAutoAdjustScrollInsets;
    function updateConstraints(controller, owner) {
        if (majorVersion <= 10) {
            var layoutGuide = initLayoutGuide(controller);
            controller.view.safeAreaLayoutGuide = layoutGuide;
        }
    }
    ios.updateConstraints = updateConstraints;
    function initLayoutGuide(controller) {
        var rootView = controller.view;
        var layoutGuide = UILayoutGuide.alloc().init();
        rootView.addLayoutGuide(layoutGuide);
        NSLayoutConstraint.activateConstraints([
            layoutGuide.topAnchor.constraintEqualToAnchor(controller.topLayoutGuide.bottomAnchor),
            layoutGuide.bottomAnchor.constraintEqualToAnchor(controller.bottomLayoutGuide.topAnchor),
            layoutGuide.leadingAnchor.constraintEqualToAnchor(rootView.leadingAnchor),
            layoutGuide.trailingAnchor.constraintEqualToAnchor(rootView.trailingAnchor)
        ]);
        return layoutGuide;
    }
    function layoutView(controller, owner) {
        var layoutGuide = controller.view.safeAreaLayoutGuide;
        if (!layoutGuide) {
            view_common_1.traceWrite("safeAreaLayoutGuide during layout of " + owner + ". Creating fallback constraints, but layout might be wrong.", view_common_1.traceCategories.Layout, view_common_1.traceMessageType.error);
            layoutGuide = initLayoutGuide(controller);
        }
        var safeArea = layoutGuide.layoutFrame;
        var position = ios.getPositionFromFrame(safeArea);
        var safeAreaSize = safeArea.size;
        var hasChildViewControllers = controller.childViewControllers.count > 0;
        if (hasChildViewControllers) {
            var fullscreen = controller.view.frame;
            position = ios.getPositionFromFrame(fullscreen);
        }
        var safeAreaWidth = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaSize.width));
        var safeAreaHeight = view_common_1.layout.round(view_common_1.layout.toDevicePixels(safeAreaSize.height));
        var widthSpec = view_common_1.layout.makeMeasureSpec(safeAreaWidth, view_common_1.layout.EXACTLY);
        var heightSpec = view_common_1.layout.makeMeasureSpec(safeAreaHeight, view_common_1.layout.EXACTLY);
        View.measureChild(null, owner, widthSpec, heightSpec);
        View.layoutChild(null, owner, position.left, position.top, position.right, position.bottom);
        layoutParent(owner.parent);
    }
    ios.layoutView = layoutView;
    function getPositionFromFrame(frame) {
        var left = view_common_1.layout.round(view_common_1.layout.toDevicePixels(frame.origin.x));
        var top = view_common_1.layout.round(view_common_1.layout.toDevicePixels(frame.origin.y));
        var right = view_common_1.layout.round(view_common_1.layout.toDevicePixels(frame.origin.x + frame.size.width));
        var bottom = view_common_1.layout.round(view_common_1.layout.toDevicePixels(frame.origin.y + frame.size.height));
        return { left: left, right: right, top: top, bottom: bottom };
    }
    ios.getPositionFromFrame = getPositionFromFrame;
    function getFrameFromPosition(position, insets) {
        insets = insets || { left: 0, top: 0, right: 0, bottom: 0 };
        var left = view_common_1.layout.toDeviceIndependentPixels(position.left + insets.left);
        var top = view_common_1.layout.toDeviceIndependentPixels(position.top + insets.top);
        var width = view_common_1.layout.toDeviceIndependentPixels(position.right - position.left - insets.left - insets.right);
        var height = view_common_1.layout.toDeviceIndependentPixels(position.bottom - position.top - insets.top - insets.bottom);
        return CGRectMake(left, top, width, height);
    }
    ios.getFrameFromPosition = getFrameFromPosition;
    function shrinkToSafeArea(view, frame) {
        var insets = view.getSafeAreaInsets();
        if (insets.left || insets.top) {
            var position = ios.getPositionFromFrame(frame);
            var adjustedFrame = ios.getFrameFromPosition(position, insets);
            if (view_common_1.traceEnabled()) {
                view_common_1.traceWrite(this + " :shrinkToSafeArea: " + JSON.stringify(ios.getPositionFromFrame(adjustedFrame)), view_common_1.traceCategories.Layout);
            }
            return adjustedFrame;
        }
        return null;
    }
    ios.shrinkToSafeArea = shrinkToSafeArea;
    function expandBeyondSafeArea(view, frame) {
        var availableSpace = getAvailableSpaceFromParent(view, frame);
        var safeArea = availableSpace.safeArea;
        var fullscreen = availableSpace.fullscreen;
        var inWindow = availableSpace.inWindow;
        var position = ios.getPositionFromFrame(frame);
        var safeAreaPosition = ios.getPositionFromFrame(safeArea);
        var fullscreenPosition = ios.getPositionFromFrame(fullscreen);
        var inWindowPosition = ios.getPositionFromFrame(inWindow);
        var adjustedPosition = position;
        if (position.left && inWindowPosition.left <= safeAreaPosition.left) {
            adjustedPosition.left = fullscreenPosition.left;
        }
        if (position.top && inWindowPosition.top <= safeAreaPosition.top) {
            adjustedPosition.top = fullscreenPosition.top;
        }
        if (inWindowPosition.right < fullscreenPosition.right && inWindowPosition.right >= safeAreaPosition.right + fullscreenPosition.left) {
            adjustedPosition.right += fullscreenPosition.right - inWindowPosition.right;
        }
        if (inWindowPosition.bottom < fullscreenPosition.bottom && inWindowPosition.bottom >= safeAreaPosition.bottom + fullscreenPosition.top) {
            adjustedPosition.bottom += fullscreenPosition.bottom - inWindowPosition.bottom;
        }
        var adjustedFrame = CGRectMake(view_common_1.layout.toDeviceIndependentPixels(adjustedPosition.left), view_common_1.layout.toDeviceIndependentPixels(adjustedPosition.top), view_common_1.layout.toDeviceIndependentPixels(adjustedPosition.right - adjustedPosition.left), view_common_1.layout.toDeviceIndependentPixels(adjustedPosition.bottom - adjustedPosition.top));
        if (view_common_1.traceEnabled()) {
            view_common_1.traceWrite(view + " :expandBeyondSafeArea: " + JSON.stringify(ios.getPositionFromFrame(adjustedFrame)), view_common_1.traceCategories.Layout);
        }
        return adjustedFrame;
    }
    ios.expandBeyondSafeArea = expandBeyondSafeArea;
    function layoutParent(view) {
        if (!view) {
            return;
        }
        if (view instanceof View && view.nativeViewProtected) {
            var frame = view.nativeViewProtected.frame;
            var origin_2 = frame.origin;
            var size = frame.size;
            var left = view_common_1.layout.toDevicePixels(origin_2.x);
            var top_1 = view_common_1.layout.toDevicePixels(origin_2.y);
            var width = view_common_1.layout.toDevicePixels(size.width);
            var height = view_common_1.layout.toDevicePixels(size.height);
            view._setLayoutFlags(left, top_1, width + left, height + top_1);
        }
        layoutParent(view.parent);
    }
    function getAvailableSpaceFromParent(view, frame) {
        if (!view) {
            return;
        }
        var scrollView = null;
        var viewControllerView = null;
        if (view.viewController) {
            viewControllerView = view.viewController.view;
        }
        else {
            var parent_1 = view.parent;
            while (parent_1 && !parent_1.viewController && !(parent_1.nativeViewProtected instanceof UIScrollView)) {
                parent_1 = parent_1.parent;
            }
            if (parent_1.nativeViewProtected instanceof UIScrollView) {
                scrollView = parent_1.nativeViewProtected;
            }
            else if (parent_1.viewController) {
                viewControllerView = parent_1.viewController.view;
            }
        }
        var fullscreen = null;
        var safeArea = null;
        if (viewControllerView) {
            safeArea = viewControllerView.safeAreaLayoutGuide.layoutFrame;
            fullscreen = viewControllerView.frame;
        }
        else if (scrollView) {
            var insets = scrollView.safeAreaInsets;
            safeArea = CGRectMake(insets.left, insets.top, scrollView.contentSize.width - insets.left - insets.right, scrollView.contentSize.height - insets.top - insets.bottom);
            fullscreen = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);
        }
        var locationInWindow = view.getLocationInWindow();
        var inWindowLeft = locationInWindow.x;
        var inWindowTop = locationInWindow.y;
        if (scrollView) {
            inWindowLeft += scrollView.contentOffset.x;
            inWindowTop += scrollView.contentOffset.y;
        }
        var inWindow = CGRectMake(inWindowLeft, inWindowTop, frame.size.width, frame.size.height);
        return { safeArea: safeArea, fullscreen: fullscreen, inWindow: inWindow };
    }
    var UILayoutViewController = (function (_super) {
        __extends(UILayoutViewController, _super);
        function UILayoutViewController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UILayoutViewController.initWithOwner = function (owner) {
            var controller = UILayoutViewController.new();
            controller.owner = owner;
            return controller;
        };
        UILayoutViewController.prototype.viewDidLoad = function () {
            _super.prototype.viewDidLoad.call(this);
            this.extendedLayoutIncludesOpaqueBars = true;
        };
        UILayoutViewController.prototype.viewWillLayoutSubviews = function () {
            _super.prototype.viewWillLayoutSubviews.call(this);
            var owner = this.owner.get();
            if (owner) {
                updateConstraints(this, owner);
            }
        };
        UILayoutViewController.prototype.viewDidLayoutSubviews = function () {
            _super.prototype.viewDidLayoutSubviews.call(this);
            var owner = this.owner.get();
            if (owner) {
                if (majorVersion >= 11) {
                    var tabViewItem = owner.parent;
                    var tabView = tabViewItem && tabViewItem.parent;
                    var parent_2 = tabView && tabView.parent;
                    while (parent_2 && !parent_2.nativeViewProtected) {
                        parent_2 = parent_2.parent;
                    }
                    if (parent_2) {
                        var parentPageInsetsTop = parent_2.nativeViewProtected.safeAreaInsets.top;
                        var currentInsetsTop = this.view.safeAreaInsets.top;
                        var additionalInsetsTop = Math.max(parentPageInsetsTop - currentInsetsTop, 0);
                        var parentPageInsetsBottom = parent_2.nativeViewProtected.safeAreaInsets.bottom;
                        var currentInsetsBottom = this.view.safeAreaInsets.bottom;
                        var additionalInsetsBottom = Math.max(parentPageInsetsBottom - currentInsetsBottom, 0);
                        if (additionalInsetsTop > 0 || additionalInsetsBottom > 0) {
                            var additionalInsets = new UIEdgeInsets({ top: additionalInsetsTop, left: 0, bottom: additionalInsetsBottom, right: 0 });
                            this.additionalSafeAreaInsets = additionalInsets;
                        }
                    }
                }
                layoutView(this, owner);
            }
        };
        UILayoutViewController.prototype.viewWillAppear = function (animated) {
            _super.prototype.viewWillAppear.call(this, animated);
            var owner = this.owner.get();
            if (!owner) {
                return;
            }
            updateAutoAdjustScrollInsets(this, owner);
            if (!owner.parent) {
                owner.callLoaded();
            }
        };
        UILayoutViewController.prototype.viewDidDisappear = function (animated) {
            _super.prototype.viewDidDisappear.call(this, animated);
            var owner = this.owner.get();
            if (owner && !owner.parent) {
                owner.callUnloaded();
            }
        };
        return UILayoutViewController;
    }(UIViewController));
    ios.UILayoutViewController = UILayoutViewController;
    var UIPopoverPresentationControllerDelegateImp = (function (_super) {
        __extends(UIPopoverPresentationControllerDelegateImp, _super);
        function UIPopoverPresentationControllerDelegateImp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UIPopoverPresentationControllerDelegateImp.initWithOwnerAndCallback = function (owner, whenClosedCallback) {
            var instance = _super.new.call(this);
            instance.owner = owner;
            instance.closedCallback = whenClosedCallback;
            return instance;
        };
        UIPopoverPresentationControllerDelegateImp.prototype.popoverPresentationControllerDidDismissPopover = function (popoverPresentationController) {
            var owner = this.owner.get();
            if (owner && typeof this.closedCallback === "function") {
                this.closedCallback();
            }
        };
        UIPopoverPresentationControllerDelegateImp.ObjCProtocols = [UIPopoverPresentationControllerDelegate];
        return UIPopoverPresentationControllerDelegateImp;
    }(NSObject));
    ios.UIPopoverPresentationControllerDelegateImp = UIPopoverPresentationControllerDelegateImp;
})(ios = exports.ios || (exports.ios = {}));
//# sourceMappingURL=view.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/core/weak-event-listener/weak-event-listener.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var handlersForEventName = new Map();
var sourcesMap = new WeakMap();
var TargetHandlerPair = (function () {
    function TargetHandlerPair(target, handler) {
        this.tagetRef = new WeakRef(target);
        this.handler = handler;
    }
    return TargetHandlerPair;
}());
function getHandlerForEventName(eventName) {
    var handler = handlersForEventName.get(eventName);
    if (!handler) {
        handler = function (eventData) {
            var source = eventData.object;
            var sourceEventMap = sourcesMap.get(source);
            if (!sourceEventMap) {
                source.removeEventListener(eventName, handlersForEventName.get(eventName));
                return;
            }
            var targetHandlerPairList = sourceEventMap.get(eventName);
            if (!targetHandlerPairList) {
                return;
            }
            var deadPairsIndexes = [];
            var pair;
            var target;
            for (var i = 0; i < targetHandlerPairList.length; i++) {
                pair = targetHandlerPairList[i];
                target = pair.tagetRef.get();
                if (target) {
                    pair.handler.call(target, eventData);
                }
                else {
                    deadPairsIndexes.push(i);
                }
            }
            if (deadPairsIndexes.length === targetHandlerPairList.length) {
                source.removeEventListener(eventName, handlersForEventName.get(eventName));
                sourceEventMap.delete(eventName);
            }
            else {
                for (var j = deadPairsIndexes.length - 1; j >= 0; j--) {
                    targetHandlerPairList.splice(deadPairsIndexes[j], 1);
                }
            }
        };
        handlersForEventName.set(eventName, handler);
    }
    return handler;
}
function validateArgs(source, eventName, handler, target) {
    if (!source) {
        throw new Error("source is null or undefined");
    }
    if (!target) {
        throw new Error("target is null or undefined");
    }
    if (typeof eventName !== "string") {
        throw new Error("eventName is not a string");
    }
    if (typeof handler !== "function") {
        throw new Error("handler is not a function");
    }
}
function addWeakEventListener(source, eventName, handler, target) {
    validateArgs(source, eventName, handler, target);
    var shouldAttach = false;
    var sourceEventMap = sourcesMap.get(source);
    if (!sourceEventMap) {
        sourceEventMap = new Map();
        sourcesMap.set(source, sourceEventMap);
        shouldAttach = true;
    }
    var pairList = sourceEventMap.get(eventName);
    if (!pairList) {
        pairList = new Array();
        sourceEventMap.set(eventName, pairList);
        shouldAttach = true;
    }
    pairList.push(new TargetHandlerPair(target, handler));
    if (shouldAttach) {
        source.addEventListener(eventName, getHandlerForEventName(eventName));
    }
}
exports.addWeakEventListener = addWeakEventListener;
function removeWeakEventListener(source, eventName, handler, target) {
    validateArgs(source, eventName, handler, target);
    var handlerForEventWithName = handlersForEventName.get(eventName);
    if (!handlerForEventWithName) {
        return;
    }
    var sourceEventMap = sourcesMap.get(source);
    if (!sourceEventMap) {
        return;
    }
    var targetHandlerPairList = sourceEventMap.get(eventName);
    if (!targetHandlerPairList) {
        return;
    }
    var targetHandlerPairsToRemove = [];
    var pair;
    var registeredTarget;
    for (var i = 0; i < targetHandlerPairList.length; i++) {
        pair = targetHandlerPairList[i];
        registeredTarget = pair.tagetRef.get();
        if (!registeredTarget || (registeredTarget === target && handler === pair.handler)) {
            targetHandlerPairsToRemove.push(i);
        }
    }
    if (targetHandlerPairsToRemove.length === targetHandlerPairList.length) {
        source.removeEventListener(eventName, handlerForEventWithName);
        sourceEventMap.delete(eventName);
    }
    else {
        for (var j = targetHandlerPairsToRemove.length - 1; j >= 0; j--) {
            targetHandlerPairList.splice(targetHandlerPairsToRemove[j], 1);
        }
    }
}
exports.removeWeakEventListener = removeWeakEventListener;
//# sourceMappingURL=weak-event-listener.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/dialogs/dialogs-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var types_1 = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
exports.STRING = "string";
exports.PROMPT = "Prompt";
exports.CONFIRM = "Confirm";
exports.ALERT = "Alert";
exports.LOGIN = "Login";
exports.OK = "OK";
exports.CANCEL = "Cancel";
var inputType;
(function (inputType) {
    inputType.text = "text";
    inputType.password = "password";
    inputType.email = "email";
    inputType.number = "number";
    inputType.decimal = "decimal";
    inputType.phone = "phone";
})(inputType = exports.inputType || (exports.inputType = {}));
var capitalizationType;
(function (capitalizationType) {
    capitalizationType.none = "none";
    capitalizationType.all = "all";
    capitalizationType.sentences = "sentences";
    capitalizationType.words = "words";
})(capitalizationType = exports.capitalizationType || (exports.capitalizationType = {}));
var frame;
function getCurrentPage() {
    if (!frame) {
        frame = __webpack_require__("../node_modules/tns-core-modules/ui/frame/frame.js");
    }
    var topmostFrame = frame.topmost();
    if (topmostFrame) {
        return topmostFrame.currentPage;
    }
    return undefined;
}
exports.getCurrentPage = getCurrentPage;
function applySelectors(view, callback) {
    var currentPage = getCurrentPage();
    if (currentPage) {
        var styleScope = currentPage._styleScope;
        if (styleScope) {
            view._inheritStyleScope(styleScope);
            view.onLoaded();
            callback(view);
            view.onUnloaded();
        }
    }
}
var button;
var label;
var textField;
function getButtonColors() {
    if (!button) {
        var Button = __webpack_require__("../node_modules/tns-core-modules/ui/button/button.js").Button;
        button = new Button;
        if (platform_1.isIOS) {
            button._setupUI({});
        }
    }
    var buttonColor;
    var buttonBackgroundColor;
    applySelectors(button, function (btn) {
        buttonColor = btn.color;
        buttonBackgroundColor = btn.backgroundColor;
    });
    return { color: buttonColor, backgroundColor: buttonBackgroundColor };
}
exports.getButtonColors = getButtonColors;
function getLabelColor() {
    if (!label) {
        var Label = __webpack_require__("../node_modules/tns-core-modules/ui/label/label.js").Label;
        label = new Label;
        if (platform_1.isIOS) {
            label._setupUI({});
        }
    }
    var labelColor;
    applySelectors(label, function (lbl) {
        labelColor = lbl.color;
    });
    return labelColor;
}
exports.getLabelColor = getLabelColor;
function getTextFieldColor() {
    if (!textField) {
        var TextField = __webpack_require__("../node_modules/tns-core-modules/ui/text-field/text-field.js").TextField;
        textField = new TextField();
        if (platform_1.isIOS) {
            textField._setupUI({});
        }
    }
    var textFieldColor;
    applySelectors(textField, function (tf) {
        textFieldColor = tf.color;
    });
    return textFieldColor;
}
exports.getTextFieldColor = getTextFieldColor;
function isDialogOptions(arg) {
    return arg && (arg.message || arg.title);
}
exports.isDialogOptions = isDialogOptions;
function parseLoginOptions(args) {
    if (args.length === 1 && types_1.isObject(args[0])) {
        return args[0];
    }
    var options = { title: exports.LOGIN, okButtonText: exports.OK, cancelButtonText: exports.CANCEL };
    if (types_1.isString(args[0])) {
        options.message = args[0];
    }
    if (types_1.isString(args[1])) {
        options.userNameHint = args[1];
    }
    if (types_1.isString(args[2])) {
        options.passwordHint = args[2];
    }
    if (types_1.isString(args[3])) {
        options.userName = args[3];
    }
    if (types_1.isString(args[4])) {
        options.password = args[4];
    }
    return options;
}
exports.parseLoginOptions = parseLoginOptions;
//# sourceMappingURL=dialogs-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/dialogs/dialogs.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var dialogs_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/dialogs/dialogs-common.js");
var types_1 = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var application_1 = __webpack_require__("../node_modules/tns-core-modules/application/application.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/dialogs/dialogs-common.js"));
function addButtonsToAlertController(alertController, options, callback) {
    if (!options) {
        return;
    }
    if (types_1.isString(options.cancelButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.cancelButtonText, 0, function () {
            raiseCallback(callback, false);
        }));
    }
    if (types_1.isString(options.neutralButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.neutralButtonText, 0, function () {
            raiseCallback(callback, undefined);
        }));
    }
    if (types_1.isString(options.okButtonText)) {
        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.okButtonText, 0, function () {
            raiseCallback(callback, true);
        }));
    }
}
function raiseCallback(callback, result) {
    if (types_1.isFunction(callback)) {
        callback(result);
    }
}
function alert(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var options = !dialogs_common_1.isDialogOptions(arg) ? { title: dialogs_common_1.ALERT, okButtonText: dialogs_common_1.OK, message: arg + "" } : arg;
            var alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1);
            addButtonsToAlertController(alertController, options, function () { resolve(); });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.alert = alert;
function confirm(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var options = !dialogs_common_1.isDialogOptions(arg) ? { title: dialogs_common_1.CONFIRM, okButtonText: dialogs_common_1.OK, cancelButtonText: dialogs_common_1.CANCEL, message: arg + "" } : arg;
            var alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1);
            addButtonsToAlertController(alertController, options, function (r) { resolve(r); });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.confirm = confirm;
function prompt(arg) {
    var options;
    var defaultOptions = {
        title: dialogs_common_1.PROMPT,
        okButtonText: dialogs_common_1.OK,
        cancelButtonText: dialogs_common_1.CANCEL,
        inputType: dialogs_common_1.inputType.text,
    };
    if (arguments.length === 1) {
        if (types_1.isString(arg)) {
            options = defaultOptions;
            options.message = arg;
        }
        else {
            options = arg;
        }
    }
    else if (arguments.length === 2) {
        if (types_1.isString(arguments[0]) && types_1.isString(arguments[1])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.defaultText = arguments[1];
        }
    }
    return new Promise(function (resolve, reject) {
        try {
            var textField_1;
            var alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1);
            alertController.addTextFieldWithConfigurationHandler(function (arg) {
                arg.text = types_1.isString(options.defaultText) ? options.defaultText : "";
                arg.secureTextEntry = options && options.inputType === dialogs_common_1.inputType.password;
                if (options && options.inputType === dialogs_common_1.inputType.email) {
                    arg.keyboardType = 7;
                }
                else if (options && options.inputType === dialogs_common_1.inputType.number) {
                    arg.keyboardType = 4;
                }
                else if (options && options.inputType === dialogs_common_1.inputType.decimal) {
                    arg.keyboardType = 8;
                }
                else if (options && options.inputType === dialogs_common_1.inputType.phone) {
                    arg.keyboardType = 5;
                }
                var color = dialogs_common_1.getTextFieldColor();
                if (color) {
                    arg.textColor = arg.tintColor = color.ios;
                }
            });
            textField_1 = alertController.textFields.firstObject;
            if (options) {
                switch (options.capitalizationType) {
                    case dialogs_common_1.capitalizationType.all: {
                        textField_1.autocapitalizationType = 3;
                        break;
                    }
                    case dialogs_common_1.capitalizationType.sentences: {
                        textField_1.autocapitalizationType = 2;
                        break;
                    }
                    case dialogs_common_1.capitalizationType.words: {
                        textField_1.autocapitalizationType = 1;
                        break;
                    }
                    default: {
                        textField_1.autocapitalizationType = 0;
                    }
                }
            }
            addButtonsToAlertController(alertController, options, function (r) { resolve({ result: r, text: textField_1.text }); });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.prompt = prompt;
function login() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var options = dialogs_common_1.parseLoginOptions(args);
    return new Promise(function (resolve, reject) {
        try {
            var userNameTextField_1;
            var passwordTextField_1;
            var alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 1);
            var textFieldColor_1 = dialogs_common_1.getTextFieldColor();
            alertController.addTextFieldWithConfigurationHandler(function (arg) {
                arg.placeholder = "Login";
                arg.placeholder = options.userNameHint ? options.userNameHint : "";
                arg.text = types_1.isString(options.userName) ? options.userName : "";
                if (textFieldColor_1) {
                    arg.textColor = arg.tintColor = textFieldColor_1.ios;
                }
            });
            alertController.addTextFieldWithConfigurationHandler(function (arg) {
                arg.placeholder = "Password";
                arg.secureTextEntry = true;
                arg.placeholder = options.passwordHint ? options.passwordHint : "";
                arg.text = types_1.isString(options.password) ? options.password : "";
                if (textFieldColor_1) {
                    arg.textColor = arg.tintColor = textFieldColor_1.ios;
                }
            });
            userNameTextField_1 = alertController.textFields.firstObject;
            passwordTextField_1 = alertController.textFields.lastObject;
            addButtonsToAlertController(alertController, options, function (r) {
                resolve({
                    result: r,
                    userName: userNameTextField_1.text,
                    password: passwordTextField_1.text
                });
            });
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.login = login;
function showUIAlertController(alertController) {
    var _a, _b;
    var currentView = dialogs_common_1.getCurrentPage() || application_1.getRootView();
    if (currentView) {
        currentView = currentView.modal || currentView;
        var viewController = currentView.ios;
        if (!(currentView.ios instanceof UIViewController)) {
            var parentWithController = view_1.ios.getParentWithViewController(currentView);
            viewController = parentWithController ? parentWithController.viewController : undefined;
        }
        if (viewController) {
            if (alertController.popoverPresentationController) {
                alertController.popoverPresentationController.sourceView = viewController.view;
                alertController.popoverPresentationController.sourceRect = CGRectMake(viewController.view.bounds.size.width / 2.0, viewController.view.bounds.size.height / 2.0, 1.0, 1.0);
                alertController.popoverPresentationController.permittedArrowDirections = 0;
            }
            var color = dialogs_common_1.getButtonColors().color;
            if (color) {
                alertController.view.tintColor = color.ios;
            }
            var lblColor = dialogs_common_1.getLabelColor();
            if (lblColor) {
                if (alertController.title) {
                    var title = NSAttributedString.alloc().initWithStringAttributes(alertController.title, (_a = {}, _a[NSForegroundColorAttributeName] = lblColor.ios, _a));
                    alertController.setValueForKey(title, "attributedTitle");
                }
                if (alertController.message) {
                    var message = NSAttributedString.alloc().initWithStringAttributes(alertController.message, (_b = {}, _b[NSForegroundColorAttributeName] = lblColor.ios, _b));
                    alertController.setValueForKey(message, "attributedMessage");
                }
            }
            viewController.presentModalViewControllerAnimated(alertController, true);
        }
    }
}
function action() {
    var options;
    var defaultOptions = { title: null, cancelButtonText: dialogs_common_1.CANCEL };
    if (arguments.length === 1) {
        if (types_1.isString(arguments[0])) {
            options = defaultOptions;
            options.message = arguments[0];
        }
        else {
            options = arguments[0];
        }
    }
    else if (arguments.length === 2) {
        if (types_1.isString(arguments[0]) && types_1.isString(arguments[1])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.cancelButtonText = arguments[1];
        }
    }
    else if (arguments.length === 3) {
        if (types_1.isString(arguments[0]) && types_1.isString(arguments[1]) && types_1.isDefined(arguments[2])) {
            options = defaultOptions;
            options.message = arguments[0];
            options.cancelButtonText = arguments[1];
            options.actions = arguments[2];
        }
    }
    return new Promise(function (resolve, reject) {
        try {
            var i = void 0;
            var action_1;
            var alertController = UIAlertController.alertControllerWithTitleMessagePreferredStyle(options.title, options.message, 0);
            if (options.actions) {
                for (i = 0; i < options.actions.length; i++) {
                    action_1 = options.actions[i];
                    if (types_1.isString(action_1)) {
                        alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(action_1, 0, function (arg) {
                            resolve(arg.title);
                        }));
                    }
                }
            }
            if (types_1.isString(options.cancelButtonText)) {
                alertController.addAction(UIAlertAction.actionWithTitleStyleHandler(options.cancelButtonText, 1, function (arg) {
                    resolve(arg.title);
                }));
            }
            showUIAlertController(alertController);
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.action = action;
//# sourceMappingURL=dialogs.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var text_base_1 = __webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js"));
var EditableTextBase = (function (_super) {
    __extends(EditableTextBase, _super);
    function EditableTextBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EditableTextBase.blurEvent = "blur";
    EditableTextBase.focusEvent = "focus";
    return EditableTextBase;
}(text_base_1.TextBase));
exports.EditableTextBase = EditableTextBase;
exports.placeholderColorProperty = new text_base_1.CssProperty({ name: "placeholderColor", cssName: "placeholder-color", equalityComparer: text_base_1.Color.equals, valueConverter: function (v) { return new text_base_1.Color(v); } });
exports.placeholderColorProperty.register(text_base_1.Style);
var keyboardTypeConverter = text_base_1.makeParser(text_base_1.makeValidator("datetime", "phone", "number", "url", "email"));
exports.keyboardTypeProperty = new text_base_1.Property({ name: "keyboardType", valueConverter: keyboardTypeConverter });
exports.keyboardTypeProperty.register(EditableTextBase);
var returnKeyTypeConverter = text_base_1.makeParser(text_base_1.makeValidator("done", "next", "go", "search", "send"));
exports.returnKeyTypeProperty = new text_base_1.Property({ name: "returnKeyType", valueConverter: returnKeyTypeConverter });
exports.returnKeyTypeProperty.register(EditableTextBase);
exports.editableProperty = new text_base_1.Property({ name: "editable", defaultValue: true, valueConverter: text_base_1.booleanConverter });
exports.editableProperty.register(EditableTextBase);
exports.updateTextTriggerProperty = new text_base_1.Property({ name: "updateTextTrigger", defaultValue: "textChanged" });
exports.updateTextTriggerProperty.register(EditableTextBase);
var autocapitalizationTypeConverter = text_base_1.makeParser(text_base_1.makeValidator("none", "words", "sentences", "allcharacters"));
exports.autocapitalizationTypeProperty = new text_base_1.Property({ name: "autocapitalizationType", defaultValue: "sentences", valueConverter: autocapitalizationTypeConverter });
exports.autocapitalizationTypeProperty.register(EditableTextBase);
exports.autocorrectProperty = new text_base_1.Property({ name: "autocorrect", valueConverter: text_base_1.booleanConverter });
exports.autocorrectProperty.register(EditableTextBase);
exports.hintProperty = new text_base_1.Property({ name: "hint", defaultValue: "" });
exports.hintProperty.register(EditableTextBase);
exports.maxLengthProperty = new text_base_1.Property({ name: "maxLength", defaultValue: Number.POSITIVE_INFINITY, valueConverter: parseInt });
exports.maxLengthProperty.register(EditableTextBase);
//# sourceMappingURL=editable-text-base-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var editable_text_base_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base-common.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base-common.js"));
var EditableTextBase = (function (_super) {
    __extends(EditableTextBase, _super);
    function EditableTextBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EditableTextBase.prototype.dismissSoftInput = function () {
        this.nativeTextViewProtected.resignFirstResponder();
        this.notify({ eventName: EditableTextBase.blurEvent, object: this });
    };
    EditableTextBase.prototype[editable_text_base_common_1.keyboardTypeProperty.getDefault] = function () {
        var keyboardType = this.nativeTextViewProtected.keyboardType;
        switch (keyboardType) {
            case 2:
                return "number";
            case 5:
                return "phone";
            case 3:
                return "url";
            case 7:
                return "email";
            default:
                return keyboardType.toString();
        }
    };
    EditableTextBase.prototype[editable_text_base_common_1.keyboardTypeProperty.setNative] = function (value) {
        var newKeyboardType;
        switch (value) {
            case "datetime":
                newKeyboardType = 2;
                break;
            case "phone":
                newKeyboardType = 5;
                break;
            case "number":
                newKeyboardType = 2;
                break;
            case "url":
                newKeyboardType = 3;
                break;
            case "email":
                newKeyboardType = 7;
                break;
            default:
                var kt = +value;
                if (!isNaN(kt)) {
                    newKeyboardType = kt;
                }
                else {
                    newKeyboardType = 0;
                }
                break;
        }
        this.nativeTextViewProtected.keyboardType = newKeyboardType;
    };
    EditableTextBase.prototype[editable_text_base_common_1.returnKeyTypeProperty.getDefault] = function () {
        var returnKeyType = this.nativeTextViewProtected.returnKeyType;
        switch (returnKeyType) {
            case 9:
                return "done";
            case 1:
                return "go";
            case 4:
                return "next";
            case 6:
                return "search";
            case 7:
                return "send";
            default:
                return returnKeyType.toString();
        }
    };
    EditableTextBase.prototype[editable_text_base_common_1.returnKeyTypeProperty.setNative] = function (value) {
        var newValue;
        switch (value) {
            case "done":
                newValue = 9;
                break;
            case "go":
                newValue = 1;
                break;
            case "next":
                newValue = 4;
                break;
            case "search":
                newValue = 6;
                break;
            case "send":
                newValue = 7;
                break;
            default:
                var rkt = +value;
                if (!isNaN(rkt)) {
                    newValue = rkt;
                }
                else {
                    newValue = 0;
                }
                break;
        }
        this.nativeTextViewProtected.returnKeyType = newValue;
    };
    EditableTextBase.prototype[editable_text_base_common_1.autocapitalizationTypeProperty.getDefault] = function () {
        var autocapitalizationType = this.nativeTextViewProtected.autocapitalizationType;
        switch (autocapitalizationType) {
            case 0:
                return "none";
            case 1:
                return "words";
            case 2:
                return "sentences";
            case 3:
                return "allcharacters";
            default:
                throw new Error("Invalid autocapitalizationType value:" + autocapitalizationType);
        }
    };
    EditableTextBase.prototype[editable_text_base_common_1.autocapitalizationTypeProperty.setNative] = function (value) {
        var newValue;
        switch (value) {
            case "none":
                newValue = 0;
                break;
            case "words":
                newValue = 1;
                break;
            case "sentences":
                newValue = 2;
                break;
            case "allcharacters":
                newValue = 3;
                break;
            default:
                newValue = 2;
                break;
        }
        this.nativeTextViewProtected.autocapitalizationType = newValue;
    };
    EditableTextBase.prototype[editable_text_base_common_1.autocorrectProperty.getDefault] = function () {
        var autocorrectionType = this.nativeTextViewProtected.autocorrectionType;
        switch (autocorrectionType) {
            case 2:
                return true;
            case 1:
                return false;
            case 0:
                return autocorrectionType;
        }
    };
    EditableTextBase.prototype[editable_text_base_common_1.autocorrectProperty.setNative] = function (value) {
        var newValue;
        if (typeof value === "number") {
            newValue = 0;
        }
        else if (value) {
            newValue = 2;
        }
        else {
            newValue = 1;
        }
        this.nativeTextViewProtected.autocorrectionType = newValue;
    };
    return EditableTextBase;
}(editable_text_base_common_1.EditableTextBase));
exports.EditableTextBase = EditableTextBase;
function _updateCharactersInRangeReplacementString(formattedText, rangeLocation, rangeLength, replacementString) {
    var deletingText = !replacementString;
    var currentLocation = 0;
    for (var i = 0, length_1 = formattedText.spans.length; i < length_1; i++) {
        var span = formattedText.spans.getItem(i);
        if (currentLocation <= rangeLocation && rangeLocation < (currentLocation + span.text.length)) {
            var newText = splice(span.text, rangeLocation - currentLocation, deletingText ? rangeLength : 0, replacementString);
            span._setTextInternal(newText);
            return;
        }
        currentLocation += span.text.length;
    }
}
exports._updateCharactersInRangeReplacementString = _updateCharactersInRangeReplacementString;
function splice(value, start, delCount, newSubStr) {
    return value.slice(0, start) + newSubStr + value.slice(start + Math.abs(delCount));
}
//# sourceMappingURL=editable-text-base.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/enums/enums.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var KeyboardType;
(function (KeyboardType) {
    KeyboardType.datetime = "datetime";
    KeyboardType.phone = "phone";
    KeyboardType.number = "number";
    KeyboardType.url = "url";
    KeyboardType.email = "email";
})(KeyboardType = exports.KeyboardType || (exports.KeyboardType = {}));
var ReturnKeyType;
(function (ReturnKeyType) {
    ReturnKeyType.done = "done";
    ReturnKeyType.next = "next";
    ReturnKeyType.go = "go";
    ReturnKeyType.search = "search";
    ReturnKeyType.send = "send";
})(ReturnKeyType = exports.ReturnKeyType || (exports.ReturnKeyType = {}));
var TextAlignment;
(function (TextAlignment) {
    TextAlignment.left = "left";
    TextAlignment.center = "center";
    TextAlignment.right = "right";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var TextDecoration;
(function (TextDecoration) {
    TextDecoration.none = "none";
    TextDecoration.underline = "underline";
    TextDecoration.lineThrough = "line-through";
})(TextDecoration = exports.TextDecoration || (exports.TextDecoration = {}));
var TextTransform;
(function (TextTransform) {
    TextTransform.none = "none";
    TextTransform.capitalize = "capitalize";
    TextTransform.uppercase = "uppercase";
    TextTransform.lowercase = "lowercase";
})(TextTransform = exports.TextTransform || (exports.TextTransform = {}));
var WhiteSpace;
(function (WhiteSpace) {
    WhiteSpace.normal = "normal";
    WhiteSpace.nowrap = "nowrap";
})(WhiteSpace = exports.WhiteSpace || (exports.WhiteSpace = {}));
var Orientation;
(function (Orientation) {
    Orientation.horizontal = "horizontal";
    Orientation.vertical = "vertical";
})(Orientation = exports.Orientation || (exports.Orientation = {}));
var DeviceOrientation;
(function (DeviceOrientation) {
    DeviceOrientation.portrait = "portrait";
    DeviceOrientation.landscape = "landscape";
    DeviceOrientation.unknown = "unknown";
})(DeviceOrientation = exports.DeviceOrientation || (exports.DeviceOrientation = {}));
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment.left = "left";
    HorizontalAlignment.center = "center";
    HorizontalAlignment.right = "right";
    HorizontalAlignment.stretch = "stretch";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment.top = "top";
    VerticalAlignment.middle = "middle";
    VerticalAlignment.bottom = "bottom";
    VerticalAlignment.stretch = "stretch";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
var Stretch;
(function (Stretch) {
    Stretch.none = "none";
    Stretch.aspectFill = "aspectFill";
    Stretch.aspectFit = "aspectFit";
    Stretch.fill = "fill";
})(Stretch = exports.Stretch || (exports.Stretch = {}));
var Visibility;
(function (Visibility) {
    Visibility.visible = "visible";
    Visibility.collapse = "collapse";
    Visibility.collapsed = "collapsed";
})(Visibility = exports.Visibility || (exports.Visibility = {}));
var FontAttributes;
(function (FontAttributes) {
    FontAttributes.Normal = 0;
    FontAttributes.Bold = 1;
    FontAttributes.Italic = 1 << 1;
})(FontAttributes = exports.FontAttributes || (exports.FontAttributes = {}));
var DeviceType;
(function (DeviceType) {
    DeviceType.Phone = "Phone";
    DeviceType.Tablet = "Tablet";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
var UpdateTextTrigger;
(function (UpdateTextTrigger) {
    UpdateTextTrigger.focusLost = "focusLost";
    UpdateTextTrigger.textChanged = "textChanged";
})(UpdateTextTrigger = exports.UpdateTextTrigger || (exports.UpdateTextTrigger = {}));
var Accuracy;
(function (Accuracy) {
    Accuracy.any = 300;
    Accuracy.high = 3;
})(Accuracy = exports.Accuracy || (exports.Accuracy = {}));
var Dock;
(function (Dock) {
    Dock.left = "left";
    Dock.top = "top";
    Dock.right = "right";
    Dock.bottom = "bottom";
})(Dock = exports.Dock || (exports.Dock = {}));
var AutocapitalizationType;
(function (AutocapitalizationType) {
    AutocapitalizationType.none = "none";
    AutocapitalizationType.words = "words";
    AutocapitalizationType.sentences = "sentences";
    AutocapitalizationType.allCharacters = "allcharacters";
})(AutocapitalizationType = exports.AutocapitalizationType || (exports.AutocapitalizationType = {}));
var NavigationBarVisibility;
(function (NavigationBarVisibility) {
    NavigationBarVisibility.auto = "auto";
    NavigationBarVisibility.never = "never";
    NavigationBarVisibility.always = "always";
})(NavigationBarVisibility = exports.NavigationBarVisibility || (exports.NavigationBarVisibility = {}));
var AndroidActionBarIconVisibility;
(function (AndroidActionBarIconVisibility) {
    AndroidActionBarIconVisibility.auto = "auto";
    AndroidActionBarIconVisibility.never = "never";
    AndroidActionBarIconVisibility.always = "always";
})(AndroidActionBarIconVisibility = exports.AndroidActionBarIconVisibility || (exports.AndroidActionBarIconVisibility = {}));
var AndroidActionItemPosition;
(function (AndroidActionItemPosition) {
    AndroidActionItemPosition.actionBar = "actionBar";
    AndroidActionItemPosition.actionBarIfRoom = "actionBarIfRoom";
    AndroidActionItemPosition.popup = "popup";
})(AndroidActionItemPosition = exports.AndroidActionItemPosition || (exports.AndroidActionItemPosition = {}));
var IOSActionItemPosition;
(function (IOSActionItemPosition) {
    IOSActionItemPosition.left = "left";
    IOSActionItemPosition.right = "right";
})(IOSActionItemPosition = exports.IOSActionItemPosition || (exports.IOSActionItemPosition = {}));
var ImageFormat;
(function (ImageFormat) {
    ImageFormat.png = "png";
    ImageFormat.jpeg = "jpeg";
    ImageFormat.jpg = "jpg";
})(ImageFormat = exports.ImageFormat || (exports.ImageFormat = {}));
var FontStyle;
(function (FontStyle) {
    FontStyle.normal = "normal";
    FontStyle.italic = "italic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
var FontWeight;
(function (FontWeight) {
    FontWeight.thin = "100";
    FontWeight.extraLight = "200";
    FontWeight.light = "300";
    FontWeight.normal = "normal";
    FontWeight.medium = "500";
    FontWeight.semiBold = "600";
    FontWeight.bold = "bold";
    FontWeight.extraBold = "800";
    FontWeight.black = "900";
})(FontWeight = exports.FontWeight || (exports.FontWeight = {}));
var BackgroundRepeat;
(function (BackgroundRepeat) {
    BackgroundRepeat.repeat = "repeat";
    BackgroundRepeat.repeatX = "repeat-x";
    BackgroundRepeat.repeatY = "repeat-y";
    BackgroundRepeat.noRepeat = "no-repeat";
})(BackgroundRepeat = exports.BackgroundRepeat || (exports.BackgroundRepeat = {}));
var animation;
var AnimationCurve;
(function (AnimationCurve) {
    AnimationCurve.ease = "ease";
    AnimationCurve.easeIn = "easeIn";
    AnimationCurve.easeOut = "easeOut";
    AnimationCurve.easeInOut = "easeInOut";
    AnimationCurve.linear = "linear";
    AnimationCurve.spring = "spring";
    function cubicBezier(x1, y1, x2, y2) {
        animation = animation || __webpack_require__("../node_modules/tns-core-modules/ui/animation/animation.js");
        return new animation.CubicBezierAnimationCurve(x1, y1, x2, y2);
    }
    AnimationCurve.cubicBezier = cubicBezier;
})(AnimationCurve = exports.AnimationCurve || (exports.AnimationCurve = {}));
var StatusBarStyle;
(function (StatusBarStyle) {
    StatusBarStyle.light = "light";
    StatusBarStyle.dark = "dark";
})(StatusBarStyle = exports.StatusBarStyle || (exports.StatusBarStyle = {}));
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/frame/fragment.transitions.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var slide_transition_1 = __webpack_require__("../node_modules/tns-core-modules/ui/transition/slide-transition.js");
var fade_transition_1 = __webpack_require__("../node_modules/tns-core-modules/ui/transition/fade-transition.js");
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var UIViewControllerAnimatedTransitioningMethods;
(function (UIViewControllerAnimatedTransitioningMethods) {
    var methodSignature = NSMethodSignature.signatureWithObjCTypes("v@:c");
    var invocation = NSInvocation.invocationWithMethodSignature(methodSignature);
    invocation.selector = "completeTransition:";
    function completeTransition(didComplete) {
        var didCompleteReference = new interop.Reference(interop.types.bool, didComplete);
        invocation.setArgumentAtIndex(didCompleteReference, 2);
        invocation.invokeWithTarget(this);
    }
    UIViewControllerAnimatedTransitioningMethods.completeTransition = completeTransition;
})(UIViewControllerAnimatedTransitioningMethods || (UIViewControllerAnimatedTransitioningMethods = {}));
var AnimatedTransitioning = (function (_super) {
    __extends(AnimatedTransitioning, _super);
    function AnimatedTransitioning() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimatedTransitioning.init = function (transition, operation, fromVC, toVC) {
        var impl = AnimatedTransitioning.new();
        impl._transition = transition;
        impl._operation = operation;
        impl._fromVC = fromVC;
        impl._toVC = toVC;
        return impl;
    };
    AnimatedTransitioning.prototype.animateTransition = function (transitionContext) {
        var containerView = transitionContext.valueForKey("containerView");
        var completion = UIViewControllerAnimatedTransitioningMethods.completeTransition.bind(transitionContext);
        switch (this._operation) {
            case 1:
                this._transitionType = "push";
                break;
            case 2:
                this._transitionType = "pop";
                break;
            case 0:
                this._transitionType = "none";
                break;
        }
        if (trace_1.isEnabled()) {
            trace_1.write("START " + this._transition + " " + this._transitionType, trace_1.categories.Transition);
        }
        this._transition.animateIOSTransition(containerView, this._fromVC.view, this._toVC.view, this._operation, completion);
    };
    AnimatedTransitioning.prototype.transitionDuration = function (transitionContext) {
        return this._transition.getDuration();
    };
    AnimatedTransitioning.prototype.animationEnded = function (transitionCompleted) {
        if (transitionCompleted) {
            if (trace_1.isEnabled()) {
                trace_1.write("END " + this._transition + " " + this._transitionType, trace_1.categories.Transition);
            }
        }
        else {
            if (trace_1.isEnabled()) {
                trace_1.write("CANCEL " + this._transition + " " + this._transitionType, trace_1.categories.Transition);
            }
        }
    };
    AnimatedTransitioning.ObjCProtocols = [UIViewControllerAnimatedTransitioning];
    return AnimatedTransitioning;
}(NSObject));
function _createIOSAnimatedTransitioning(navigationTransition, nativeCurve, operation, fromVC, toVC) {
    var instance = navigationTransition.instance;
    var transition;
    if (instance) {
        transition = instance;
    }
    else if (navigationTransition.name) {
        var name_1 = navigationTransition.name.toLowerCase();
        if (name_1.indexOf("slide") === 0) {
            var direction = name_1.substr("slide".length) || "left";
            transition = new slide_transition_1.SlideTransition(direction, navigationTransition.duration, nativeCurve);
        }
        else if (name_1 === "fade") {
            transition = new fade_transition_1.FadeTransition(navigationTransition.duration, nativeCurve);
        }
    }
    return transition ? AnimatedTransitioning.init(transition, operation, fromVC, toVC) : undefined;
}
exports._createIOSAnimatedTransitioning = _createIOSAnimatedTransitioning;
//# sourceMappingURL=fragment.transitions.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/frame/frame-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var view_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view-common.js");
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var builder_1 = __webpack_require__("../node_modules/tns-core-modules/ui/builder/builder.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var frame_stack_1 = __webpack_require__("../node_modules/tns-core-modules/ui/frame/frame-stack.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js"));
var NavigationType;
(function (NavigationType) {
    NavigationType[NavigationType["back"] = 0] = "back";
    NavigationType[NavigationType["forward"] = 1] = "forward";
    NavigationType[NavigationType["replace"] = 2] = "replace";
})(NavigationType = exports.NavigationType || (exports.NavigationType = {}));
function buildEntryFromArgs(arg) {
    var entry;
    if (typeof arg === "string") {
        entry = {
            moduleName: arg
        };
    }
    else if (typeof arg === "function") {
        entry = {
            create: arg
        };
    }
    else {
        entry = arg;
    }
    return entry;
}
var FrameBase = (function (_super) {
    __extends(FrameBase, _super);
    function FrameBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._backStack = new Array();
        _this._navigationQueue = new Array();
        _this._isInFrameStack = false;
        return _this;
    }
    FrameBase_1 = FrameBase;
    FrameBase.prototype._addChildFromBuilder = function (name, value) {
        throw new Error("Frame should not have a view. Use 'defaultPage' property instead.");
    };
    FrameBase.prototype.onLoaded = function () {
        _super.prototype.onLoaded.call(this);
        this._processNextNavigationEntry();
    };
    FrameBase.prototype.canGoBack = function () {
        var _this = this;
        var backstack = this._backStack.length;
        var previousForwardNotInBackstack = false;
        this._navigationQueue.forEach(function (item) {
            var entry = item.entry;
            if (item.isBackNavigation) {
                previousForwardNotInBackstack = false;
                if (!entry) {
                    backstack--;
                }
                else {
                    var backstackIndex = _this._backStack.indexOf(entry);
                    if (backstackIndex !== -1) {
                        backstack = backstackIndex;
                    }
                    else {
                        backstack--;
                    }
                }
            }
            else if (entry.entry.clearHistory) {
                previousForwardNotInBackstack = false;
                backstack = 0;
            }
            else {
                backstack++;
                if (previousForwardNotInBackstack) {
                    backstack--;
                }
                previousForwardNotInBackstack = entry.entry.backstackVisible === false;
            }
        });
        if (this._navigationQueue.length > 0 && !this._currentEntry) {
            backstack--;
        }
        return backstack > 0;
    };
    FrameBase.prototype.goBack = function (backstackEntry) {
        if (view_1.traceEnabled()) {
            view_1.traceWrite("GO BACK", view_1.traceCategories.Navigation);
        }
        if (!this.canGoBack()) {
            return;
        }
        if (backstackEntry) {
            var index_1 = this._backStack.indexOf(backstackEntry);
            if (index_1 < 0) {
                return;
            }
        }
        var navigationContext = {
            entry: backstackEntry,
            isBackNavigation: true
        };
        this._navigationQueue.push(navigationContext);
        this._processNextNavigationEntry();
    };
    FrameBase.prototype._removeEntry = function (removed) {
        var page = removed.resolvedPage;
        var frame = page.frame;
        page._frame = null;
        if (frame) {
            frame._removeView(page);
        }
        else {
            page._tearDownUI(true);
        }
    };
    FrameBase.prototype.navigate = function (param) {
        if (view_1.traceEnabled()) {
            view_1.traceWrite("NAVIGATE", view_1.traceCategories.Navigation);
        }
        var entry = buildEntryFromArgs(param);
        var page = builder_1.createViewFromEntry(entry);
        this._pushInFrameStack();
        var backstackEntry = {
            entry: entry,
            resolvedPage: page,
            navDepth: undefined,
            fragmentTag: undefined
        };
        var navigationContext = {
            entry: backstackEntry,
            isBackNavigation: false
        };
        this._navigationQueue.push(navigationContext);
        this._processNextNavigationEntry();
    };
    FrameBase.prototype.isCurrent = function (entry) {
        return this._currentEntry === entry;
    };
    FrameBase.prototype.setCurrent = function (entry, navigationType) {
        var newPage = entry.resolvedPage;
        if (!newPage.frame) {
            this._addView(newPage);
            newPage._frame = this;
        }
        this._currentEntry = entry;
        var isBack = navigationType === NavigationType.back;
        if (isBack) {
            this._pushInFrameStack();
        }
        newPage.onNavigatedTo(isBack);
        this._executingEntry = null;
    };
    FrameBase.prototype._updateBackstack = function (entry, navigationType) {
        var _this = this;
        var isBack = navigationType === NavigationType.back;
        var isReplace = navigationType === NavigationType.replace;
        this.raiseCurrentPageNavigatedEvents(isBack);
        var current = this._currentEntry;
        if (isBack) {
            var index_2 = this._backStack.indexOf(entry);
            this._backStack.splice(index_2 + 1).forEach(function (e) { return _this._removeEntry(e); });
            this._backStack.pop();
        }
        else if (!isReplace) {
            if (entry.entry.clearHistory) {
                this._backStack.forEach(function (e) { return _this._removeEntry(e); });
                this._backStack.length = 0;
            }
            else if (FrameBase_1._isEntryBackstackVisible(current)) {
                this._backStack.push(current);
            }
        }
        if (current && this._backStack.indexOf(current) < 0) {
            this._removeEntry(current);
        }
    };
    FrameBase.prototype.isNestedWithin = function (parentFrameCandidate) {
        var frameAncestor = this;
        while (frameAncestor) {
            frameAncestor = view_common_1.getAncestor(frameAncestor, FrameBase_1);
            if (frameAncestor === parentFrameCandidate) {
                return true;
            }
        }
        return false;
    };
    FrameBase.prototype.raiseCurrentPageNavigatedEvents = function (isBack) {
        var page = this.currentPage;
        if (page) {
            if (page.isLoaded) {
                page.callUnloaded();
            }
            page.onNavigatedFrom(isBack);
        }
    };
    FrameBase.prototype._processNavigationQueue = function (page) {
        if (this._navigationQueue.length === 0) {
            return;
        }
        var entry = this._navigationQueue[0].entry;
        var currentNavigationPage = entry.resolvedPage;
        if (page !== currentNavigationPage) {
            return;
        }
        this._navigationQueue.shift();
        this._processNextNavigationEntry();
        this._updateActionBar();
    };
    FrameBase.prototype._findEntryForTag = function (fragmentTag) {
        var entry;
        if (this._currentEntry && this._currentEntry.fragmentTag === fragmentTag) {
            entry = this._currentEntry;
        }
        else {
            entry = this._backStack.find(function (value) { return value.fragmentTag === fragmentTag; });
            if (!entry) {
                var navigationItem = this._navigationQueue.find(function (value) { return value.entry.fragmentTag === fragmentTag; });
                entry = navigationItem ? navigationItem.entry : undefined;
            }
        }
        return entry;
    };
    FrameBase.prototype.navigationQueueIsEmpty = function () {
        return this._navigationQueue.length === 0;
    };
    FrameBase._isEntryBackstackVisible = function (entry) {
        if (!entry) {
            return false;
        }
        var backstackVisibleValue = entry.entry.backstackVisible;
        var backstackHidden = backstackVisibleValue !== undefined && !backstackVisibleValue;
        return !backstackHidden;
    };
    FrameBase.prototype._updateActionBar = function (page, disableNavBarAnimation) {
    };
    FrameBase.prototype._processNextNavigationEntry = function () {
        if (!this.isLoaded || this._executingEntry) {
            return;
        }
        if (this._navigationQueue.length > 0) {
            var navigationContext = this._navigationQueue[0];
            if (navigationContext.isBackNavigation) {
                this.performGoBack(navigationContext);
            }
            else {
                this.performNavigation(navigationContext);
            }
        }
    };
    FrameBase.prototype.performNavigation = function (navigationContext) {
        var navContext = navigationContext.entry;
        this._executingEntry = navContext;
        this._onNavigatingTo(navContext, navigationContext.isBackNavigation);
        this._navigateCore(navContext);
    };
    FrameBase.prototype.performGoBack = function (navigationContext) {
        var backstackEntry = navigationContext.entry;
        var backstack = this._backStack;
        if (!backstackEntry) {
            backstackEntry = backstack[backstack.length - 1];
            navigationContext.entry = backstackEntry;
        }
        this._executingEntry = backstackEntry;
        this._onNavigatingTo(backstackEntry, true);
        this._goBackCore(backstackEntry);
    };
    FrameBase.prototype._goBackCore = function (backstackEntry) {
        if (view_1.traceEnabled()) {
            view_1.traceWrite("GO BACK CORE(" + this._backstackEntryTrace(backstackEntry) + "); currentPage: " + this.currentPage, view_1.traceCategories.Navigation);
        }
    };
    FrameBase.prototype._navigateCore = function (backstackEntry) {
        if (view_1.traceEnabled()) {
            view_1.traceWrite("NAVIGATE CORE(" + this._backstackEntryTrace(backstackEntry) + "); currentPage: " + this.currentPage, view_1.traceCategories.Navigation);
        }
    };
    FrameBase.prototype._onNavigatingTo = function (backstackEntry, isBack) {
        if (this.currentPage) {
            this.currentPage.onNavigatingFrom(isBack);
        }
        backstackEntry.resolvedPage.onNavigatingTo(backstackEntry.entry.context, isBack, backstackEntry.entry.bindingContext);
    };
    Object.defineProperty(FrameBase.prototype, "animated", {
        get: function () {
            return this._animated;
        },
        set: function (value) {
            this._animated = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameBase.prototype, "transition", {
        get: function () {
            return this._transition;
        },
        set: function (value) {
            this._transition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameBase.prototype, "backStack", {
        get: function () {
            return this._backStack.slice();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameBase.prototype, "currentPage", {
        get: function () {
            if (this._currentEntry) {
                return this._currentEntry.resolvedPage;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameBase.prototype, "currentEntry", {
        get: function () {
            if (this._currentEntry) {
                return this._currentEntry.entry;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    FrameBase.prototype._pushInFrameStackRecursive = function () {
        this._pushInFrameStack();
        var framesToPush = [];
        for (var _i = 0, frameStack_1 = frame_stack_1.frameStack; _i < frameStack_1.length; _i++) {
            var frame = frameStack_1[_i];
            if (frame.isNestedWithin(this)) {
                framesToPush.push(frame);
            }
        }
        for (var _a = 0, framesToPush_1 = framesToPush; _a < framesToPush_1.length; _a++) {
            var frame = framesToPush_1[_a];
            frame._pushInFrameStack();
        }
    };
    FrameBase.prototype._pushInFrameStack = function () {
        frame_stack_1._pushInFrameStack(this);
    };
    FrameBase.prototype._popFromFrameStack = function () {
        frame_stack_1._popFromFrameStack(this);
    };
    FrameBase.prototype._removeFromFrameStack = function () {
        frame_stack_1._removeFromFrameStack(this);
    };
    FrameBase.prototype._dialogClosed = function () {
        this._removeFromFrameStack();
    };
    FrameBase.prototype._onRootViewReset = function () {
        _super.prototype._onRootViewReset.call(this);
        this._removeFromFrameStack();
    };
    Object.defineProperty(FrameBase.prototype, "_childrenCount", {
        get: function () {
            if (this.currentPage) {
                return 1;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    FrameBase.prototype.eachChildView = function (callback) {
        var page = this.currentPage;
        if (page) {
            callback(page);
        }
    };
    FrameBase.prototype._getIsAnimatedNavigation = function (entry) {
        if (entry && entry.animated !== undefined) {
            return entry.animated;
        }
        if (this.animated !== undefined) {
            return this.animated;
        }
        return FrameBase_1.defaultAnimatedNavigation;
    };
    FrameBase.prototype._getNavigationTransition = function (entry) {
        if (entry) {
            if (view_1.isIOS && entry.transitioniOS !== undefined) {
                return entry.transitioniOS;
            }
            if (view_1.isAndroid && entry.transitionAndroid !== undefined) {
                return entry.transitionAndroid;
            }
            if (entry.transition !== undefined) {
                return entry.transition;
            }
        }
        if (this.transition !== undefined) {
            return this.transition;
        }
        return FrameBase_1.defaultTransition;
    };
    Object.defineProperty(FrameBase.prototype, "navigationBarHeight", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    FrameBase.prototype._getNavBarVisible = function (page) {
        throw new Error();
    };
    FrameBase.prototype._addViewToNativeVisualTree = function (child) {
        return true;
    };
    FrameBase.prototype._removeViewFromNativeVisualTree = function (child) {
        child._isAddedToNativeVisualTree = false;
    };
    FrameBase.prototype._printFrameBackStack = function () {
        var length = this.backStack.length;
        var i = length - 1;
        console.log("Frame Back Stack: ");
        while (i >= 0) {
            var backstackEntry = this.backStack[i--];
            console.log("\t" + backstackEntry.resolvedPage);
        }
    };
    FrameBase.prototype._backstackEntryTrace = function (b) {
        var result = "" + b.resolvedPage;
        var backstackVisible = FrameBase_1._isEntryBackstackVisible(b);
        if (!backstackVisible) {
            result += " | INVISIBLE";
        }
        if (b.entry.clearHistory) {
            result += " | CLEAR HISTORY";
        }
        var animated = this._getIsAnimatedNavigation(b.entry);
        if (!animated) {
            result += " | NOT ANIMATED";
        }
        var t = this._getNavigationTransition(b.entry);
        if (t) {
            result += " | Transition[" + JSON.stringify(t) + "]";
        }
        return result;
    };
    FrameBase.prototype._onLivesync = function (context) {
        if (_super.prototype._onLivesync.call(this, context)) {
            return true;
        }
        if (!context) {
            return this.legacyLivesync();
        }
        return false;
    };
    FrameBase.prototype._handleLivesync = function (context) {
        if (_super.prototype._handleLivesync.call(this, context)) {
            return true;
        }
        if (this.currentPage &&
            view_common_1.viewMatchesModuleContext(this.currentPage, context, ["markup", "script"])) {
            view_1.traceWrite("Change Handled: Replacing page " + context.path, view_1.traceCategories.Livesync);
            this.replacePage(context);
            return true;
        }
        return false;
    };
    FrameBase.prototype.legacyLivesync = function () {
        if (view_1.traceEnabled()) {
            view_1.traceWrite(this + "._onLivesync()", view_1.traceCategories.Livesync);
        }
        if (!this._currentEntry || !this._currentEntry.entry) {
            return false;
        }
        var currentEntry = this._currentEntry.entry;
        var newEntry = {
            animated: false,
            clearHistory: true,
            context: currentEntry.context,
            create: currentEntry.create,
            moduleName: currentEntry.moduleName,
            backstackVisible: currentEntry.backstackVisible
        };
        if (newEntry.create) {
            var page = newEntry.create();
            if (page === this.currentPage) {
                return false;
            }
        }
        this.navigate(newEntry);
        return true;
    };
    FrameBase.prototype.replacePage = function (context) {
        this.navigationType = NavigationType.replace;
        var currentBackstackEntry = this._currentEntry;
        var contextModuleName = utils_1.getModuleName(context.path);
        var newPage = builder_1.createViewFromEntry({ moduleName: contextModuleName });
        var newBackstackEntry = {
            entry: currentBackstackEntry.entry,
            resolvedPage: newPage,
            navDepth: currentBackstackEntry.navDepth,
            fragmentTag: currentBackstackEntry.fragmentTag,
            frameId: currentBackstackEntry.frameId
        };
        var navContext = { entry: newBackstackEntry, isBackNavigation: false };
        this.performNavigation(navContext);
    };
    var FrameBase_1;
    FrameBase.androidOptionSelectedEvent = "optionSelected";
    FrameBase.defaultAnimatedNavigation = true;
    __decorate([
        profiling_1.profile
    ], FrameBase.prototype, "onLoaded", null);
    __decorate([
        profiling_1.profile
    ], FrameBase.prototype, "performNavigation", null);
    __decorate([
        profiling_1.profile
    ], FrameBase.prototype, "performGoBack", null);
    FrameBase = FrameBase_1 = __decorate([
        view_1.CSSType("Frame")
    ], FrameBase);
    return FrameBase;
}(view_1.CustomLayoutView));
exports.FrameBase = FrameBase;
function getFrameById(id) {
    return frame_stack_1.frameStack.find(function (frame) { return frame.id && frame.id === id; });
}
exports.getFrameById = getFrameById;
function topmost() {
    return frame_stack_1.topmost();
}
exports.topmost = topmost;
function goBack() {
    var top = topmost();
    if (top && top.canGoBack()) {
        top.goBack();
        return true;
    }
    else if (top) {
        var parentFrameCanGoBack = false;
        var parentFrame = view_common_1.getAncestor(top, "Frame");
        while (parentFrame && !parentFrameCanGoBack) {
            if (parentFrame && parentFrame.canGoBack()) {
                parentFrameCanGoBack = true;
            }
            else {
                parentFrame = view_common_1.getAncestor(parentFrame, "Frame");
            }
        }
        if (parentFrame && parentFrameCanGoBack) {
            parentFrame.goBack();
            return true;
        }
    }
    if (frame_stack_1.frameStack.length > 1) {
        top._popFromFrameStack();
    }
    return false;
}
exports.goBack = goBack;
function stack() {
    return frame_stack_1.frameStack;
}
exports.stack = stack;
exports.defaultPage = new view_1.Property({
    name: "defaultPage", valueChanged: function (frame, oldValue, newValue) {
        frame.navigate({ moduleName: newValue });
    }
});
exports.defaultPage.register(FrameBase);
exports.actionBarVisibilityProperty = new view_1.Property({ name: "actionBarVisibility", defaultValue: "auto", affectsLayout: view_1.isIOS });
exports.actionBarVisibilityProperty.register(FrameBase);
//# sourceMappingURL=frame-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/frame/frame-stack.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.frameStack = [];
function topmost() {
    if (exports.frameStack.length > 0) {
        return exports.frameStack[exports.frameStack.length - 1];
    }
    return undefined;
}
exports.topmost = topmost;
function _pushInFrameStack(frame) {
    if (frame._isInFrameStack && exports.frameStack[exports.frameStack.length - 1] === frame) {
        return;
    }
    if (frame._isInFrameStack) {
        var indexOfFrame = exports.frameStack.indexOf(frame);
        exports.frameStack.splice(indexOfFrame, 1);
    }
    exports.frameStack.push(frame);
    frame._isInFrameStack = true;
}
exports._pushInFrameStack = _pushInFrameStack;
function _popFromFrameStack(frame) {
    if (!frame._isInFrameStack) {
        return;
    }
    var top = topmost();
    if (top !== frame) {
        throw new Error("Cannot pop a Frame which is not at the top of the navigation stack.");
    }
    exports.frameStack.pop();
    frame._isInFrameStack = false;
}
exports._popFromFrameStack = _popFromFrameStack;
function _removeFromFrameStack(frame) {
    if (!frame._isInFrameStack) {
        return;
    }
    var index = exports.frameStack.indexOf(frame);
    exports.frameStack.splice(index, 1);
    frame._isInFrameStack = false;
}
exports._removeFromFrameStack = _removeFromFrameStack;
//# sourceMappingURL=frame-stack.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/frame/frame.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var frame_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/frame/frame-common.js");
var fragment_transitions_1 = __webpack_require__("../node_modules/tns-core-modules/ui/frame/fragment.transitions.js");
var utils = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/frame/frame-common.js"));
var majorVersion = utils.ios.MajorVersion;
var ENTRY = "_entry";
var DELEGATE = "_delegate";
var NAV_DEPTH = "_navDepth";
var TRANSITION = "_transition";
var NON_ANIMATED_TRANSITION = "non-animated";
var HMR_REPLACE_TRANSITION = "fade";
var navDepth = -1;
var Frame = (function (_super) {
    __extends(Frame, _super);
    function Frame() {
        var _this = _super.call(this) || this;
        _this._animatedDelegate = UINavigationControllerAnimatedDelegate.new();
        _this._ios = new iOSFrame(_this);
        _this.viewController = _this._ios.controller;
        return _this;
    }
    Frame.prototype.createNativeView = function () {
        return this.viewController.view;
    };
    Frame.prototype.disposeNativeView = function () {
        this._removeFromFrameStack();
        this.viewController = null;
        this._ios.controller = null;
        _super.prototype.disposeNativeView.call(this);
    };
    Object.defineProperty(Frame.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    Frame.prototype.setCurrent = function (entry, navigationType) {
        var current = this._currentEntry;
        var currentEntryChanged = current !== entry;
        if (currentEntryChanged) {
            this._updateBackstack(entry, navigationType);
            _super.prototype.setCurrent.call(this, entry, navigationType);
        }
    };
    Frame.prototype._navigateCore = function (backstackEntry) {
        var isReplace = this.navigationType === frame_common_1.NavigationType.replace;
        if (!isReplace) {
            this.navigationType = frame_common_1.NavigationType.forward;
        }
        _super.prototype._navigateCore.call(this, backstackEntry);
        var viewController = backstackEntry.resolvedPage.ios;
        if (!viewController) {
            throw new Error("Required page does not have a viewController created.");
        }
        var clearHistory = backstackEntry.entry.clearHistory;
        if (clearHistory) {
            navDepth = -1;
        }
        if (!isReplace) {
            navDepth++;
        }
        var navigationTransition;
        var animated = this.currentPage ? this._getIsAnimatedNavigation(backstackEntry.entry) : false;
        if (isReplace) {
            animated = true;
            navigationTransition = { name: HMR_REPLACE_TRANSITION, duration: 100 };
            viewController[TRANSITION] = navigationTransition;
        }
        else if (animated) {
            navigationTransition = this._getNavigationTransition(backstackEntry.entry);
            if (navigationTransition) {
                viewController[TRANSITION] = navigationTransition;
            }
        }
        else {
            viewController[TRANSITION] = { name: NON_ANIMATED_TRANSITION };
        }
        var nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!nativeTransition && navigationTransition) {
            this._ios.controller.delegate = this._animatedDelegate;
            viewController[DELEGATE] = this._animatedDelegate;
        }
        else {
            viewController[DELEGATE] = null;
            this._ios.controller.delegate = null;
        }
        backstackEntry[NAV_DEPTH] = navDepth;
        viewController[ENTRY] = backstackEntry;
        if (!animated && majorVersion > 10) {
            var barButtonItem = UIBarButtonItem.alloc().initWithTitleStyleTargetAction("", 0, null, null);
            viewController.navigationItem.backBarButtonItem = barButtonItem;
        }
        if (!this._currentEntry) {
            this._updateActionBar(backstackEntry.resolvedPage, true);
            this._ios.controller.pushViewControllerAnimated(viewController, animated);
            if (frame_common_1.traceEnabled()) {
                frame_common_1.traceWrite(this + ".pushViewControllerAnimated(" + viewController + ", " + animated + "); depth = " + navDepth, frame_common_1.traceCategories.Navigation);
            }
            return;
        }
        if (clearHistory) {
            viewController.navigationItem.hidesBackButton = true;
            var newControllers = NSMutableArray.alloc().initWithCapacity(1);
            newControllers.addObject(viewController);
            var oldControllers = this._ios.controller.viewControllers;
            for (var i = 0; i < oldControllers.count; i++) {
                oldControllers.objectAtIndex(i).isBackstackCleared = true;
            }
            this._ios.controller.setViewControllersAnimated(newControllers, animated);
            if (frame_common_1.traceEnabled()) {
                frame_common_1.traceWrite(this + ".setViewControllersAnimated([" + viewController + "], " + animated + "); depth = " + navDepth, frame_common_1.traceCategories.Navigation);
            }
            return;
        }
        if (!Frame._isEntryBackstackVisible(this._currentEntry) || isReplace) {
            var newControllers = NSMutableArray.alloc().initWithArray(this._ios.controller.viewControllers);
            if (newControllers.count === 0) {
                throw new Error("Wrong controllers count.");
            }
            viewController.navigationItem.hidesBackButton = this.backStack.length === 0;
            var skippedNavController = newControllers.lastObject;
            skippedNavController.isBackstackSkipped = true;
            newControllers.removeLastObject();
            newControllers.addObject(viewController);
            this._ios.controller.setViewControllersAnimated(newControllers, animated);
            if (frame_common_1.traceEnabled()) {
                frame_common_1.traceWrite(this + ".setViewControllersAnimated([originalControllers - lastController + " + viewController + "], " + animated + "); depth = " + navDepth, frame_common_1.traceCategories.Navigation);
            }
            return;
        }
        this._ios.controller.pushViewControllerAnimated(viewController, animated);
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite(this + ".pushViewControllerAnimated(" + viewController + ", " + animated + "); depth = " + navDepth, frame_common_1.traceCategories.Navigation);
        }
    };
    Frame.prototype._goBackCore = function (backstackEntry) {
        this.navigationType = frame_common_1.NavigationType.back;
        _super.prototype._goBackCore.call(this, backstackEntry);
        navDepth = backstackEntry[NAV_DEPTH];
        var controller = backstackEntry.resolvedPage.ios;
        var animated = this._currentEntry ? this._getIsAnimatedNavigation(this._currentEntry.entry) : false;
        this._updateActionBar(backstackEntry.resolvedPage);
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite(this + ".popToViewControllerAnimated(" + controller + ", " + animated + "); depth = " + navDepth, frame_common_1.traceCategories.Navigation);
        }
        this._ios.controller.popToViewControllerAnimated(controller, animated);
    };
    Frame.prototype._updateActionBar = function (page, disableNavBarAnimation) {
        if (disableNavBarAnimation === void 0) { disableNavBarAnimation = false; }
        _super.prototype._updateActionBar.call(this, page);
        if (page && this.currentPage && this.currentPage.modal === page) {
            return;
        }
        page = page || this.currentPage;
        var newValue = this._getNavBarVisible(page);
        var disableNavBarAnimationCache = this._ios._disableNavBarAnimation;
        if (disableNavBarAnimation) {
            this._ios._disableNavBarAnimation = true;
        }
        this._ios.showNavigationBar = newValue;
        if (disableNavBarAnimation) {
            this._ios._disableNavBarAnimation = disableNavBarAnimationCache;
        }
        if (this._ios.controller.navigationBar) {
            this._ios.controller.navigationBar.userInteractionEnabled = this.navigationQueueIsEmpty();
        }
    };
    Frame.prototype._getNavBarVisible = function (page) {
        switch (this.actionBarVisibility) {
            case "always":
                return true;
            case "never":
                return false;
            case "auto":
                switch (this._ios.navBarVisibility) {
                    case "always":
                        return true;
                    case "never":
                        return false;
                    case "auto":
                        var newValue = void 0;
                        if (page && page.actionBarHidden !== undefined) {
                            newValue = !page.actionBarHidden;
                        }
                        else {
                            newValue = this.ios.controller.viewControllers.count > 1 || (page && page.actionBar && !page.actionBar._isEmpty());
                        }
                        newValue = !!newValue;
                        return newValue;
                }
        }
    };
    Object.defineProperty(Frame, "defaultAnimatedNavigation", {
        get: function () {
            return frame_common_1.FrameBase.defaultAnimatedNavigation;
        },
        set: function (value) {
            frame_common_1.FrameBase.defaultAnimatedNavigation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Frame, "defaultTransition", {
        get: function () {
            return frame_common_1.FrameBase.defaultTransition;
        },
        set: function (value) {
            frame_common_1.FrameBase.defaultTransition = value;
        },
        enumerable: true,
        configurable: true
    });
    Frame.prototype.onMeasure = function (widthMeasureSpec, heightMeasureSpec) {
        var width = frame_common_1.layout.getMeasureSpecSize(widthMeasureSpec);
        var widthMode = frame_common_1.layout.getMeasureSpecMode(widthMeasureSpec);
        var height = frame_common_1.layout.getMeasureSpecSize(heightMeasureSpec);
        var heightMode = frame_common_1.layout.getMeasureSpecMode(heightMeasureSpec);
        var widthAndState = frame_common_1.View.resolveSizeAndState(width, width, widthMode, 0);
        var heightAndState = frame_common_1.View.resolveSizeAndState(height, height, heightMode, 0);
        this.setMeasuredDimension(widthAndState, heightAndState);
    };
    Frame.prototype.layoutNativeView = function (left, top, right, bottom) {
    };
    Frame.prototype._setNativeViewFrame = function (nativeView, frame) {
    };
    Frame.prototype._onNavigatingTo = function (backstackEntry, isBack) {
    };
    __decorate([
        profiling_1.profile
    ], Frame.prototype, "_navigateCore", null);
    return Frame;
}(frame_common_1.FrameBase));
exports.Frame = Frame;
var transitionDelegates = new Array();
var TransitionDelegate = (function (_super) {
    __extends(TransitionDelegate, _super);
    function TransitionDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TransitionDelegate.initWithOwnerId = function (id) {
        var delegate = TransitionDelegate.new();
        delegate._id = id;
        transitionDelegates.push(delegate);
        return delegate;
    };
    TransitionDelegate.prototype.animationWillStart = function (animationID, context) {
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("START " + this._id, frame_common_1.traceCategories.Transition);
        }
    };
    TransitionDelegate.prototype.animationDidStop = function (animationID, finished, context) {
        if (finished) {
            if (frame_common_1.traceEnabled()) {
                frame_common_1.traceWrite("END " + this._id, frame_common_1.traceCategories.Transition);
            }
        }
        else {
            if (frame_common_1.traceEnabled()) {
                frame_common_1.traceWrite("CANCEL " + this._id, frame_common_1.traceCategories.Transition);
            }
        }
        var index = transitionDelegates.indexOf(this);
        if (index > -1) {
            transitionDelegates.splice(index, 1);
        }
    };
    TransitionDelegate.ObjCExposedMethods = {
        "animationWillStart": { returns: interop.types.void, params: [NSString, NSObject] },
        "animationDidStop": { returns: interop.types.void, params: [NSString, NSNumber, NSObject] }
    };
    return TransitionDelegate;
}(NSObject));
var _defaultTransitionDuration = 0.35;
var UINavigationControllerAnimatedDelegate = (function (_super) {
    __extends(UINavigationControllerAnimatedDelegate, _super);
    function UINavigationControllerAnimatedDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerAnimatedDelegate.prototype.navigationControllerAnimationControllerForOperationFromViewControllerToViewController = function (navigationController, operation, fromVC, toVC) {
        var viewController;
        switch (operation) {
            case 1:
                viewController = toVC;
                break;
            case 2:
                viewController = fromVC;
                break;
        }
        if (!viewController) {
            return null;
        }
        var navigationTransition = viewController[TRANSITION];
        if (!navigationTransition) {
            return null;
        }
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("UINavigationControllerImpl.navigationControllerAnimationControllerForOperationFromViewControllerToViewController(" + operation + ", " + fromVC + ", " + toVC + "), transition: " + JSON.stringify(navigationTransition), frame_common_1.traceCategories.NativeLifecycle);
        }
        var curve = _getNativeCurve(navigationTransition);
        var animationController = fragment_transitions_1._createIOSAnimatedTransitioning(navigationTransition, curve, operation, fromVC, toVC);
        return animationController;
    };
    UINavigationControllerAnimatedDelegate.ObjCProtocols = [UINavigationControllerDelegate];
    return UINavigationControllerAnimatedDelegate;
}(NSObject));
var UINavigationControllerImpl = (function (_super) {
    __extends(UINavigationControllerImpl, _super);
    function UINavigationControllerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UINavigationControllerImpl.initWithOwner = function (owner) {
        var controller = UINavigationControllerImpl.new();
        controller._owner = owner;
        return controller;
    };
    Object.defineProperty(UINavigationControllerImpl.prototype, "owner", {
        get: function () {
            return this._owner.get();
        },
        enumerable: true,
        configurable: true
    });
    UINavigationControllerImpl.prototype.viewWillAppear = function (animated) {
        _super.prototype.viewWillAppear.call(this, animated);
        var owner = this._owner.get();
        if (owner && !owner.isLoaded && !owner.parent) {
            owner.callLoaded();
        }
    };
    UINavigationControllerImpl.prototype.viewDidDisappear = function (animated) {
        _super.prototype.viewDidDisappear.call(this, animated);
        var owner = this._owner.get();
        if (owner && owner.isLoaded && !owner.parent && !this.presentedViewController) {
            owner.callUnloaded();
            owner._tearDownUI(true);
        }
    };
    UINavigationControllerImpl.prototype.animateWithDuration = function (navigationTransition, nativeTransition, transitionType, baseCallback) {
        var _this = this;
        var duration = navigationTransition.duration ? navigationTransition.duration / 1000 : _defaultTransitionDuration;
        var curve = _getNativeCurve(navigationTransition);
        var transitionTraced = frame_common_1.isCategorySet(frame_common_1.traceCategories.Transition);
        var transitionDelegate;
        if (transitionTraced) {
            var id = _getTransitionId(nativeTransition, transitionType);
            transitionDelegate = TransitionDelegate.initWithOwnerId(id);
        }
        UIView.animateWithDurationAnimations(duration, function () {
            if (transitionTraced) {
                UIView.setAnimationDelegate(transitionDelegate);
            }
            UIView.setAnimationWillStartSelector("animationWillStart");
            UIView.setAnimationDidStopSelector("animationDidStop");
            UIView.setAnimationCurve(curve);
            baseCallback();
            UIView.setAnimationTransitionForViewCache(nativeTransition, _this.view, true);
        });
    };
    UINavigationControllerImpl.prototype.pushViewControllerAnimated = function (viewController, animated) {
        var _this = this;
        var navigationTransition = viewController[TRANSITION];
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("UINavigationControllerImpl.pushViewControllerAnimated(" + viewController + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), frame_common_1.traceCategories.NativeLifecycle);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!animated || !navigationTransition || !nativeTransition) {
            _super.prototype.pushViewControllerAnimated.call(this, viewController, animated);
            return;
        }
        this.animateWithDuration(navigationTransition, nativeTransition, "push", function () {
            _super.prototype.pushViewControllerAnimated.call(_this, viewController, false);
        });
    };
    UINavigationControllerImpl.prototype.setViewControllersAnimated = function (viewControllers, animated) {
        var _this = this;
        var viewController = viewControllers.lastObject;
        var navigationTransition = viewController[TRANSITION];
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("UINavigationControllerImpl.setViewControllersAnimated(" + viewControllers + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), frame_common_1.traceCategories.NativeLifecycle);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, true);
        if (!animated || !navigationTransition || !nativeTransition) {
            _super.prototype.setViewControllersAnimated.call(this, viewControllers, animated);
            return;
        }
        this.animateWithDuration(navigationTransition, nativeTransition, "set", function () {
            _super.prototype.setViewControllersAnimated.call(_this, viewControllers, false);
        });
    };
    UINavigationControllerImpl.prototype.popViewControllerAnimated = function (animated) {
        var _this = this;
        var lastViewController = this.viewControllers.lastObject;
        var navigationTransition = lastViewController[TRANSITION];
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("UINavigationControllerImpl.popViewControllerAnimated(" + animated + "); transition: " + JSON.stringify(navigationTransition), frame_common_1.traceCategories.NativeLifecycle);
        }
        if (navigationTransition && navigationTransition.name === NON_ANIMATED_TRANSITION) {
            return _super.prototype.popViewControllerAnimated.call(this, false);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, false);
        if (!animated || !navigationTransition || !nativeTransition) {
            return _super.prototype.popViewControllerAnimated.call(this, animated);
        }
        this.animateWithDuration(navigationTransition, nativeTransition, "pop", function () {
            _super.prototype.popViewControllerAnimated.call(_this, false);
        });
        return null;
    };
    UINavigationControllerImpl.prototype.popToViewControllerAnimated = function (viewController, animated) {
        var _this = this;
        var lastViewController = this.viewControllers.lastObject;
        var navigationTransition = lastViewController[TRANSITION];
        if (frame_common_1.traceEnabled()) {
            frame_common_1.traceWrite("UINavigationControllerImpl.popToViewControllerAnimated(" + viewController + ", " + animated + "); transition: " + JSON.stringify(navigationTransition), frame_common_1.traceCategories.NativeLifecycle);
        }
        if (navigationTransition && navigationTransition.name === NON_ANIMATED_TRANSITION) {
            return _super.prototype.popToViewControllerAnimated.call(this, viewController, false);
        }
        var nativeTransition = _getNativeTransition(navigationTransition, false);
        if (!animated || !navigationTransition || !nativeTransition) {
            return _super.prototype.popToViewControllerAnimated.call(this, viewController, animated);
        }
        this.animateWithDuration(navigationTransition, nativeTransition, "popTo", function () {
            _super.prototype.popToViewControllerAnimated.call(_this, viewController, false);
        });
        return null;
    };
    __decorate([
        profiling_1.profile
    ], UINavigationControllerImpl.prototype, "viewWillAppear", null);
    __decorate([
        profiling_1.profile
    ], UINavigationControllerImpl.prototype, "viewDidDisappear", null);
    __decorate([
        profiling_1.profile
    ], UINavigationControllerImpl.prototype, "pushViewControllerAnimated", null);
    __decorate([
        profiling_1.profile
    ], UINavigationControllerImpl.prototype, "setViewControllersAnimated", null);
    return UINavigationControllerImpl;
}(UINavigationController));
function _getTransitionId(nativeTransition, transitionType) {
    var name;
    switch (nativeTransition) {
        case 4:
            name = "CurlDown";
            break;
        case 3:
            name = "CurlUp";
            break;
        case 1:
            name = "FlipFromLeft";
            break;
        case 2:
            name = "FlipFromRight";
            break;
        case 0:
            name = "None";
            break;
    }
    return name + " " + transitionType;
}
function _getNativeTransition(navigationTransition, push) {
    if (navigationTransition && navigationTransition.name) {
        switch (navigationTransition.name.toLowerCase()) {
            case "flip":
            case "flipright":
                return push ? 2 : 1;
            case "flipleft":
                return push ? 1 : 2;
            case "curl":
            case "curlup":
                return push ? 3 : 4;
            case "curldown":
                return push ? 4 : 3;
        }
    }
    return null;
}
function _getNativeCurve(transition) {
    if (transition.curve) {
        switch (transition.curve) {
            case "easeIn":
                if (frame_common_1.traceEnabled()) {
                    frame_common_1.traceWrite("Transition curve resolved to UIViewAnimationCurve.EaseIn.", frame_common_1.traceCategories.Transition);
                }
                return 1;
            case "easeOut":
                if (frame_common_1.traceEnabled()) {
                    frame_common_1.traceWrite("Transition curve resolved to UIViewAnimationCurve.EaseOut.", frame_common_1.traceCategories.Transition);
                }
                return 2;
            case "easeInOut":
                if (frame_common_1.traceEnabled()) {
                    frame_common_1.traceWrite("Transition curve resolved to UIViewAnimationCurve.EaseInOut.", frame_common_1.traceCategories.Transition);
                }
                return 0;
            case "linear":
                if (frame_common_1.traceEnabled()) {
                    frame_common_1.traceWrite("Transition curve resolved to UIViewAnimationCurve.Linear.", frame_common_1.traceCategories.Transition);
                }
                return 3;
            default:
                if (frame_common_1.traceEnabled()) {
                    frame_common_1.traceWrite("Transition curve resolved to original: " + transition.curve, frame_common_1.traceCategories.Transition);
                }
                return transition.curve;
        }
    }
    return 0;
}
exports._getNativeCurve = _getNativeCurve;
var iOSFrame = (function () {
    function iOSFrame(frame) {
        this._navBarVisibility = "auto";
        this._controller = UINavigationControllerImpl.initWithOwner(new WeakRef(frame));
    }
    Object.defineProperty(iOSFrame.prototype, "controller", {
        get: function () {
            return this._controller;
        },
        set: function (value) {
            this._controller = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(iOSFrame.prototype, "showNavigationBar", {
        get: function () {
            return this._showNavigationBar;
        },
        set: function (value) {
            this._showNavigationBar = value;
            this._controller.setNavigationBarHiddenAnimated(!value, !this._disableNavBarAnimation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(iOSFrame.prototype, "navBarVisibility", {
        get: function () {
            return this._navBarVisibility;
        },
        set: function (value) {
            this._navBarVisibility = value;
        },
        enumerable: true,
        configurable: true
    });
    return iOSFrame;
}());
//# sourceMappingURL=frame.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/gestures/gestures-common.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var GestureTypes;
(function (GestureTypes) {
    GestureTypes[GestureTypes["tap"] = 1] = "tap";
    GestureTypes[GestureTypes["doubleTap"] = 2] = "doubleTap";
    GestureTypes[GestureTypes["pinch"] = 4] = "pinch";
    GestureTypes[GestureTypes["pan"] = 8] = "pan";
    GestureTypes[GestureTypes["swipe"] = 16] = "swipe";
    GestureTypes[GestureTypes["rotation"] = 32] = "rotation";
    GestureTypes[GestureTypes["longPress"] = 64] = "longPress";
    GestureTypes[GestureTypes["touch"] = 128] = "touch";
})(GestureTypes = exports.GestureTypes || (exports.GestureTypes = {}));
var GestureStateTypes;
(function (GestureStateTypes) {
    GestureStateTypes[GestureStateTypes["cancelled"] = 0] = "cancelled";
    GestureStateTypes[GestureStateTypes["began"] = 1] = "began";
    GestureStateTypes[GestureStateTypes["changed"] = 2] = "changed";
    GestureStateTypes[GestureStateTypes["ended"] = 3] = "ended";
})(GestureStateTypes = exports.GestureStateTypes || (exports.GestureStateTypes = {}));
var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection[SwipeDirection["right"] = 1] = "right";
    SwipeDirection[SwipeDirection["left"] = 2] = "left";
    SwipeDirection[SwipeDirection["up"] = 4] = "up";
    SwipeDirection[SwipeDirection["down"] = 8] = "down";
})(SwipeDirection = exports.SwipeDirection || (exports.SwipeDirection = {}));
var TouchAction;
(function (TouchAction) {
    TouchAction.down = "down";
    TouchAction.up = "up";
    TouchAction.move = "move";
    TouchAction.cancel = "cancel";
})(TouchAction = exports.TouchAction || (exports.TouchAction = {}));
function toString(type, separator) {
    var types = new Array();
    if (type & GestureTypes.tap) {
        types.push("tap");
    }
    if (type & GestureTypes.doubleTap) {
        types.push("doubleTap");
    }
    if (type & GestureTypes.pinch) {
        types.push("pinch");
    }
    if (type & GestureTypes.pan) {
        types.push("pan");
    }
    if (type & GestureTypes.swipe) {
        types.push("swipe");
    }
    if (type & GestureTypes.rotation) {
        types.push("rotation");
    }
    if (type & GestureTypes.longPress) {
        types.push("longPress");
    }
    if (type & GestureTypes.touch) {
        types.push("touch");
    }
    return types.join(separator);
}
exports.toString = toString;
function fromString(type) {
    var t = type.trim().toLowerCase();
    if (t === "tap") {
        return GestureTypes.tap;
    }
    else if (t === "doubletap") {
        return GestureTypes.doubleTap;
    }
    else if (t === "pinch") {
        return GestureTypes.pinch;
    }
    else if (t === "pan") {
        return GestureTypes.pan;
    }
    else if (t === "swipe") {
        return GestureTypes.swipe;
    }
    else if (t === "rotation") {
        return GestureTypes.rotation;
    }
    else if (t === "longpress") {
        return GestureTypes.longPress;
    }
    else if (t === "touch") {
        return GestureTypes.touch;
    }
    return undefined;
}
exports.fromString = fromString;
var GesturesObserverBase = (function () {
    function GesturesObserverBase(target, callback, context) {
        this._target = target;
        this._callback = callback;
        this._context = context;
    }
    Object.defineProperty(GesturesObserverBase.prototype, "callback", {
        get: function () {
            return this._callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GesturesObserverBase.prototype, "target", {
        get: function () {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GesturesObserverBase.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    GesturesObserverBase.prototype.disconnect = function () {
        if (this.target) {
            var list = this.target.getGestureObservers(this.type);
            if (list && list.length > 0) {
                for (var i = 0; i < list.length; i++) {
                    if (list[i].callback === this.callback) {
                        break;
                    }
                }
                list.length = 0;
                this.target._gestureObservers[this.type] = undefined;
                delete this.target._gestureObservers[this.type];
            }
        }
        this._target = null;
        this._callback = null;
        this._context = null;
    };
    return GesturesObserverBase;
}());
exports.GesturesObserverBase = GesturesObserverBase;
//# sourceMappingURL=gestures-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/gestures/gestures.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var gestures_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/gestures/gestures-common.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/gestures/gestures-common.js"));
function observe(target, type, callback, context) {
    var observer = new GesturesObserver(target, callback, context);
    observer.observe(type);
    return observer;
}
exports.observe = observe;
var UIGestureRecognizerDelegateImpl = (function (_super) {
    __extends(UIGestureRecognizerDelegateImpl, _super);
    function UIGestureRecognizerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIGestureRecognizerDelegateImpl.prototype.gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer = function (gestureRecognizer, otherGestureRecognizer) {
        return true;
    };
    UIGestureRecognizerDelegateImpl.ObjCProtocols = [UIGestureRecognizerDelegate];
    return UIGestureRecognizerDelegateImpl;
}(NSObject));
var recognizerDelegateInstance = UIGestureRecognizerDelegateImpl.new();
var UIGestureRecognizerImpl = (function (_super) {
    __extends(UIGestureRecognizerImpl, _super);
    function UIGestureRecognizerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIGestureRecognizerImpl.initWithOwnerTypeCallback = function (owner, type, callback, thisArg) {
        var handler = UIGestureRecognizerImpl.new();
        handler._owner = owner;
        handler._type = type;
        if (callback) {
            handler._callback = callback;
        }
        if (thisArg) {
            handler._context = thisArg;
        }
        return handler;
    };
    UIGestureRecognizerImpl.prototype.recognize = function (recognizer) {
        var owner = this._owner.get();
        var callback = this._callback ? this._callback : (owner ? owner.callback : null);
        var typeParam = this._type;
        var target = owner ? owner.target : undefined;
        var args = {
            type: typeParam,
            view: target,
            ios: recognizer,
            android: undefined,
            object: target,
            eventName: gestures_common_1.toString(typeParam),
        };
        if (callback) {
            callback.call(this._context, args);
        }
    };
    UIGestureRecognizerImpl.ObjCExposedMethods = {
        "recognize": { returns: interop.types.void, params: [UIGestureRecognizer] }
    };
    return UIGestureRecognizerImpl;
}(NSObject));
var GesturesObserver = (function (_super) {
    __extends(GesturesObserver, _super);
    function GesturesObserver(target, callback, context) {
        var _this = _super.call(this, target, callback, context) || this;
        _this._recognizers = {};
        return _this;
    }
    GesturesObserver.prototype.androidOnTouchEvent = function (motionEvent) {
    };
    GesturesObserver.prototype.observe = function (type) {
        var _this = this;
        if (this.target) {
            this.type = type;
            this._onTargetLoaded = function (args) {
                _this._attach(_this.target, type);
            };
            this._onTargetUnloaded = function (args) {
                _this._detach();
            };
            this.target.on("loaded", this._onTargetLoaded);
            this.target.on("unloaded", this._onTargetUnloaded);
            if (this.target.isLoaded) {
                this._attach(this.target, type);
            }
        }
    };
    GesturesObserver.prototype._attach = function (target, type) {
        var _this = this;
        this._detach();
        if (target && target.nativeViewProtected && target.nativeViewProtected.addGestureRecognizer) {
            var nativeView = target.nativeViewProtected;
            if (type & gestures_common_1.GestureTypes.tap) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.tap));
            }
            if (type & gestures_common_1.GestureTypes.doubleTap) {
                var r = this._createRecognizer(gestures_common_1.GestureTypes.doubleTap);
                r.numberOfTapsRequired = 2;
                nativeView.addGestureRecognizer(r);
            }
            if (type & gestures_common_1.GestureTypes.pinch) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.pinch, function (args) {
                    _this._executeCallback(_getPinchData(args));
                }));
            }
            if (type & gestures_common_1.GestureTypes.pan) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.pan, function (args) {
                    _this._executeCallback(_getPanData(args, target.nativeViewProtected));
                }));
            }
            if (type & gestures_common_1.GestureTypes.swipe) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.swipe, function (args) {
                    _this._executeCallback(_getSwipeData(args));
                }, 8));
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.swipe, function (args) {
                    _this._executeCallback(_getSwipeData(args));
                }, 2));
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.swipe, function (args) {
                    _this._executeCallback(_getSwipeData(args));
                }, 1));
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.swipe, function (args) {
                    _this._executeCallback(_getSwipeData(args));
                }, 4));
            }
            if (type & gestures_common_1.GestureTypes.rotation) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.rotation, function (args) {
                    _this._executeCallback(_getRotationData(args));
                }));
            }
            if (type & gestures_common_1.GestureTypes.longPress) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.longPress));
            }
            if (type & gestures_common_1.GestureTypes.touch) {
                nativeView.addGestureRecognizer(this._createRecognizer(gestures_common_1.GestureTypes.touch));
            }
        }
    };
    GesturesObserver.prototype._detach = function () {
        if (this.target && this.target.nativeViewProtected) {
            for (var name_1 in this._recognizers) {
                if (this._recognizers.hasOwnProperty(name_1)) {
                    var item = this._recognizers[name_1];
                    this.target.nativeViewProtected.removeGestureRecognizer(item.recognizer);
                    item.recognizer = null;
                    item.target = null;
                }
            }
            this._recognizers = {};
        }
    };
    GesturesObserver.prototype.disconnect = function () {
        this._detach();
        if (this.target) {
            this.target.off("loaded", this._onTargetLoaded);
            this.target.off("unloaded", this._onTargetUnloaded);
            this._onTargetLoaded = null;
            this._onTargetUnloaded = null;
        }
        _super.prototype.disconnect.call(this);
    };
    GesturesObserver.prototype._executeCallback = function (args) {
        if (this.callback) {
            this.callback.call(this.context, args);
        }
    };
    GesturesObserver.prototype._createRecognizer = function (type, callback, swipeDirection) {
        var recognizer;
        var name = gestures_common_1.toString(type);
        var target = _createUIGestureRecognizerTarget(this, type, callback, this.context);
        var recognizerType = _getUIGestureRecognizerType(type);
        if (recognizerType) {
            recognizer = recognizerType.alloc().initWithTargetAction(target, "recognize");
            if (type === gestures_common_1.GestureTypes.swipe && swipeDirection) {
                name = name + swipeDirection.toString();
                recognizer.direction = swipeDirection;
            }
            else if (type === gestures_common_1.GestureTypes.touch) {
                recognizer.observer = this;
            }
            if (recognizer) {
                recognizer.delegate = recognizerDelegateInstance;
                this._recognizers[name] = { recognizer: recognizer, target: target };
            }
        }
        return recognizer;
    };
    return GesturesObserver;
}(gestures_common_1.GesturesObserverBase));
exports.GesturesObserver = GesturesObserver;
function _createUIGestureRecognizerTarget(owner, type, callback, context) {
    return UIGestureRecognizerImpl.initWithOwnerTypeCallback(new WeakRef(owner), type, callback, context);
}
function _getUIGestureRecognizerType(type) {
    var nativeType = null;
    if (type === gestures_common_1.GestureTypes.tap) {
        nativeType = UITapGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.doubleTap) {
        nativeType = UITapGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.pinch) {
        nativeType = UIPinchGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.pan) {
        nativeType = UIPanGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.swipe) {
        nativeType = UISwipeGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.rotation) {
        nativeType = UIRotationGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.longPress) {
        nativeType = UILongPressGestureRecognizer;
    }
    else if (type === gestures_common_1.GestureTypes.touch) {
        nativeType = TouchGestureRecognizer;
    }
    return nativeType;
}
function getState(recognizer) {
    if (recognizer.state === 1) {
        return gestures_common_1.GestureStateTypes.began;
    }
    else if (recognizer.state === 4) {
        return gestures_common_1.GestureStateTypes.cancelled;
    }
    else if (recognizer.state === 2) {
        return gestures_common_1.GestureStateTypes.changed;
    }
    else if (recognizer.state === 3) {
        return gestures_common_1.GestureStateTypes.ended;
    }
}
function _getSwipeDirection(direction) {
    if (direction === 8) {
        return gestures_common_1.SwipeDirection.down;
    }
    else if (direction === 2) {
        return gestures_common_1.SwipeDirection.left;
    }
    else if (direction === 1) {
        return gestures_common_1.SwipeDirection.right;
    }
    else if (direction === 4) {
        return gestures_common_1.SwipeDirection.up;
    }
}
function _getPinchData(args) {
    var recognizer = args.ios;
    var center = recognizer.locationInView(args.view.nativeViewProtected);
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        scale: recognizer.scale,
        getFocusX: function () { return center.x; },
        getFocusY: function () { return center.y; },
        object: args.view,
        eventName: gestures_common_1.toString(args.type),
        state: getState(recognizer)
    };
}
function _getSwipeData(args) {
    var recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        direction: _getSwipeDirection(recognizer.direction),
        object: args.view,
        eventName: gestures_common_1.toString(args.type),
    };
}
function _getPanData(args, view) {
    var recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        deltaX: recognizer.translationInView(view).x,
        deltaY: recognizer.translationInView(view).y,
        object: args.view,
        eventName: gestures_common_1.toString(args.type),
        state: getState(recognizer)
    };
}
function _getRotationData(args) {
    var recognizer = args.ios;
    return {
        type: args.type,
        view: args.view,
        ios: args.ios,
        android: undefined,
        rotation: recognizer.rotation * (180.0 / Math.PI),
        object: args.view,
        eventName: gestures_common_1.toString(args.type),
        state: getState(recognizer)
    };
}
var TouchGestureRecognizer = (function (_super) {
    __extends(TouchGestureRecognizer, _super);
    function TouchGestureRecognizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TouchGestureRecognizer.prototype.touchesBeganWithEvent = function (touches, event) {
        this.executeCallback(gestures_common_1.TouchAction.down, touches, event);
        if (this.view) {
            this.view.touchesBeganWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesMovedWithEvent = function (touches, event) {
        this.executeCallback(gestures_common_1.TouchAction.move, touches, event);
        if (this.view) {
            this.view.touchesMovedWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesEndedWithEvent = function (touches, event) {
        this.executeCallback(gestures_common_1.TouchAction.up, touches, event);
        if (this.view) {
            this.view.touchesEndedWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.touchesCancelledWithEvent = function (touches, event) {
        this.executeCallback(gestures_common_1.TouchAction.cancel, touches, event);
        if (this.view) {
            this.view.touchesCancelledWithEvent(touches, event);
        }
    };
    TouchGestureRecognizer.prototype.executeCallback = function (action, touches, event) {
        if (!this._eventData) {
            this._eventData = new TouchGestureEventData();
        }
        this._eventData.prepare(this.observer.target, action, touches, event);
        this.observer._executeCallback(this._eventData);
    };
    return TouchGestureRecognizer;
}(UIGestureRecognizer));
var Pointer = (function () {
    function Pointer(touch, targetView) {
        this.android = undefined;
        this.ios = undefined;
        this.ios = touch;
        this._view = targetView;
    }
    Object.defineProperty(Pointer.prototype, "location", {
        get: function () {
            if (!this._location) {
                this._location = this.ios.locationInView(this._view.nativeViewProtected);
            }
            return this._location;
        },
        enumerable: true,
        configurable: true
    });
    Pointer.prototype.getX = function () {
        return this.location.x;
    };
    Pointer.prototype.getY = function () {
        return this.location.y;
    };
    return Pointer;
}());
var TouchGestureEventData = (function () {
    function TouchGestureEventData() {
        this.eventName = gestures_common_1.toString(gestures_common_1.GestureTypes.touch);
        this.type = gestures_common_1.GestureTypes.touch;
        this.android = undefined;
    }
    TouchGestureEventData.prototype.prepare = function (view, action, touches, event) {
        this.action = action;
        this.view = view;
        this.object = view;
        this.ios = {
            touches: touches,
            event: event
        };
        this._mainPointer = undefined;
        this._activePointers = undefined;
        this._allPointers = undefined;
    };
    TouchGestureEventData.prototype.getPointerCount = function () {
        return this.ios.event.allTouches.count;
    };
    TouchGestureEventData.prototype.getMainPointer = function () {
        if (this._mainPointer === undefined) {
            this._mainPointer = this.ios.touches.anyObject();
        }
        return this._mainPointer;
    };
    TouchGestureEventData.prototype.getActivePointers = function () {
        if (!this._activePointers) {
            this._activePointers = [];
            for (var i = 0, nsArr = this.ios.touches.allObjects; i < nsArr.count; i++) {
                this._activePointers.push(new Pointer(nsArr.objectAtIndex(i), this.view));
            }
        }
        return this._activePointers;
    };
    TouchGestureEventData.prototype.getAllPointers = function () {
        if (!this._allPointers) {
            this._allPointers = [];
            var nsArr = this.ios.event.allTouches.allObjects;
            for (var i = 0; i < nsArr.count; i++) {
                this._allPointers.push(new Pointer(nsArr.objectAtIndex(i), this.view));
            }
        }
        return this._allPointers;
    };
    TouchGestureEventData.prototype.getX = function () {
        return this.getMainPointer().locationInView(this.view.nativeViewProtected).x;
    };
    TouchGestureEventData.prototype.getY = function () {
        return this.getMainPointer().locationInView(this.view.nativeViewProtected).y;
    };
    return TouchGestureEventData;
}());
//# sourceMappingURL=gestures.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/label/label.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var background_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/background.js");
var text_base_1 = __webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js");
var background_2 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/background.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base.js"));
var FixedSize;
(function (FixedSize) {
    FixedSize[FixedSize["NONE"] = 0] = "NONE";
    FixedSize[FixedSize["WIDTH"] = 1] = "WIDTH";
    FixedSize[FixedSize["HEIGHT"] = 2] = "HEIGHT";
    FixedSize[FixedSize["BOTH"] = 3] = "BOTH";
})(FixedSize || (FixedSize = {}));
var Label = (function (_super) {
    __extends(Label, _super);
    function Label() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Label.prototype.createNativeView = function () {
        var view = TNSLabel.new();
        view.userInteractionEnabled = true;
        return view;
    };
    Object.defineProperty(Label.prototype, "ios", {
        get: function () {
            return this.nativeTextViewProtected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textWrap", {
        get: function () {
            return this.style.whiteSpace === "normal";
        },
        set: function (value) {
            if (typeof value === "string") {
                value = text_base_1.booleanConverter(value);
            }
            this.style.whiteSpace = value ? "normal" : "nowrap";
        },
        enumerable: true,
        configurable: true
    });
    Label.prototype._requestLayoutOnTextChanged = function () {
        if (this._fixedSize === FixedSize.BOTH) {
            return;
        }
        if (this._fixedSize === FixedSize.WIDTH && !this.textWrap && this.getMeasuredHeight() > 0) {
            return;
        }
        _super.prototype._requestLayoutOnTextChanged.call(this);
    };
    Label.prototype.onMeasure = function (widthMeasureSpec, heightMeasureSpec) {
        var nativeView = this.nativeTextViewProtected;
        if (nativeView) {
            var width = text_base_1.layout.getMeasureSpecSize(widthMeasureSpec);
            var widthMode = text_base_1.layout.getMeasureSpecMode(widthMeasureSpec);
            var height = text_base_1.layout.getMeasureSpecSize(heightMeasureSpec);
            var heightMode = text_base_1.layout.getMeasureSpecMode(heightMeasureSpec);
            this._fixedSize = (widthMode === text_base_1.layout.EXACTLY ? FixedSize.WIDTH : FixedSize.NONE)
                | (heightMode === text_base_1.layout.EXACTLY ? FixedSize.HEIGHT : FixedSize.NONE);
            var nativeSize = void 0;
            if (this.textWrap) {
                nativeSize = this._measureNativeView(width, widthMode, height, heightMode);
            }
            else {
                nativeSize = text_base_1.layout.measureNativeView(nativeView, width, widthMode, height, heightMode);
            }
            var labelWidth = nativeSize.width;
            if (this.textWrap && widthMode === text_base_1.layout.AT_MOST) {
                labelWidth = Math.min(labelWidth, width);
            }
            var measureWidth = Math.max(labelWidth, this.effectiveMinWidth);
            var measureHeight = Math.max(nativeSize.height, this.effectiveMinHeight);
            var widthAndState = text_base_1.View.resolveSizeAndState(measureWidth, width, widthMode, 0);
            var heightAndState = text_base_1.View.resolveSizeAndState(measureHeight, height, heightMode, 0);
            this.setMeasuredDimension(widthAndState, heightAndState);
        }
    };
    Label.prototype._measureNativeView = function (width, widthMode, height, heightMode) {
        var view = this.nativeTextViewProtected;
        var nativeSize = view.textRectForBoundsLimitedToNumberOfLines(CGRectMake(0, 0, widthMode === 0 ? Number.POSITIVE_INFINITY : text_base_1.layout.toDeviceIndependentPixels(width), heightMode === 0 ? Number.POSITIVE_INFINITY : text_base_1.layout.toDeviceIndependentPixels(height)), 0).size;
        nativeSize.width = text_base_1.layout.round(text_base_1.layout.toDevicePixels(nativeSize.width));
        nativeSize.height = text_base_1.layout.round(text_base_1.layout.toDevicePixels(nativeSize.height));
        return nativeSize;
    };
    Label.prototype[text_base_1.whiteSpaceProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        switch (value) {
            case "normal":
                nativeView.lineBreakMode = 0;
                nativeView.numberOfLines = 0;
                break;
            case "nowrap":
            case "initial":
                nativeView.lineBreakMode = 4;
                nativeView.numberOfLines = 1;
                break;
        }
    };
    Label.prototype._redrawNativeBackground = function (value) {
        var _this = this;
        if (value instanceof background_1.Background) {
            background_2.ios.createBackgroundUIColor(this, function (color) {
                var cgColor = color ? color.CGColor : null;
                _this.nativeTextViewProtected.layer.backgroundColor = cgColor;
            }, true);
        }
        this._setNativeClipToBounds();
    };
    Label.prototype[text_base_1.borderTopWidthProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: text_base_1.layout.toDeviceIndependentPixels(this.effectiveBorderTopWidth),
            right: border.right,
            bottom: border.bottom,
            left: border.left
        };
    };
    Label.prototype[text_base_1.borderRightWidthProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: text_base_1.layout.toDeviceIndependentPixels(this.effectiveBorderRightWidth),
            bottom: border.bottom,
            left: border.left
        };
    };
    Label.prototype[text_base_1.borderBottomWidthProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: border.right,
            bottom: text_base_1.layout.toDeviceIndependentPixels(this.effectiveBorderBottomWidth),
            left: border.left
        };
    };
    Label.prototype[text_base_1.borderLeftWidthProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var border = nativeView.borderThickness;
        nativeView.borderThickness = {
            top: border.top,
            right: border.right,
            bottom: border.bottom,
            left: text_base_1.layout.toDeviceIndependentPixels(this.effectiveBorderLeftWidth)
        };
    };
    Label.prototype[text_base_1.paddingTopProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var padding = nativeView.padding;
        nativeView.padding = {
            top: text_base_1.layout.toDeviceIndependentPixels(this.effectivePaddingTop),
            right: padding.right,
            bottom: padding.bottom,
            left: padding.left
        };
    };
    Label.prototype[text_base_1.paddingRightProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: text_base_1.layout.toDeviceIndependentPixels(this.effectivePaddingRight),
            bottom: padding.bottom,
            left: padding.left
        };
    };
    Label.prototype[text_base_1.paddingBottomProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: padding.right,
            bottom: text_base_1.layout.toDeviceIndependentPixels(this.effectivePaddingBottom),
            left: padding.left
        };
    };
    Label.prototype[text_base_1.paddingLeftProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        var padding = nativeView.padding;
        nativeView.padding = {
            top: padding.top,
            right: padding.right,
            bottom: padding.bottom,
            left: text_base_1.layout.toDeviceIndependentPixels(this.effectivePaddingLeft)
        };
    };
    Label = __decorate([
        text_base_1.CSSType("Label")
    ], Label);
    return Label;
}(text_base_1.TextBase));
exports.Label = Label;
Label.prototype.recycleNativeView = "auto";
//# sourceMappingURL=label.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/background-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var linear_gradient_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/linear-gradient.js");
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
var Background = (function () {
    function Background() {
        this.borderTopWidth = 0;
        this.borderRightWidth = 0;
        this.borderBottomWidth = 0;
        this.borderLeftWidth = 0;
        this.borderTopLeftRadius = 0;
        this.borderTopRightRadius = 0;
        this.borderBottomLeftRadius = 0;
        this.borderBottomRightRadius = 0;
    }
    Background.prototype.clone = function () {
        var clone = new Background();
        clone.color = this.color;
        clone.image = this.image;
        clone.repeat = this.repeat;
        clone.position = this.position;
        clone.size = this.size;
        clone.borderTopColor = this.borderTopColor;
        clone.borderRightColor = this.borderRightColor;
        clone.borderBottomColor = this.borderBottomColor;
        clone.borderLeftColor = this.borderLeftColor;
        clone.borderTopWidth = this.borderTopWidth;
        clone.borderRightWidth = this.borderRightWidth;
        clone.borderBottomWidth = this.borderBottomWidth;
        clone.borderLeftWidth = this.borderLeftWidth;
        clone.borderTopLeftRadius = this.borderTopLeftRadius;
        clone.borderTopRightRadius = this.borderTopRightRadius;
        clone.borderBottomRightRadius = this.borderBottomRightRadius;
        clone.borderBottomLeftRadius = this.borderBottomLeftRadius;
        clone.clipPath = this.clipPath;
        return clone;
    };
    Background.prototype.withColor = function (value) {
        var clone = this.clone();
        clone.color = value;
        return clone;
    };
    Background.prototype.withImage = function (value) {
        var clone = this.clone();
        clone.image = value;
        return clone;
    };
    Background.prototype.withRepeat = function (value) {
        var clone = this.clone();
        clone.repeat = value;
        return clone;
    };
    Background.prototype.withPosition = function (value) {
        var clone = this.clone();
        clone.position = value;
        return clone;
    };
    Background.prototype.withSize = function (value) {
        var clone = this.clone();
        clone.size = value;
        return clone;
    };
    Background.prototype.withBorderTopColor = function (value) {
        var clone = this.clone();
        clone.borderTopColor = value;
        return clone;
    };
    Background.prototype.withBorderRightColor = function (value) {
        var clone = this.clone();
        clone.borderRightColor = value;
        return clone;
    };
    Background.prototype.withBorderBottomColor = function (value) {
        var clone = this.clone();
        clone.borderBottomColor = value;
        return clone;
    };
    Background.prototype.withBorderLeftColor = function (value) {
        var clone = this.clone();
        clone.borderLeftColor = value;
        return clone;
    };
    Background.prototype.withBorderTopWidth = function (value) {
        var clone = this.clone();
        clone.borderTopWidth = value;
        return clone;
    };
    Background.prototype.withBorderRightWidth = function (value) {
        var clone = this.clone();
        clone.borderRightWidth = value;
        return clone;
    };
    Background.prototype.withBorderBottomWidth = function (value) {
        var clone = this.clone();
        clone.borderBottomWidth = value;
        return clone;
    };
    Background.prototype.withBorderLeftWidth = function (value) {
        var clone = this.clone();
        clone.borderLeftWidth = value;
        return clone;
    };
    Background.prototype.withBorderTopLeftRadius = function (value) {
        var clone = this.clone();
        clone.borderTopLeftRadius = value;
        return clone;
    };
    Background.prototype.withBorderTopRightRadius = function (value) {
        var clone = this.clone();
        clone.borderTopRightRadius = value;
        return clone;
    };
    Background.prototype.withBorderBottomRightRadius = function (value) {
        var clone = this.clone();
        clone.borderBottomRightRadius = value;
        return clone;
    };
    Background.prototype.withBorderBottomLeftRadius = function (value) {
        var clone = this.clone();
        clone.borderBottomLeftRadius = value;
        return clone;
    };
    Background.prototype.withClipPath = function (value) {
        var clone = this.clone();
        clone.clipPath = value;
        return clone;
    };
    Background.prototype.isEmpty = function () {
        return !this.color
            && !this.image
            && !this.hasBorderWidth()
            && !this.hasBorderRadius()
            && !this.clipPath;
    };
    Background.equals = function (value1, value2) {
        if (!value1 && !value2) {
            return true;
        }
        if (!value1 || !value2) {
            return false;
        }
        var imagesEqual = false;
        if (value1 instanceof linear_gradient_1.LinearGradient && value2 instanceof linear_gradient_1.LinearGradient) {
            imagesEqual = linear_gradient_1.LinearGradient.equals(value1, value2);
        }
        else {
            imagesEqual = value1.image === value2.image;
        }
        return color_1.Color.equals(value1.color, value2.color)
            && imagesEqual
            && value1.position === value2.position
            && value1.repeat === value2.repeat
            && value1.size === value2.size
            && color_1.Color.equals(value1.borderTopColor, value2.borderTopColor)
            && color_1.Color.equals(value1.borderRightColor, value2.borderRightColor)
            && color_1.Color.equals(value1.borderBottomColor, value2.borderBottomColor)
            && color_1.Color.equals(value1.borderLeftColor, value2.borderLeftColor)
            && value1.borderTopWidth === value2.borderTopWidth
            && value1.borderRightWidth === value2.borderRightWidth
            && value1.borderBottomWidth === value2.borderBottomWidth
            && value1.borderLeftWidth === value2.borderLeftWidth
            && value1.borderTopLeftRadius === value2.borderTopLeftRadius
            && value1.borderTopRightRadius === value2.borderTopRightRadius
            && value1.borderBottomRightRadius === value2.borderBottomRightRadius
            && value1.borderBottomLeftRadius === value2.borderBottomLeftRadius
            && value1.clipPath === value2.clipPath;
    };
    Background.prototype.hasBorderColor = function () {
        return !!this.borderTopColor || !!this.borderRightColor || !!this.borderBottomColor || !!this.borderLeftColor;
    };
    Background.prototype.hasBorderWidth = function () {
        return this.borderTopWidth > 0
            || this.borderRightWidth > 0
            || this.borderBottomWidth > 0
            || this.borderLeftWidth > 0;
    };
    Background.prototype.hasBorderRadius = function () {
        return this.borderTopLeftRadius > 0
            || this.borderTopRightRadius > 0
            || this.borderBottomRightRadius > 0
            || this.borderBottomLeftRadius > 0;
    };
    Background.prototype.hasUniformBorderColor = function () {
        return color_1.Color.equals(this.borderTopColor, this.borderRightColor)
            && color_1.Color.equals(this.borderTopColor, this.borderBottomColor)
            && color_1.Color.equals(this.borderTopColor, this.borderLeftColor);
    };
    Background.prototype.hasUniformBorderWidth = function () {
        return this.borderTopWidth === this.borderRightWidth
            && this.borderTopWidth === this.borderBottomWidth
            && this.borderTopWidth === this.borderLeftWidth;
    };
    Background.prototype.hasUniformBorderRadius = function () {
        return this.borderTopLeftRadius === this.borderTopRightRadius
            && this.borderTopLeftRadius === this.borderBottomRightRadius
            && this.borderTopLeftRadius === this.borderBottomLeftRadius;
    };
    Background.prototype.hasUniformBorder = function () {
        return this.hasUniformBorderColor()
            && this.hasUniformBorderWidth()
            && this.hasUniformBorderRadius();
    };
    Background.prototype.getUniformBorderColor = function () {
        if (this.hasUniformBorderColor()) {
            return this.borderTopColor;
        }
        return undefined;
    };
    ;
    Background.prototype.getUniformBorderWidth = function () {
        if (this.hasUniformBorderWidth()) {
            return this.borderTopWidth;
        }
        return 0;
    };
    ;
    Background.prototype.getUniformBorderRadius = function () {
        if (this.hasUniformBorderRadius()) {
            return this.borderTopLeftRadius;
        }
        return 0;
    };
    ;
    Background.prototype.toString = function () {
        return "isEmpty: " + this.isEmpty() + "; color: " + this.color + "; image: " + this.image + "; repeat: " + this.repeat + "; position: " + this.position + "; size: " + this.size + "; borderTopColor: " + this.borderTopColor + "; borderRightColor: " + this.borderRightColor + "; borderBottomColor: " + this.borderBottomColor + "; borderLeftColor: " + this.borderLeftColor + "; borderTopWidth: " + this.borderTopWidth + "; borderRightWidth: " + this.borderRightWidth + "; borderBottomWidth: " + this.borderBottomWidth + "; borderLeftWidth: " + this.borderLeftWidth + "; borderTopLeftRadius: " + this.borderTopLeftRadius + "; borderTopRightRadius: " + this.borderTopRightRadius + "; borderBottomRightRadius: " + this.borderBottomRightRadius + "; borderBottomLeftRadius: " + this.borderBottomLeftRadius + "; clipPath: " + this.clipPath + ";";
    };
    Background.default = new Background();
    return Background;
}());
exports.Background = Background;
//# sourceMappingURL=background-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/background.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var linear_gradient_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/linear-gradient.js");
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var image_source_1 = __webpack_require__("../node_modules/tns-core-modules/image-source/image-source.js");
var css_value_1 = __webpack_require__("../node_modules/tns-core-modules/css-value/index.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/styling/background-common.js"));
var clearCGColor = UIColor.clearColor.CGColor;
var symbolUrl = Symbol("backgroundImageUrl");
var ios;
(function (ios) {
    function createBackgroundUIColor(view, callback, flip) {
        var background = view.style.backgroundInternal;
        var nativeView = view.nativeViewProtected;
        if (nativeView.hasNonUniformBorder) {
            unsubscribeFromScrollNotifications(view);
            clearNonUniformBorders(nativeView);
        }
        clearGradient(nativeView);
        if (background.image instanceof linear_gradient_1.LinearGradient) {
            drawGradient(nativeView, background.image);
        }
        var hasNonUniformBorderWidths = background.hasBorderWidth() && !background.hasUniformBorder();
        var hasNonUniformBorderRadiuses = background.hasBorderRadius() && !background.hasUniformBorderRadius();
        if (background.hasUniformBorderColor() && (hasNonUniformBorderWidths || hasNonUniformBorderRadiuses)) {
            drawUniformColorNonUniformBorders(nativeView, background);
            subscribeForScrollNotifications(view);
        }
        else if (background.hasUniformBorder()) {
            var layer = nativeView.layer;
            var borderColor = background.getUniformBorderColor();
            layer.borderColor = !borderColor ? undefined : borderColor.ios.CGColor;
            layer.borderWidth = utils_1.layout.toDeviceIndependentPixels(background.getUniformBorderWidth());
            var renderSize = view.getActualSize() || { width: 0, height: 0 };
            var cornerRadius = utils_1.layout.toDeviceIndependentPixels(background.getUniformBorderRadius());
            layer.cornerRadius = Math.min(Math.min(renderSize.width / 2, renderSize.height / 2), cornerRadius);
        }
        else {
            drawNoRadiusNonUniformBorders(nativeView, background);
            subscribeForScrollNotifications(view);
        }
        if (background.clipPath) {
            drawClipPath(nativeView, background);
        }
        if (!background.image || background.image instanceof linear_gradient_1.LinearGradient) {
            var uiColor = background.color ? background.color.ios : undefined;
            callback(uiColor);
        }
        else {
            setUIColorFromImage(view, nativeView, callback, flip);
        }
    }
    ios.createBackgroundUIColor = createBackgroundUIColor;
})(ios = exports.ios || (exports.ios = {}));
function onScroll(args) {
    var view = args.object;
    var nativeView = view.nativeViewProtected;
    if (nativeView instanceof UIScrollView) {
        adjustLayersForScrollView(nativeView);
    }
}
function adjustLayersForScrollView(nativeView) {
    var layer = nativeView.borderLayer;
    if (layer instanceof CALayer) {
        CATransaction.begin();
        CATransaction.setValueForKey(kCFBooleanTrue, kCATransactionDisableActions);
        var offset = nativeView.contentOffset;
        var transform = { a: 1, b: 0, c: 0, d: 1, tx: offset.x, ty: offset.y };
        layer.setAffineTransform(transform);
        if (nativeView.layer.mask) {
            nativeView.layer.mask.setAffineTransform(transform);
        }
        CATransaction.commit();
    }
}
function unsubscribeFromScrollNotifications(view) {
    if (view.nativeViewProtected instanceof UIScrollView) {
        view.off("scroll", onScroll);
    }
}
function subscribeForScrollNotifications(view) {
    if (view.nativeViewProtected instanceof UIScrollView) {
        view.on("scroll", onScroll);
        adjustLayersForScrollView(view.nativeViewProtected);
    }
}
function clearNonUniformBorders(nativeView) {
    if (nativeView.borderLayer) {
        nativeView.borderLayer.removeFromSuperlayer();
    }
    if (nativeView.hasBorderMask) {
        nativeView.layer.mask = nativeView.borderOriginalMask;
        nativeView.hasBorderMask = false;
        nativeView.borderOriginalMask = null;
    }
    if (nativeView.topBorderLayer) {
        nativeView.topBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.rightBorderLayer) {
        nativeView.rightBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.bottomBorderLayer) {
        nativeView.bottomBorderLayer.removeFromSuperlayer();
    }
    if (nativeView.leftBorderLayer) {
        nativeView.leftBorderLayer.removeFromSuperlayer();
    }
}
var pattern = /url\(('|")(.*?)\1\)/;
function setUIColorFromImage(view, nativeView, callback, flip) {
    var frame = nativeView.frame;
    var boundsWidth = view.scaleX ? frame.size.width / view.scaleX : frame.size.width;
    var boundsHeight = view.scaleY ? frame.size.height / view.scaleY : frame.size.height;
    if (!boundsWidth || !boundsHeight) {
        return undefined;
    }
    var style = view.style;
    var background = style.backgroundInternal;
    var imageUri = background.image;
    if (imageUri) {
        var match = imageUri.match(pattern);
        if (match && match[2]) {
            imageUri = match[2];
        }
    }
    var bitmap;
    if (utils_1.isDataURI(imageUri)) {
        var base64Data = imageUri.split(",")[1];
        if (base64Data !== undefined) {
            var imageSource = image_source_1.fromBase64(base64Data);
            bitmap = imageSource && imageSource.ios;
        }
    }
    else if (utils_1.isFileOrResourcePath(imageUri)) {
        var imageSource = image_source_1.fromFileOrResource(imageUri);
        bitmap = imageSource && imageSource.ios;
    }
    else if (imageUri.indexOf("http") !== -1) {
        style[symbolUrl] = imageUri;
        image_source_1.fromUrl(imageUri).then(function (r) {
            if (style && style[symbolUrl] === imageUri) {
                uiColorFromImage(r.ios, view, callback, flip);
            }
        });
    }
    uiColorFromImage(bitmap, view, callback, flip);
}
function parsePosition(pos) {
    var values = css_value_1.parse(pos);
    if (values.length === 2) {
        return { x: values[0], y: values[1] };
    }
    if (values.length === 1 && values[0].type === "ident") {
        var val = values[0].string.toLocaleLowerCase();
        var center = { type: "ident", string: "center" };
        if (val === "left" || val === "right") {
            return { x: values[0], y: center };
        }
        else if (val === "top" || val === "bottom") {
            return { x: center, y: values[0] };
        }
        else if (val === "center") {
            return { x: center, y: center };
        }
    }
    return null;
}
;
function getDrawParams(image, background, width, height) {
    if (!image) {
        return null;
    }
    var res = {
        repeatX: true,
        repeatY: true,
        posX: 0,
        posY: 0,
    };
    if (background.repeat) {
        switch (background.repeat.toLowerCase()) {
            case "no-repeat":
                res.repeatX = false;
                res.repeatY = false;
                break;
            case "repeat-x":
                res.repeatY = false;
                break;
            case "repeat-y":
                res.repeatX = false;
                break;
        }
    }
    var imageSize = image.size;
    var imageWidth = imageSize.width;
    var imageHeight = imageSize.height;
    var size = background.size;
    if (size) {
        var values = css_value_1.parse(size);
        if (values.length === 2) {
            var vx = values[0];
            var vy = values[1];
            if (vx.unit === "%" && vy.unit === "%") {
                imageWidth = width * vx.value / 100;
                imageHeight = height * vy.value / 100;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
            else if (vx.type === "number" && vy.type === "number" &&
                ((vx.unit === "px" && vy.unit === "px") || (vx.unit === "" && vy.unit === ""))) {
                imageWidth = vx.value;
                imageHeight = vy.value;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
        }
        else if (values.length === 1 && values[0].type === "ident") {
            var scale = 0;
            if (values[0].string === "cover") {
                scale = Math.max(width / imageWidth, height / imageHeight);
            }
            else if (values[0].string === "contain") {
                scale = Math.min(width / imageWidth, height / imageHeight);
            }
            if (scale > 0) {
                imageWidth *= scale;
                imageHeight *= scale;
                res.sizeX = imageWidth;
                res.sizeY = imageHeight;
            }
        }
    }
    var position = background.position;
    if (position) {
        var v = parsePosition(position);
        if (v) {
            var spaceX = width - imageWidth;
            var spaceY = height - imageHeight;
            if (v.x.unit === "%" && v.y.unit === "%") {
                res.posX = spaceX * v.x.value / 100;
                res.posY = spaceY * v.y.value / 100;
            }
            else if (v.x.type === "number" && v.y.type === "number" &&
                ((v.x.unit === "px" && v.y.unit === "px") || (v.x.unit === "" && v.y.unit === ""))) {
                res.posX = v.x.value;
                res.posY = v.y.value;
            }
            else if (v.x.type === "ident" && v.y.type === "ident") {
                if (v.x.string.toLowerCase() === "center") {
                    res.posX = spaceX / 2;
                }
                else if (v.x.string.toLowerCase() === "right") {
                    res.posX = spaceX;
                }
                if (v.y.string.toLowerCase() === "center") {
                    res.posY = spaceY / 2;
                }
                else if (v.y.string.toLowerCase() === "bottom") {
                    res.posY = spaceY;
                }
            }
        }
    }
    return res;
}
function uiColorFromImage(img, view, callback, flip) {
    var background = view.style.backgroundInternal;
    if (!img) {
        callback(background.color && background.color.ios);
        return;
    }
    var nativeView = view.nativeViewProtected;
    var frame = nativeView.frame;
    var boundsWidth = view.scaleX ? frame.size.width / view.scaleX : frame.size.width;
    var boundsHeight = view.scaleY ? frame.size.height / view.scaleY : frame.size.height;
    var params = getDrawParams(img, background, boundsWidth, boundsHeight);
    if (params.sizeX > 0 && params.sizeY > 0) {
        var resizeRect = CGRectMake(0, 0, params.sizeX, params.sizeY);
        UIGraphicsBeginImageContextWithOptions(resizeRect.size, false, 0.0);
        img.drawInRect(resizeRect);
        img = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
    }
    UIGraphicsBeginImageContextWithOptions(CGSizeFromString("{" + boundsWidth + "," + boundsHeight + "}"), false, 0.0);
    var context = UIGraphicsGetCurrentContext();
    if (background.color && background.color.ios) {
        CGContextSetFillColorWithColor(context, background.color.ios.CGColor);
        CGContextFillRect(context, CGRectMake(0, 0, boundsWidth, boundsHeight));
    }
    if (!params.repeatX && !params.repeatY) {
        img.drawAtPoint(CGPointMake(params.posX, params.posY));
    }
    else {
        var w = params.repeatX ? boundsWidth : img.size.width;
        var h = params.repeatY ? boundsHeight : img.size.height;
        CGContextSetPatternPhase(context, CGSizeMake(params.posX, params.posY));
        params.posX = params.repeatX ? 0 : params.posX;
        params.posY = params.repeatY ? 0 : params.posY;
        var patternRect = CGRectMake(params.posX, params.posY, w, h);
        img.drawAsPatternInRect(patternRect);
    }
    var bkgImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    if (flip) {
        var flippedImage = _flipImage(bkgImage);
        callback(UIColor.alloc().initWithPatternImage(flippedImage));
    }
    else {
        callback(UIColor.alloc().initWithPatternImage(bkgImage));
    }
}
function _flipImage(originalImage) {
    UIGraphicsBeginImageContextWithOptions(originalImage.size, false, 0.0);
    var context = UIGraphicsGetCurrentContext();
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 0.0, originalImage.size.height);
    CGContextScaleCTM(context, 1.0, -1.0);
    originalImage.drawInRect(CGRectMake(0, 0, originalImage.size.width, originalImage.size.height));
    CGContextRestoreGState(context);
    var flippedImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return flippedImage;
}
function cssValueToDeviceIndependentPixels(source, total) {
    source = source.trim();
    if (source.indexOf("px") !== -1) {
        return utils_1.layout.toDeviceIndependentPixels(parseFloat(source.replace("px", "")));
    }
    else if (source.indexOf("%") !== -1 && total > 0) {
        return (parseFloat(source.replace("%", "")) / 100) * total;
    }
    else {
        return parseFloat(source);
    }
}
function drawUniformColorNonUniformBorders(nativeView, background) {
    var layer = nativeView.layer;
    layer.backgroundColor = undefined;
    layer.borderColor = undefined;
    layer.borderWidth = 0;
    layer.cornerRadius = 0;
    var _a = layer.bounds.size, width = _a.width, height = _a.height;
    var _b = layer.bounds.origin, x = _b.x, y = _b.y;
    var left = x;
    var top = y;
    var right = x + width;
    var bottom = y + height;
    var min = Math.min, max = Math.max;
    var borderTopWidth = max(0, utils_1.layout.toDeviceIndependentPixels(background.borderTopWidth));
    var borderRightWidth = max(0, utils_1.layout.toDeviceIndependentPixels(background.borderRightWidth));
    var borderBottomWidth = max(0, utils_1.layout.toDeviceIndependentPixels(background.borderBottomWidth));
    var borderLeftWidth = max(0, utils_1.layout.toDeviceIndependentPixels(background.borderLeftWidth));
    var borderVWidth = borderTopWidth + borderBottomWidth;
    var borderHWidth = borderLeftWidth + borderRightWidth;
    var cappedBorderTopWidth = borderTopWidth && borderTopWidth * min(1, height / borderVWidth);
    var cappedBorderRightWidth = borderRightWidth && borderRightWidth * min(1, width / borderHWidth);
    var cappedBorderBottomWidth = borderBottomWidth && borderBottomWidth * min(1, height / borderVWidth);
    var cappedBorderLeftWidth = borderLeftWidth && borderLeftWidth * min(1, width / borderHWidth);
    var outerTopLeftRadius = utils_1.layout.toDeviceIndependentPixels(background.borderTopLeftRadius);
    var outerTopRightRadius = utils_1.layout.toDeviceIndependentPixels(background.borderTopRightRadius);
    var outerBottomRightRadius = utils_1.layout.toDeviceIndependentPixels(background.borderBottomRightRadius);
    var outerBottomLeftRadius = utils_1.layout.toDeviceIndependentPixels(background.borderBottomLeftRadius);
    var topRadii = outerTopLeftRadius + outerTopRightRadius;
    var rightRadii = outerTopRightRadius + outerBottomRightRadius;
    var bottomRadii = outerBottomRightRadius + outerBottomLeftRadius;
    var leftRadii = outerBottomLeftRadius + outerTopLeftRadius;
    function capRadius(a, b, c) {
        return a && Math.min(a, Math.min(b, c));
    }
    var cappedOuterTopLeftRadius = capRadius(outerTopLeftRadius, outerTopLeftRadius / topRadii * width, outerTopLeftRadius / leftRadii * height);
    var cappedOuterTopRightRadius = capRadius(outerTopRightRadius, outerTopRightRadius / topRadii * width, outerTopRightRadius / rightRadii * height);
    var cappedOuterBottomRightRadius = capRadius(outerBottomRightRadius, outerBottomRightRadius / bottomRadii * width, outerBottomRightRadius / rightRadii * height);
    var cappedOuterBottomLeftRadius = capRadius(outerBottomLeftRadius, outerBottomLeftRadius / bottomRadii * width, outerBottomLeftRadius / leftRadii * height);
    var clipPath = CGPathCreateMutable();
    CGPathMoveToPoint(clipPath, null, left + cappedOuterTopLeftRadius, top);
    CGPathAddArcToPoint(clipPath, null, right, top, right, top + cappedOuterTopRightRadius, cappedOuterTopRightRadius);
    CGPathAddArcToPoint(clipPath, null, right, bottom, right - cappedOuterBottomRightRadius, bottom, cappedOuterBottomRightRadius);
    CGPathAddArcToPoint(clipPath, null, left, bottom, left, bottom - cappedOuterBottomLeftRadius, cappedOuterBottomLeftRadius);
    CGPathAddArcToPoint(clipPath, null, left, top, left + cappedOuterTopLeftRadius, top, cappedOuterTopLeftRadius);
    CGPathCloseSubpath(clipPath);
    nativeView.borderOriginalMask = layer.mask;
    var clipShapeLayer = CAShapeLayer.layer();
    clipShapeLayer.path = clipPath;
    layer.mask = clipShapeLayer;
    nativeView.hasBorderMask = true;
    if (cappedBorderLeftWidth > 0 || cappedBorderTopWidth > 0 || cappedBorderRightWidth > 0 || cappedBorderBottomWidth > 0) {
        var borderPath = CGPathCreateMutable();
        CGPathAddRect(borderPath, null, CGRectMake(left, top, width, height));
        if (cappedBorderTopWidth > 0 || cappedBorderLeftWidth > 0) {
            CGPathMoveToPoint(borderPath, null, left + cappedOuterTopLeftRadius, top + cappedBorderTopWidth);
        }
        else {
            CGPathMoveToPoint(borderPath, null, left, top);
        }
        if (cappedBorderTopWidth > 0 || cappedBorderRightWidth > 0) {
            var innerTopRightWRadius = max(0, cappedOuterTopRightRadius - cappedBorderRightWidth);
            var innerTopRightHRadius = max(0, cappedOuterTopRightRadius - cappedBorderTopWidth);
            var innerTopRightMaxRadius = max(innerTopRightWRadius, innerTopRightHRadius);
            var innerTopRightTransform = CGAffineTransformMake(innerTopRightMaxRadius && innerTopRightWRadius / innerTopRightMaxRadius, 0, 0, innerTopRightMaxRadius && innerTopRightHRadius / innerTopRightMaxRadius, right - cappedBorderRightWidth - innerTopRightWRadius, top + cappedBorderTopWidth + innerTopRightHRadius);
            CGPathAddArc(borderPath, innerTopRightTransform, 0, 0, innerTopRightMaxRadius, Math.PI * 3 / 2, 0, false);
        }
        else {
            CGPathMoveToPoint(borderPath, null, right, top);
        }
        if (cappedBorderBottomWidth > 0 || cappedBorderRightWidth > 0) {
            var innerBottomRightWRadius = max(0, cappedOuterBottomRightRadius - cappedBorderRightWidth);
            var innerBottomRightHRadius = max(0, cappedOuterBottomRightRadius - cappedBorderBottomWidth);
            var innerBottomRightMaxRadius = max(innerBottomRightWRadius, innerBottomRightHRadius);
            var innerBottomRightTransform = CGAffineTransformMake(innerBottomRightMaxRadius && innerBottomRightWRadius / innerBottomRightMaxRadius, 0, 0, innerBottomRightMaxRadius && innerBottomRightHRadius / innerBottomRightMaxRadius, right - cappedBorderRightWidth - innerBottomRightWRadius, bottom - cappedBorderBottomWidth - innerBottomRightHRadius);
            CGPathAddArc(borderPath, innerBottomRightTransform, 0, 0, innerBottomRightMaxRadius, 0, Math.PI / 2, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, right, bottom);
        }
        if (cappedBorderBottomWidth > 0 || cappedBorderLeftWidth > 0) {
            var innerBottomLeftWRadius = max(0, cappedOuterBottomLeftRadius - cappedBorderLeftWidth);
            var innerBottomLeftHRadius = max(0, cappedOuterBottomLeftRadius - cappedBorderBottomWidth);
            var innerBottomLeftMaxRadius = max(innerBottomLeftWRadius, innerBottomLeftHRadius);
            var innerBottomLeftTransform = CGAffineTransformMake(innerBottomLeftMaxRadius && innerBottomLeftWRadius / innerBottomLeftMaxRadius, 0, 0, innerBottomLeftMaxRadius && innerBottomLeftHRadius / innerBottomLeftMaxRadius, left + cappedBorderLeftWidth + innerBottomLeftWRadius, bottom - cappedBorderBottomWidth - innerBottomLeftHRadius);
            CGPathAddArc(borderPath, innerBottomLeftTransform, 0, 0, innerBottomLeftMaxRadius, Math.PI / 2, Math.PI, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, left, bottom);
        }
        if (cappedBorderTopWidth > 0 || cappedBorderLeftWidth > 0) {
            var innerTopLeftWRadius = max(0, cappedOuterTopLeftRadius - cappedBorderLeftWidth);
            var innerTopLeftHRadius = max(0, cappedOuterTopLeftRadius - cappedBorderTopWidth);
            var innerTopLeftMaxRadius = max(innerTopLeftWRadius, innerTopLeftHRadius);
            var innerTopLeftTransform = CGAffineTransformMake(innerTopLeftMaxRadius && innerTopLeftWRadius / innerTopLeftMaxRadius, 0, 0, innerTopLeftMaxRadius && innerTopLeftHRadius / innerTopLeftMaxRadius, left + cappedBorderLeftWidth + innerTopLeftWRadius, top + cappedBorderTopWidth + innerTopLeftHRadius);
            CGPathAddArc(borderPath, innerTopLeftTransform, 0, 0, innerTopLeftMaxRadius, Math.PI, Math.PI * 3 / 2, false);
        }
        else {
            CGPathAddLineToPoint(borderPath, null, left, top);
        }
        CGPathCloseSubpath(borderPath);
        var borderLayer = CAShapeLayer.layer();
        borderLayer.fillColor = background.borderTopColor && background.borderTopColor.ios.CGColor || UIColor.blackColor.CGColor;
        borderLayer.fillRule = kCAFillRuleEvenOdd;
        borderLayer.path = borderPath;
        layer.addSublayer(borderLayer);
        nativeView.borderLayer = borderLayer;
    }
    nativeView.hasNonUniformBorder = true;
}
function drawNoRadiusNonUniformBorders(nativeView, background) {
    var borderLayer = CALayer.layer();
    nativeView.layer.addSublayer(borderLayer);
    nativeView.borderLayer = borderLayer;
    borderLayer.borderColor = undefined;
    borderLayer.borderWidth = 0;
    borderLayer.cornerRadius = 0;
    var layerBounds = nativeView.layer.bounds;
    var layerOrigin = layerBounds.origin;
    var layerSize = layerBounds.size;
    var nativeViewLayerBounds = {
        left: layerOrigin.x,
        top: layerOrigin.y,
        bottom: layerSize.height,
        right: layerSize.width
    };
    var top = utils_1.layout.toDeviceIndependentPixels(background.borderTopWidth);
    var right = utils_1.layout.toDeviceIndependentPixels(background.borderRightWidth);
    var bottom = utils_1.layout.toDeviceIndependentPixels(background.borderBottomWidth);
    var left = utils_1.layout.toDeviceIndependentPixels(background.borderLeftWidth);
    var lto = { x: nativeViewLayerBounds.left, y: nativeViewLayerBounds.top };
    var lti = { x: nativeViewLayerBounds.left + left, y: nativeViewLayerBounds.top + top };
    var rto = { x: nativeViewLayerBounds.right, y: nativeViewLayerBounds.top };
    var rti = { x: nativeViewLayerBounds.right - right, y: nativeViewLayerBounds.top + top };
    var rbo = { x: nativeViewLayerBounds.right, y: nativeViewLayerBounds.bottom };
    var rbi = { x: nativeViewLayerBounds.right - right, y: nativeViewLayerBounds.bottom - bottom };
    var lbo = { x: nativeViewLayerBounds.left, y: nativeViewLayerBounds.bottom };
    var lbi = { x: nativeViewLayerBounds.left + left, y: nativeViewLayerBounds.bottom - bottom };
    var hasNonUniformBorder;
    var borderTopColor = background.borderTopColor;
    if (top > 0 && borderTopColor && borderTopColor.ios) {
        var topBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(topBorderPath, null, lto.x, lto.y);
        CGPathAddLineToPoint(topBorderPath, null, rto.x, rto.y);
        CGPathAddLineToPoint(topBorderPath, null, rti.x, rti.y);
        CGPathAddLineToPoint(topBorderPath, null, lti.x, lti.y);
        CGPathAddLineToPoint(topBorderPath, null, lto.x, lto.y);
        var topBorderLayer = CAShapeLayer.layer();
        topBorderLayer.fillColor = background.borderTopColor.ios.CGColor;
        topBorderLayer.path = topBorderPath;
        borderLayer.addSublayer(topBorderLayer);
        nativeView.topBorderLayer = topBorderLayer;
        hasNonUniformBorder = true;
    }
    var borderRightColor = background.borderRightColor;
    if (right > 0 && borderRightColor && borderRightColor.ios) {
        var rightBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(rightBorderPath, null, rto.x, rto.y);
        CGPathAddLineToPoint(rightBorderPath, null, rbo.x, rbo.y);
        CGPathAddLineToPoint(rightBorderPath, null, rbi.x, rbi.y);
        CGPathAddLineToPoint(rightBorderPath, null, rti.x, rti.y);
        CGPathAddLineToPoint(rightBorderPath, null, rto.x, rto.y);
        var rightBorderLayer = CAShapeLayer.layer();
        rightBorderLayer.fillColor = background.borderRightColor.ios.CGColor;
        rightBorderLayer.path = rightBorderPath;
        borderLayer.addSublayer(rightBorderLayer);
        nativeView.rightBorderLayer = rightBorderLayer;
        hasNonUniformBorder = true;
    }
    var borderBottomColor = background.borderBottomColor;
    if (bottom > 0 && borderBottomColor && borderBottomColor.ios) {
        var bottomBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(bottomBorderPath, null, rbo.x, rbo.y);
        CGPathAddLineToPoint(bottomBorderPath, null, lbo.x, lbo.y);
        CGPathAddLineToPoint(bottomBorderPath, null, lbi.x, lbi.y);
        CGPathAddLineToPoint(bottomBorderPath, null, rbi.x, rbi.y);
        CGPathAddLineToPoint(bottomBorderPath, null, rbo.x, rbo.y);
        var bottomBorderLayer = CAShapeLayer.layer();
        bottomBorderLayer.fillColor = background.borderBottomColor.ios.CGColor;
        bottomBorderLayer.path = bottomBorderPath;
        borderLayer.addSublayer(bottomBorderLayer);
        nativeView.bottomBorderLayer = bottomBorderLayer;
        hasNonUniformBorder = true;
    }
    var borderLeftColor = background.borderLeftColor;
    if (left > 0 && borderLeftColor && borderLeftColor.ios) {
        var leftBorderPath = CGPathCreateMutable();
        CGPathMoveToPoint(leftBorderPath, null, lbo.x, lbo.y);
        CGPathAddLineToPoint(leftBorderPath, null, lto.x, lto.y);
        CGPathAddLineToPoint(leftBorderPath, null, lti.x, lti.y);
        CGPathAddLineToPoint(leftBorderPath, null, lbi.x, lbi.y);
        CGPathAddLineToPoint(leftBorderPath, null, lbo.x, lbo.y);
        var leftBorderLayer = CAShapeLayer.layer();
        leftBorderLayer.fillColor = background.borderLeftColor.ios.CGColor;
        leftBorderLayer.path = leftBorderPath;
        borderLayer.addSublayer(leftBorderLayer);
        nativeView.leftBorderLayer = leftBorderLayer;
        hasNonUniformBorder = true;
    }
    nativeView.hasNonUniformBorder = hasNonUniformBorder;
}
function drawGradient(nativeView, gradient) {
    var gradientLayer = CAGradientLayer.layer();
    gradientLayer.frame = nativeView.bounds;
    nativeView.gradientLayer = gradientLayer;
    var iosColors = NSMutableArray.alloc().initWithCapacity(gradient.colorStops.length);
    var iosStops = NSMutableArray.alloc().initWithCapacity(gradient.colorStops.length);
    var hasStops = false;
    gradient.colorStops.forEach(function (stop) {
        iosColors.addObject(stop.color.ios.CGColor);
        if (stop.offset) {
            iosStops.addObject(stop.offset.value);
            hasStops = true;
        }
    });
    gradientLayer.colors = iosColors;
    if (hasStops) {
        gradientLayer.locations = iosStops;
    }
    var alpha = gradient.angle / (Math.PI * 2);
    var startX = Math.pow(Math.sin(Math.PI * (alpha + 0.75)), 2);
    var startY = Math.pow(Math.sin(Math.PI * (alpha + 0.5)), 2);
    var endX = Math.pow(Math.sin(Math.PI * (alpha + 0.25)), 2);
    var endY = Math.pow(Math.sin(Math.PI * alpha), 2);
    gradientLayer.startPoint = { x: startX, y: startY };
    gradientLayer.endPoint = { x: endX, y: endY };
    nativeView.layer.insertSublayerAtIndex(gradientLayer, 0);
}
function clearGradient(nativeView) {
    if (nativeView.gradientLayer) {
        nativeView.gradientLayer.removeFromSuperlayer();
    }
}
function drawClipPath(nativeView, background) {
    var layer = nativeView.layer;
    var layerBounds = layer.bounds;
    var layerOrigin = layerBounds.origin;
    var layerSize = layerBounds.size;
    var bounds = {
        left: layerOrigin.x,
        top: layerOrigin.y,
        bottom: layerSize.height,
        right: layerSize.width
    };
    if (bounds.right === 0 || bounds.bottom === 0) {
        return;
    }
    var path;
    var clipPath = background.clipPath;
    var functionName = clipPath.substring(0, clipPath.indexOf("("));
    var value = clipPath.replace(functionName + "(", "").replace(")", "");
    switch (functionName) {
        case "rect":
            path = rectPath(value, bounds);
            break;
        case "inset":
            path = insetPath(value, bounds);
            break;
        case "circle":
            path = circlePath(value, bounds);
            break;
        case "ellipse":
            path = ellipsePath(value, bounds);
            break;
        case "polygon":
            path = polygonPath(value, bounds);
            break;
    }
    if (path) {
        var shape = CAShapeLayer.layer();
        shape.path = path;
        layer.mask = shape;
        nativeView.clipsToBounds = true;
        var borderWidth = background.getUniformBorderWidth();
        var borderColor = background.getUniformBorderColor();
        if (borderWidth > 0 && borderColor instanceof color_1.Color) {
            var borderLayer = CAShapeLayer.layer();
            borderLayer.path = path;
            borderLayer.lineWidth = borderWidth * 2;
            borderLayer.strokeColor = borderColor.ios.CGColor;
            borderLayer.fillColor = clearCGColor;
            borderLayer.frame = nativeView.bounds;
            layer.borderColor = undefined;
            layer.borderWidth = 0;
            layer.addSublayer(borderLayer);
        }
    }
}
function rectPath(value, bounds) {
    var arr = value.split(/[\s]+/);
    var top = cssValueToDeviceIndependentPixels(arr[0], bounds.top);
    var right = cssValueToDeviceIndependentPixels(arr[1], bounds.right);
    var bottom = cssValueToDeviceIndependentPixels(arr[2], bounds.bottom);
    var left = cssValueToDeviceIndependentPixels(arr[3], bounds.left);
    return UIBezierPath.bezierPathWithRect(CGRectMake(left, top, right - left, bottom - top)).CGPath;
}
function insetPath(value, bounds) {
    var arr = value.split(/[\s]+/);
    var topString;
    var rightString;
    var bottomString;
    var leftString;
    if (arr.length === 1) {
        topString = rightString = bottomString = leftString = arr[0];
    }
    else if (arr.length === 2) {
        topString = bottomString = arr[0];
        rightString = leftString = arr[1];
    }
    else if (arr.length === 3) {
        topString = arr[0];
        rightString = leftString = arr[1];
        bottomString = arr[2];
    }
    else if (arr.length === 4) {
        topString = arr[0];
        rightString = arr[1];
        bottomString = arr[2];
        leftString = arr[3];
    }
    var top = cssValueToDeviceIndependentPixels(topString, bounds.bottom);
    var right = cssValueToDeviceIndependentPixels("100%", bounds.right) - cssValueToDeviceIndependentPixels(rightString, bounds.right);
    var bottom = cssValueToDeviceIndependentPixels("100%", bounds.bottom) - cssValueToDeviceIndependentPixels(bottomString, bounds.bottom);
    var left = cssValueToDeviceIndependentPixels(leftString, bounds.right);
    return UIBezierPath.bezierPathWithRect(CGRectMake(left, top, right - left, bottom - top)).CGPath;
}
function circlePath(value, bounds) {
    var arr = value.split(/[\s]+/);
    var radius = cssValueToDeviceIndependentPixels(arr[0], (bounds.right > bounds.bottom ? bounds.bottom : bounds.right) / 2);
    var y = cssValueToDeviceIndependentPixels(arr[2], bounds.bottom);
    var x = cssValueToDeviceIndependentPixels(arr[3], bounds.right);
    return UIBezierPath.bezierPathWithArcCenterRadiusStartAngleEndAngleClockwise(CGPointMake(x, y), radius, 0, 360, true).CGPath;
}
function ellipsePath(value, bounds) {
    var arr = value.split(/[\s]+/);
    var rX = cssValueToDeviceIndependentPixels(arr[0], bounds.right);
    var rY = cssValueToDeviceIndependentPixels(arr[1], bounds.bottom);
    var cX = cssValueToDeviceIndependentPixels(arr[3], bounds.right);
    var cY = cssValueToDeviceIndependentPixels(arr[4], bounds.bottom);
    var left = cX - rX;
    var top = cY - rY;
    var width = rX * 2;
    var height = rY * 2;
    return UIBezierPath.bezierPathWithOvalInRect(CGRectMake(left, top, width, height)).CGPath;
}
function polygonPath(value, bounds) {
    var path = CGPathCreateMutable();
    var firstPoint;
    var arr = value.split(/[,]+/);
    for (var i = 0; i < arr.length; i++) {
        var xy = arr[i].trim().split(/[\s]+/);
        var point = {
            x: cssValueToDeviceIndependentPixels(xy[0], bounds.right),
            y: cssValueToDeviceIndependentPixels(xy[1], bounds.bottom)
        };
        if (!firstPoint) {
            firstPoint = point;
            CGPathMoveToPoint(path, null, point.x, point.y);
        }
        CGPathAddLineToPoint(path, null, point.x, point.y);
    }
    CGPathAddLineToPoint(path, null, firstPoint.x, firstPoint.y);
    return path;
}
//# sourceMappingURL=background.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/converters.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = __webpack_require__("../node_modules/tns-core-modules/ui/enums/enums.js");
var STYLE_CURVE_MAP = Object.freeze({
    "ease": enums_1.AnimationCurve.ease,
    "linear": enums_1.AnimationCurve.linear,
    "ease-in": enums_1.AnimationCurve.easeIn,
    "ease-out": enums_1.AnimationCurve.easeOut,
    "ease-in-out": enums_1.AnimationCurve.easeInOut,
    "spring": enums_1.AnimationCurve.spring,
});
function timeConverter(value) {
    var result = parseFloat(value);
    if (value.indexOf("ms") === -1) {
        result = result * 1000;
    }
    return Math.max(0.0, result);
}
exports.timeConverter = timeConverter;
function animationTimingFunctionConverter(value) {
    return value ?
        STYLE_CURVE_MAP[value] || parseCubicBezierCurve(value) :
        enums_1.AnimationCurve.ease;
}
exports.animationTimingFunctionConverter = animationTimingFunctionConverter;
function parseCubicBezierCurve(value) {
    var coordsString = /\((.*?)\)/.exec(value);
    var coords = coordsString && coordsString[1]
        .split(",")
        .map(stringToBezieCoords);
    if (value.startsWith("cubic-bezier") &&
        coordsString &&
        coords.length === 4) {
        var _a = coords.slice(), x1 = _a[0], x2 = _a[1], y1_1 = _a[2], y2 = _a[3];
        return enums_1.AnimationCurve.cubicBezier(x1, x2, y1_1, y2);
    }
    else {
        throw new Error("Invalid value for animation: " + value);
    }
}
function stringToBezieCoords(value) {
    var result = parseFloat(value);
    if (result < 0) {
        return 0;
    }
    else if (result > 1) {
        return 1;
    }
    return result;
}
//# sourceMappingURL=converters.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/css-animation-parser.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var keyframe_animation_1 = __webpack_require__("../node_modules/tns-core-modules/ui/animation/keyframe-animation.js");
var converters_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/converters.js");
var style_properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/style-properties.js");
var ANIMATION_PROPERTY_HANDLERS = Object.freeze({
    "animation-name": function (info, value) { return info.name = value; },
    "animation-duration": function (info, value) { return info.duration = converters_1.timeConverter(value); },
    "animation-delay": function (info, value) { return info.delay = converters_1.timeConverter(value); },
    "animation-timing-function": function (info, value) { return info.curve = converters_1.animationTimingFunctionConverter(value); },
    "animation-iteration-count": function (info, value) { return info.iterations = value === "infinite" ? Number.MAX_VALUE : parseFloat(value); },
    "animation-direction": function (info, value) { return info.isReverse = value === "reverse"; },
    "animation-fill-mode": function (info, value) { return info.isForwards = value === "forwards"; }
});
var CssAnimationParser = (function () {
    function CssAnimationParser() {
    }
    CssAnimationParser.keyframeAnimationsFromCSSDeclarations = function (declarations) {
        if (declarations === null || declarations === undefined) {
            return undefined;
        }
        var animations = new Array();
        var animationInfo = undefined;
        declarations.forEach(function (_a) {
            var property = _a.property, value = _a.value;
            if (property === "animation") {
                keyframeAnimationsFromCSSProperty(value, animations);
            }
            else {
                var propertyHandler = ANIMATION_PROPERTY_HANDLERS[property];
                if (propertyHandler) {
                    if (animationInfo === undefined) {
                        animationInfo = new keyframe_animation_1.KeyframeAnimationInfo();
                        animations.push(animationInfo);
                    }
                    propertyHandler(animationInfo, value);
                }
            }
        });
        return animations.length === 0 ? undefined : animations;
    };
    CssAnimationParser.keyframesArrayFromCSS = function (keyframes) {
        var parsedKeyframes = new Array();
        for (var _i = 0, keyframes_1 = keyframes; _i < keyframes_1.length; _i++) {
            var keyframe = keyframes_1[_i];
            var declarations = parseKeyframeDeclarations(keyframe.declarations);
            for (var _a = 0, _b = keyframe.values; _a < _b.length; _a++) {
                var time_1 = _b[_a];
                if (time_1 === "from") {
                    time_1 = 0;
                }
                else if (time_1 === "to") {
                    time_1 = 1;
                }
                else {
                    time_1 = parseFloat(time_1) / 100;
                    if (time_1 < 0) {
                        time_1 = 0;
                    }
                    if (time_1 > 100) {
                        time_1 = 100;
                    }
                }
                var current = parsedKeyframes[time_1];
                if (current === undefined) {
                    current = {};
                    current.duration = time_1;
                    parsedKeyframes[time_1] = current;
                }
                for (var _c = 0, _d = keyframe.declarations; _c < _d.length; _c++) {
                    var declaration = _d[_c];
                    if (declaration.property === "animation-timing-function") {
                        current.curve = converters_1.animationTimingFunctionConverter(declaration.value);
                    }
                }
                current.declarations = declarations;
            }
        }
        var array = new Array();
        for (var parsedKeyframe in parsedKeyframes) {
            array.push(parsedKeyframes[parsedKeyframe]);
        }
        array.sort(function (a, b) { return a.duration - b.duration; });
        return array;
    };
    return CssAnimationParser;
}());
exports.CssAnimationParser = CssAnimationParser;
function keyframeAnimationsFromCSSProperty(value, animations) {
    if (typeof value === "string") {
        var values = value.split(/[,]+/);
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var parsedValue = values_1[_i];
            var animationInfo = new keyframe_animation_1.KeyframeAnimationInfo();
            var arr = parsedValue.trim().split(/[ ]+/);
            if (arr.length > 0) {
                animationInfo.name = arr[0];
            }
            if (arr.length > 1) {
                animationInfo.duration = converters_1.timeConverter(arr[1]);
            }
            if (arr.length > 2) {
                animationInfo.curve = converters_1.animationTimingFunctionConverter(arr[2]);
            }
            if (arr.length > 3) {
                animationInfo.delay = converters_1.timeConverter(arr[3]);
            }
            if (arr.length > 4) {
                animationInfo.iterations = parseInt(arr[4]);
            }
            if (arr.length > 5) {
                animationInfo.isReverse = arr[4] === "reverse";
            }
            if (arr.length > 6) {
                animationInfo.isForwards = arr[5] === "forwards";
            }
            if (arr.length > 7) {
                throw new Error("Invalid value for animation: " + value);
            }
            animations.push(animationInfo);
        }
    }
}
function parseKeyframeDeclarations(unparsedKeyframeDeclarations) {
    var declarations = unparsedKeyframeDeclarations
        .reduce(function (declarations, _a) {
        var unparsedProperty = _a.property, unparsedValue = _a.value;
        var property = properties_1.CssAnimationProperty._getByCssName(unparsedProperty);
        if (typeof unparsedProperty === "string" && property && property._valueConverter) {
            declarations[property.name] = property._valueConverter(unparsedValue);
        }
        else if (typeof unparsedValue === "string" && unparsedProperty === "transform") {
            var transformations = style_properties_1.transformConverter(unparsedValue);
            Object.assign(declarations, transformations);
        }
        return declarations;
    }, {});
    return Object.keys(declarations).map(function (property) { return ({ property: property, value: declarations[property] }); });
}
exports.parseKeyframeDeclarations = parseKeyframeDeclarations;
//# sourceMappingURL=css-animation-parser.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/css-selector/css-selector.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var utils_common_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils-common.js");
var parser = __webpack_require__("../node_modules/tns-core-modules/css/parser.js");
var Match;
(function (Match) {
    Match.Dynamic = true;
    Match.Static = false;
})(Match || (Match = {}));
function getNodeDirectSibling(node) {
    if (!node.parent || !node.parent.getChildIndex || !node.parent.getChildAt) {
        return null;
    }
    var nodeIndex = node.parent.getChildIndex(node);
    if (nodeIndex === 0) {
        return null;
    }
    return node.parent.getChildAt(nodeIndex - 1);
}
function SelectorProperties(specificity, rarity, dynamic) {
    if (dynamic === void 0) { dynamic = false; }
    return function (cls) {
        cls.prototype.specificity = specificity;
        cls.prototype.rarity = rarity;
        cls.prototype.combinator = undefined;
        cls.prototype.dynamic = dynamic;
        return cls;
    };
}
var SelectorCore = (function () {
    function SelectorCore() {
    }
    SelectorCore.prototype.lookupSort = function (sorter, base) { sorter.sortAsUniversal(base || this); };
    SelectorCore = __decorate([
        SelectorProperties(0, 0, Match.Static)
    ], SelectorCore);
    return SelectorCore;
}());
exports.SelectorCore = SelectorCore;
var SimpleSelector = (function (_super) {
    __extends(SimpleSelector, _super);
    function SimpleSelector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleSelector.prototype.accumulateChanges = function (node, map) {
        if (!this.dynamic) {
            return this.match(node);
        }
        else if (this.mayMatch(node)) {
            this.trackChanges(node, map);
            return true;
        }
        return false;
    };
    SimpleSelector.prototype.mayMatch = function (node) { return this.match(node); };
    SimpleSelector.prototype.trackChanges = function (node, map) {
    };
    return SimpleSelector;
}(SelectorCore));
exports.SimpleSelector = SimpleSelector;
function wrap(text) {
    return text ? " " + text + " " : "";
}
var InvalidSelector = (function (_super) {
    __extends(InvalidSelector, _super);
    function InvalidSelector(e) {
        var _this = _super.call(this) || this;
        _this.e = e;
        return _this;
    }
    InvalidSelector.prototype.toString = function () { return "<error: " + this.e + ">"; };
    InvalidSelector.prototype.match = function (node) { return false; };
    InvalidSelector.prototype.lookupSort = function (sorter, base) {
    };
    InvalidSelector = __decorate([
        SelectorProperties(0, 4, Match.Static)
    ], InvalidSelector);
    return InvalidSelector;
}(SimpleSelector));
exports.InvalidSelector = InvalidSelector;
var UniversalSelector = (function (_super) {
    __extends(UniversalSelector, _super);
    function UniversalSelector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UniversalSelector.prototype.toString = function () { return "*" + wrap(this.combinator); };
    UniversalSelector.prototype.match = function (node) { return true; };
    UniversalSelector = __decorate([
        SelectorProperties(0, 0, Match.Static)
    ], UniversalSelector);
    return UniversalSelector;
}(SimpleSelector));
exports.UniversalSelector = UniversalSelector;
var IdSelector = (function (_super) {
    __extends(IdSelector, _super);
    function IdSelector(id) {
        var _this = _super.call(this) || this;
        _this.id = id;
        return _this;
    }
    IdSelector.prototype.toString = function () { return "#" + this.id + wrap(this.combinator); };
    IdSelector.prototype.match = function (node) { return node.id === this.id; };
    IdSelector.prototype.lookupSort = function (sorter, base) { sorter.sortById(this.id, base || this); };
    IdSelector = __decorate([
        SelectorProperties(65536, 3, Match.Static)
    ], IdSelector);
    return IdSelector;
}(SimpleSelector));
exports.IdSelector = IdSelector;
var TypeSelector = (function (_super) {
    __extends(TypeSelector, _super);
    function TypeSelector(cssType) {
        var _this = _super.call(this) || this;
        _this.cssType = cssType;
        return _this;
    }
    TypeSelector.prototype.toString = function () { return "" + this.cssType + wrap(this.combinator); };
    TypeSelector.prototype.match = function (node) { return node.cssType === this.cssType; };
    TypeSelector.prototype.lookupSort = function (sorter, base) { sorter.sortByType(this.cssType, base || this); };
    TypeSelector = __decorate([
        SelectorProperties(1, 1, Match.Static)
    ], TypeSelector);
    return TypeSelector;
}(SimpleSelector));
exports.TypeSelector = TypeSelector;
var ClassSelector = (function (_super) {
    __extends(ClassSelector, _super);
    function ClassSelector(cssClass) {
        var _this = _super.call(this) || this;
        _this.cssClass = cssClass;
        return _this;
    }
    ClassSelector.prototype.toString = function () { return "." + this.cssClass + wrap(this.combinator); };
    ClassSelector.prototype.match = function (node) { return node.cssClasses && node.cssClasses.has(this.cssClass); };
    ClassSelector.prototype.lookupSort = function (sorter, base) { sorter.sortByClass(this.cssClass, base || this); };
    ClassSelector = __decorate([
        SelectorProperties(256, 2, Match.Static)
    ], ClassSelector);
    return ClassSelector;
}(SimpleSelector));
exports.ClassSelector = ClassSelector;
var AttributeSelector = (function (_super) {
    __extends(AttributeSelector, _super);
    function AttributeSelector(attribute, test, value) {
        var _this = _super.call(this) || this;
        _this.attribute = attribute;
        _this.test = test;
        _this.value = value;
        if (!test) {
            _this.match = function (node) { return !types_1.isNullOrUndefined(node[attribute]); };
            return _this;
        }
        if (!value) {
            _this.match = function (node) { return false; };
        }
        var escapedValue = utils_common_1.escapeRegexSymbols(value);
        var regexp = null;
        switch (test) {
            case "^=":
                regexp = new RegExp("^" + escapedValue);
                break;
            case "$=":
                regexp = new RegExp(escapedValue + "$");
                break;
            case "*=":
                regexp = new RegExp(escapedValue);
                break;
            case "=":
                regexp = new RegExp("^" + escapedValue + "$");
                break;
            case "~=":
                if (/\s/.test(value)) {
                    _this.match = function (node) { return false; };
                    return _this;
                }
                regexp = new RegExp("(^|\\s)" + escapedValue + "(\\s|$)");
                break;
            case "|=":
                regexp = new RegExp("^" + escapedValue + "(-|$)");
                break;
        }
        if (regexp) {
            _this.match = function (node) { return regexp.test(node[attribute] + ""); };
            return _this;
        }
        else {
            _this.match = function (node) { return false; };
            return _this;
        }
    }
    AttributeSelector.prototype.toString = function () { return "[" + this.attribute + wrap(this.test) + ((this.test && this.value) || "") + "]" + wrap(this.combinator); };
    AttributeSelector.prototype.match = function (node) { return false; };
    AttributeSelector.prototype.mayMatch = function (node) { return true; };
    AttributeSelector.prototype.trackChanges = function (node, map) { map.addAttribute(node, this.attribute); };
    AttributeSelector = __decorate([
        SelectorProperties(256, 0, Match.Dynamic)
    ], AttributeSelector);
    return AttributeSelector;
}(SimpleSelector));
exports.AttributeSelector = AttributeSelector;
var PseudoClassSelector = (function (_super) {
    __extends(PseudoClassSelector, _super);
    function PseudoClassSelector(cssPseudoClass) {
        var _this = _super.call(this) || this;
        _this.cssPseudoClass = cssPseudoClass;
        return _this;
    }
    PseudoClassSelector.prototype.toString = function () { return ":" + this.cssPseudoClass + wrap(this.combinator); };
    PseudoClassSelector.prototype.match = function (node) { return node.cssPseudoClasses && node.cssPseudoClasses.has(this.cssPseudoClass); };
    PseudoClassSelector.prototype.mayMatch = function (node) { return true; };
    PseudoClassSelector.prototype.trackChanges = function (node, map) { map.addPseudoClass(node, this.cssPseudoClass); };
    PseudoClassSelector = __decorate([
        SelectorProperties(256, 0, Match.Dynamic)
    ], PseudoClassSelector);
    return PseudoClassSelector;
}(SimpleSelector));
exports.PseudoClassSelector = PseudoClassSelector;
var SimpleSelectorSequence = (function (_super) {
    __extends(SimpleSelectorSequence, _super);
    function SimpleSelectorSequence(selectors) {
        var _this = _super.call(this) || this;
        _this.selectors = selectors;
        _this.specificity = selectors.reduce(function (sum, sel) { return sel.specificity + sum; }, 0);
        _this.head = _this.selectors.reduce(function (prev, curr) { return !prev || (curr.rarity > prev.rarity) ? curr : prev; }, null);
        _this.dynamic = selectors.some(function (sel) { return sel.dynamic; });
        return _this;
    }
    SimpleSelectorSequence.prototype.toString = function () { return "" + this.selectors.join("") + wrap(this.combinator); };
    SimpleSelectorSequence.prototype.match = function (node) { return this.selectors.every(function (sel) { return sel.match(node); }); };
    SimpleSelectorSequence.prototype.mayMatch = function (node) {
        return this.selectors.every(function (sel) { return sel.mayMatch(node); });
    };
    SimpleSelectorSequence.prototype.trackChanges = function (node, map) {
        this.selectors.forEach(function (sel) { return sel.trackChanges(node, map); });
    };
    SimpleSelectorSequence.prototype.lookupSort = function (sorter, base) {
        this.head.lookupSort(sorter, base || this);
    };
    return SimpleSelectorSequence;
}(SimpleSelector));
exports.SimpleSelectorSequence = SimpleSelectorSequence;
var Selector = (function (_super) {
    __extends(Selector, _super);
    function Selector(selectors) {
        var _this = _super.call(this) || this;
        _this.selectors = selectors;
        var supportedCombinator = [undefined, " ", ">", "+"];
        var siblingGroup;
        var lastGroup;
        var groups = [];
        selectors.reverse().forEach(function (sel) {
            if (supportedCombinator.indexOf(sel.combinator) === -1) {
                throw new Error("Unsupported combinator \"" + sel.combinator + "\".");
            }
            if (sel.combinator === undefined || sel.combinator === " ") {
                groups.push(lastGroup = [siblingGroup = []]);
            }
            if (sel.combinator === ">") {
                lastGroup.push(siblingGroup = []);
            }
            siblingGroup.push(sel);
        });
        _this.groups = groups.map(function (g) {
            return new Selector.ChildGroup(g.map(function (sg) {
                return new Selector.SiblingGroup(sg);
            }));
        });
        _this.last = selectors[0];
        _this.specificity = selectors.reduce(function (sum, sel) { return sel.specificity + sum; }, 0);
        _this.dynamic = selectors.some(function (sel) { return sel.dynamic; });
        return _this;
    }
    Selector.prototype.toString = function () { return this.selectors.join(""); };
    Selector.prototype.match = function (node) {
        return this.groups.every(function (group, i) {
            if (i === 0) {
                node = group.match(node);
                return !!node;
            }
            else {
                var ancestor = node;
                while (ancestor = ancestor.parent) {
                    if (node = group.match(ancestor)) {
                        return true;
                    }
                }
                return false;
            }
        });
    };
    Selector.prototype.lookupSort = function (sorter, base) {
        this.last.lookupSort(sorter, this);
    };
    Selector.prototype.accumulateChanges = function (node, map) {
        if (!this.dynamic) {
            return this.match(node);
        }
        var bounds = [];
        var mayMatch = this.groups.every(function (group, i) {
            if (i === 0) {
                var nextNode = group.mayMatch(node);
                bounds.push({ left: node, right: node });
                node = nextNode;
                return !!node;
            }
            else {
                var ancestor = node;
                while (ancestor = ancestor.parent) {
                    var nextNode = group.mayMatch(ancestor);
                    if (nextNode) {
                        bounds.push({ left: ancestor, right: null });
                        node = nextNode;
                        return true;
                    }
                }
                return false;
            }
        });
        if (!mayMatch) {
            return false;
        }
        if (!map) {
            return mayMatch;
        }
        for (var i = 0; i < this.groups.length; i++) {
            var group_1 = this.groups[i];
            if (!group_1.dynamic) {
                continue;
            }
            var bound = bounds[i];
            var node_1 = bound.left;
            do {
                if (group_1.mayMatch(node_1)) {
                    group_1.trackChanges(node_1, map);
                }
            } while ((node_1 !== bound.right) && (node_1 = node_1.parent));
        }
        return mayMatch;
    };
    return Selector;
}(SelectorCore));
exports.Selector = Selector;
(function (Selector) {
    var ChildGroup = (function () {
        function ChildGroup(selectors) {
            this.selectors = selectors;
            this.dynamic = selectors.some(function (sel) { return sel.dynamic; });
        }
        ChildGroup.prototype.match = function (node) {
            return this.selectors.every(function (sel, i) { return (i === 0 ? node : node = node.parent) && !!sel.match(node); }) ? node : null;
        };
        ChildGroup.prototype.mayMatch = function (node) {
            return this.selectors.every(function (sel, i) { return (i === 0 ? node : node = node.parent) && !!sel.mayMatch(node); }) ? node : null;
        };
        ChildGroup.prototype.trackChanges = function (node, map) {
            this.selectors.forEach(function (sel, i) { return (i === 0 ? node : node = node.parent) && sel.trackChanges(node, map); });
        };
        return ChildGroup;
    }());
    Selector.ChildGroup = ChildGroup;
    var SiblingGroup = (function () {
        function SiblingGroup(selectors) {
            this.selectors = selectors;
            this.dynamic = selectors.some(function (sel) { return sel.dynamic; });
        }
        SiblingGroup.prototype.match = function (node) {
            return this.selectors.every(function (sel, i) { return (i === 0 ? node : node = getNodeDirectSibling(node)) && sel.match(node); }) ? node : null;
        };
        SiblingGroup.prototype.mayMatch = function (node) {
            return this.selectors.every(function (sel, i) { return (i === 0 ? node : node = getNodeDirectSibling(node)) && sel.mayMatch(node); }) ? node : null;
        };
        SiblingGroup.prototype.trackChanges = function (node, map) {
            this.selectors.forEach(function (sel, i) { return (i === 0 ? node : node = getNodeDirectSibling(node)) && sel.trackChanges(node, map); });
        };
        return SiblingGroup;
    }());
    Selector.SiblingGroup = SiblingGroup;
})(Selector = exports.Selector || (exports.Selector = {}));
exports.Selector = Selector;
var RuleSet = (function () {
    function RuleSet(selectors, declarations) {
        var _this = this;
        this.selectors = selectors;
        this.declarations = declarations;
        this.selectors.forEach(function (sel) { return sel.ruleset = _this; });
    }
    RuleSet.prototype.toString = function () { return this.selectors.join(", ") + " {" + this.declarations.map(function (d, i) { return "" + (i === 0 ? " " : "") + d.property + ": " + d.value; }).join("; ") + " }"; };
    RuleSet.prototype.lookupSort = function (sorter) { this.selectors.forEach(function (sel) { return sel.lookupSort(sorter); }); };
    return RuleSet;
}());
exports.RuleSet = RuleSet;
function fromAstNodes(astRules) {
    return astRules.filter(isRule).map(function (rule) {
        var declarations = rule.declarations.filter(isDeclaration).map(createDeclaration);
        var selectors = rule.selectors.map(createSelector);
        var ruleset = new RuleSet(selectors, declarations);
        return ruleset;
    });
}
exports.fromAstNodes = fromAstNodes;
function createDeclaration(decl) {
    return { property: decl.property.toLowerCase(), value: decl.value };
}
function createSimpleSelectorFromAst(ast) {
    switch (ast.type) {
        case "*": return new UniversalSelector();
        case "#": return new IdSelector(ast.identifier);
        case "": return new TypeSelector(ast.identifier.replace(/-/, "").toLowerCase());
        case ".": return new ClassSelector(ast.identifier);
        case ":": return new PseudoClassSelector(ast.identifier);
        case "[]": return ast.test ? new AttributeSelector(ast.property, ast.test, ast.value) : new AttributeSelector(ast.property);
    }
}
function createSimpleSelectorSequenceFromAst(ast) {
    if (ast.length === 0) {
        return new InvalidSelector(new Error("Empty simple selector sequence."));
    }
    else if (ast.length === 1) {
        return createSimpleSelectorFromAst(ast[0]);
    }
    else {
        return new SimpleSelectorSequence(ast.map(createSimpleSelectorFromAst));
    }
}
function createSelectorFromAst(ast) {
    if (ast.length === 0) {
        return new InvalidSelector(new Error("Empty selector."));
    }
    else if (ast.length === 1) {
        return createSimpleSelectorSequenceFromAst(ast[0][0]);
    }
    else {
        var simpleSelectorSequences = [];
        var simpleSelectorSequence = void 0;
        var combinator = void 0;
        for (var i = 0; i < ast.length; i++) {
            simpleSelectorSequence = createSimpleSelectorSequenceFromAst(ast[i][0]);
            combinator = ast[i][1];
            if (combinator) {
                simpleSelectorSequence.combinator = combinator;
            }
            simpleSelectorSequences.push(simpleSelectorSequence);
        }
        return new Selector(simpleSelectorSequences);
    }
}
function createSelector(sel) {
    try {
        var parsedSelector = parser.parseSelector(sel);
        if (!parsedSelector) {
            return new InvalidSelector(new Error("Empty selector"));
        }
        return createSelectorFromAst(parsedSelector.value);
    }
    catch (e) {
        return new InvalidSelector(e);
    }
}
exports.createSelector = createSelector;
function isRule(node) {
    return node.type === "rule";
}
function isDeclaration(node) {
    return node.type === "declaration";
}
var SelectorsMap = (function () {
    function SelectorsMap(rulesets) {
        var _this = this;
        this.id = {};
        this.class = {};
        this.type = {};
        this.universal = [];
        this.position = 0;
        rulesets.forEach(function (rule) { return rule.lookupSort(_this); });
    }
    SelectorsMap.prototype.query = function (node) {
        var _this = this;
        var selectorClasses = [
            this.universal,
            this.id[node.id],
            this.type[node.cssType]
        ];
        if (node.cssClasses) {
            node.cssClasses.forEach(function (c) { return selectorClasses.push(_this.class[c]); });
        }
        var selectors = selectorClasses
            .filter(function (arr) { return !!arr; })
            .reduce(function (cur, next) { return cur.concat(next); }, []);
        var selectorsMatch = new SelectorsMatch();
        selectorsMatch.selectors = selectors
            .filter(function (sel) { return sel.sel.accumulateChanges(node, selectorsMatch); })
            .sort(function (a, b) { return a.sel.specificity - b.sel.specificity || a.pos - b.pos; })
            .map(function (docSel) { return docSel.sel; });
        return selectorsMatch;
    };
    SelectorsMap.prototype.sortById = function (id, sel) { this.addToMap(this.id, id, sel); };
    SelectorsMap.prototype.sortByClass = function (cssClass, sel) {
        this.addToMap(this.class, cssClass, sel);
    };
    SelectorsMap.prototype.sortByType = function (cssType, sel) {
        this.addToMap(this.type, cssType, sel);
    };
    SelectorsMap.prototype.sortAsUniversal = function (sel) { this.universal.push(this.makeDocSelector(sel)); };
    SelectorsMap.prototype.addToMap = function (map, head, sel) {
        this.position++;
        var list = map[head];
        if (list) {
            list.push(this.makeDocSelector(sel));
        }
        else {
            map[head] = [this.makeDocSelector(sel)];
        }
    };
    SelectorsMap.prototype.makeDocSelector = function (sel) {
        return { sel: sel, pos: this.position++ };
    };
    return SelectorsMap;
}());
exports.SelectorsMap = SelectorsMap;
var SelectorsMatch = (function () {
    function SelectorsMatch() {
        this.changeMap = new Map();
    }
    SelectorsMatch.prototype.addAttribute = function (node, attribute) {
        var deps = this.properties(node);
        if (!deps.attributes) {
            deps.attributes = new Set();
        }
        deps.attributes.add(attribute);
    };
    SelectorsMatch.prototype.addPseudoClass = function (node, pseudoClass) {
        var deps = this.properties(node);
        if (!deps.pseudoClasses) {
            deps.pseudoClasses = new Set();
        }
        deps.pseudoClasses.add(pseudoClass);
    };
    SelectorsMatch.prototype.properties = function (node) {
        var set = this.changeMap.get(node);
        if (!set) {
            this.changeMap.set(node, set = {});
        }
        return set;
    };
    return SelectorsMatch;
}());
exports.SelectorsMatch = SelectorsMatch;
//# sourceMappingURL=css-selector.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/font-common.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var Font = (function () {
    function Font(fontFamily, fontSize, fontStyle, fontWeight) {
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.fontStyle = fontStyle;
        this.fontWeight = fontWeight;
    }
    Object.defineProperty(Font.prototype, "isItalic", {
        get: function () {
            return this.fontStyle === FontStyle.ITALIC;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Font.prototype, "isBold", {
        get: function () {
            return this.fontWeight === FontWeight.SEMI_BOLD ||
                this.fontWeight === FontWeight.BOLD ||
                this.fontWeight === "700" ||
                this.fontWeight === FontWeight.EXTRA_BOLD ||
                this.fontWeight === FontWeight.BLACK;
        },
        enumerable: true,
        configurable: true
    });
    Font.equals = function (value1, value2) {
        if (!value1 && !value2) {
            return true;
        }
        if (!value1 || !value2) {
            return false;
        }
        return value1.fontFamily === value2.fontFamily &&
            value1.fontSize === value2.fontSize &&
            value1.fontStyle === value2.fontStyle &&
            value1.fontWeight === value2.fontWeight;
    };
    Font.default = undefined;
    return Font;
}());
exports.Font = Font;
var FontStyle;
(function (FontStyle) {
    FontStyle.NORMAL = "normal";
    FontStyle.ITALIC = "italic";
    FontStyle.isValid = properties_1.makeValidator(FontStyle.NORMAL, FontStyle.ITALIC);
    FontStyle.parse = properties_1.makeParser(FontStyle.isValid);
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
var FontWeight;
(function (FontWeight) {
    FontWeight.THIN = "100";
    FontWeight.EXTRA_LIGHT = "200";
    FontWeight.LIGHT = "300";
    FontWeight.NORMAL = "normal";
    FontWeight.MEDIUM = "500";
    FontWeight.SEMI_BOLD = "600";
    FontWeight.BOLD = "bold";
    FontWeight.EXTRA_BOLD = "800";
    FontWeight.BLACK = "900";
    FontWeight.isValid = properties_1.makeValidator(FontWeight.THIN, FontWeight.EXTRA_LIGHT, FontWeight.LIGHT, FontWeight.NORMAL, "400", FontWeight.MEDIUM, FontWeight.SEMI_BOLD, FontWeight.BOLD, "700", FontWeight.EXTRA_BOLD, FontWeight.BLACK);
    FontWeight.parse = properties_1.makeParser(FontWeight.isValid);
})(FontWeight = exports.FontWeight || (exports.FontWeight = {}));
function parseFontFamily(value) {
    var result = new Array();
    if (!value) {
        return result;
    }
    var split = value.split(",");
    for (var i = 0; i < split.length; i++) {
        var str = split[i].trim().replace(/['"]+/g, "");
        if (str) {
            result.push(str);
        }
    }
    return result;
}
exports.parseFontFamily = parseFontFamily;
var genericFontFamilies;
(function (genericFontFamilies) {
    genericFontFamilies.serif = "serif";
    genericFontFamilies.sansSerif = "sans-serif";
    genericFontFamilies.monospace = "monospace";
    genericFontFamilies.system = "system";
})(genericFontFamilies = exports.genericFontFamilies || (exports.genericFontFamilies = {}));
var styles = new Set();
[
    FontStyle.NORMAL,
    FontStyle.ITALIC
].forEach(function (val, i, a) { return styles.add(val); });
var weights = new Set();
[
    FontWeight.THIN,
    FontWeight.EXTRA_LIGHT,
    FontWeight.LIGHT,
    FontWeight.NORMAL,
    "400",
    FontWeight.MEDIUM,
    FontWeight.SEMI_BOLD,
    FontWeight.BOLD,
    "700",
    FontWeight.EXTRA_BOLD,
    FontWeight.BLACK
].forEach(function (val, i, a) { return weights.add(val); });
function parseFont(fontValue) {
    var result = {
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal"
    };
    var parts = fontValue.split(/\s+/);
    var part;
    while (part = parts.shift()) {
        if (part === "normal") {
        }
        else if (part === "small-caps") {
            result.fontVariant = part;
        }
        else if (styles.has(part)) {
            result.fontStyle = part;
        }
        else if (weights.has(part)) {
            result.fontWeight = part;
        }
        else if (!result.fontSize) {
            var sizes = part.split("/");
            result.fontSize = sizes[0];
            result.lineHeight = sizes.length > 1 ? sizes[1] : undefined;
        }
        else {
            result.fontFamily = part;
            if (parts.length) {
                result.fontFamily += " " + parts.join(" ");
            }
            break;
        }
    }
    return result;
}
exports.parseFont = parseFont;
//# sourceMappingURL=font-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/font.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var font_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/font-common.js");
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var fs = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/styling/font-common.js"));
var EMULATE_OBLIQUE = true;
var OBLIQUE_TRANSFORM = CGAffineTransformMake(1, 0, 0.2, 1, 0, 0);
var DEFAULT_SERIF = "Times New Roman";
var DEFAULT_MONOSPACE = "Courier New";
var SUPPORT_FONT_WEIGHTS = parseFloat(platform_1.device.osVersion) >= 10.0;
var Font = (function (_super) {
    __extends(Font, _super);
    function Font(family, size, style, weight) {
        return _super.call(this, family, size, style, weight) || this;
    }
    Font.prototype.withFontFamily = function (family) {
        return new Font(family, this.fontSize, this.fontStyle, this.fontWeight);
    };
    Font.prototype.withFontStyle = function (style) {
        return new Font(this.fontFamily, this.fontSize, style, this.fontWeight);
    };
    Font.prototype.withFontWeight = function (weight) {
        return new Font(this.fontFamily, this.fontSize, this.fontStyle, weight);
    };
    Font.prototype.withFontSize = function (size) {
        return new Font(this.fontFamily, size, this.fontStyle, this.fontWeight);
    };
    Font.prototype.getUIFont = function (defaultFont) {
        if (!this._uiFont) {
            this._uiFont = createUIFont(this, defaultFont);
        }
        return this._uiFont;
    };
    Font.prototype.getAndroidTypeface = function () {
        return undefined;
    };
    Font.default = new Font(undefined, undefined, font_common_1.FontStyle.NORMAL, font_common_1.FontWeight.NORMAL);
    return Font;
}(font_common_1.Font));
exports.Font = Font;
function getFontFamilyRespectingGenericFonts(fontFamily) {
    if (!fontFamily) {
        return fontFamily;
    }
    switch (fontFamily.toLowerCase()) {
        case font_common_1.genericFontFamilies.serif:
            return DEFAULT_SERIF;
        case font_common_1.genericFontFamilies.monospace:
            return DEFAULT_MONOSPACE;
        default:
            return fontFamily;
    }
}
function shouldUseSystemFont(fontFamily) {
    return !fontFamily ||
        fontFamily === font_common_1.genericFontFamilies.sansSerif ||
        fontFamily === font_common_1.genericFontFamilies.system;
}
function getNativeFontWeight(fontWeight) {
    switch (fontWeight) {
        case font_common_1.FontWeight.THIN:
            return UIFontWeightUltraLight;
        case font_common_1.FontWeight.EXTRA_LIGHT:
            return UIFontWeightThin;
        case font_common_1.FontWeight.LIGHT:
            return UIFontWeightLight;
        case font_common_1.FontWeight.NORMAL:
        case "400":
        case undefined:
        case null:
            return UIFontWeightRegular;
        case font_common_1.FontWeight.MEDIUM:
            return UIFontWeightMedium;
        case font_common_1.FontWeight.SEMI_BOLD:
            return UIFontWeightSemibold;
        case font_common_1.FontWeight.BOLD:
        case "700":
            return UIFontWeightBold;
        case font_common_1.FontWeight.EXTRA_BOLD:
            return UIFontWeightHeavy;
        case font_common_1.FontWeight.BLACK:
            return UIFontWeightBlack;
        default:
            throw new Error("Invalid font weight: \"" + fontWeight + "\"");
    }
}
function getSystemFont(size, nativeWeight, italic, symbolicTraits) {
    var result = UIFont.systemFontOfSizeWeight(size, nativeWeight);
    if (italic) {
        var descriptor = result.fontDescriptor.fontDescriptorWithSymbolicTraits(symbolicTraits);
        result = UIFont.fontWithDescriptorSize(descriptor, size);
    }
    return result;
}
function createUIFont(font, defaultFont) {
    var _a, _b;
    var result;
    var size = font.fontSize || defaultFont.pointSize;
    var nativeWeight = getNativeFontWeight(font.fontWeight);
    var fontFamilies = font_common_1.parseFontFamily(font.fontFamily);
    var symbolicTraits = 0;
    if (font.isBold) {
        symbolicTraits |= 2;
    }
    if (font.isItalic) {
        symbolicTraits |= 1;
    }
    var fontDescriptorTraits = (_a = {},
        _a[UIFontSymbolicTrait] = symbolicTraits,
        _a);
    if (SUPPORT_FONT_WEIGHTS) {
        fontDescriptorTraits[UIFontWeightTrait] = nativeWeight;
    }
    for (var i = 0; i < fontFamilies.length; i++) {
        var fontFamily = getFontFamilyRespectingGenericFonts(fontFamilies[i]);
        if (shouldUseSystemFont(fontFamily)) {
            result = getSystemFont(size, nativeWeight, font.isItalic, symbolicTraits);
            break;
        }
        else {
            var fontAttributes = (_b = {},
                _b[UIFontDescriptorFamilyAttribute] = fontFamily,
                _b[UIFontDescriptorTraitsAttribute] = fontDescriptorTraits,
                _b);
            var descriptor = UIFontDescriptor.fontDescriptorWithFontAttributes(fontAttributes);
            result = UIFont.fontWithDescriptorSize(descriptor, size);
            var actualItalic = result.fontDescriptor.symbolicTraits & 1;
            if (font.isItalic && !actualItalic && EMULATE_OBLIQUE) {
                descriptor = descriptor.fontDescriptorWithMatrix(OBLIQUE_TRANSFORM);
                result = UIFont.fontWithDescriptorSize(descriptor, size);
            }
            if (result.familyName === fontFamily) {
                break;
            }
            else {
                result = null;
            }
        }
    }
    if (!result) {
        result = getSystemFont(size, nativeWeight, font.isItalic, symbolicTraits);
    }
    return result;
}
var ios;
(function (ios) {
    function registerFont(fontFile) {
        var filePath = fs.path.join(fs.knownFolders.currentApp().path, "fonts", fontFile);
        if (!fs.File.exists(filePath)) {
            filePath = fs.path.join(fs.knownFolders.currentApp().path, fontFile);
        }
        var fontData = NSFileManager.defaultManager.contentsAtPath(filePath);
        if (!fontData) {
            throw new Error("Could not load font from: " + fontFile);
        }
        var provider = CGDataProviderCreateWithCFData(fontData);
        var font = CGFontCreateWithDataProvider(provider);
        if (!font) {
            throw new Error("Could not load font from: " + fontFile);
        }
        var error = new interop.Reference();
        if (!CTFontManagerRegisterGraphicsFont(font, error)) {
            if (trace_1.isEnabled()) {
                trace_1.write("Error occur while registering font: " + CFErrorCopyDescription(error.value), trace_1.categories.Error, trace_1.messageType.error);
            }
        }
    }
    ios.registerFont = registerFont;
})(ios = exports.ios || (exports.ios = {}));
function registerFontsInFolder(fontsFolderPath) {
    var fontsFolder = fs.Folder.fromPath(fontsFolderPath);
    fontsFolder.eachEntity(function (fileEntity) {
        if (fs.Folder.exists(fs.path.join(fontsFolderPath, fileEntity.name))) {
            return true;
        }
        if (fileEntity instanceof fs.File &&
            (fileEntity.extension === ".ttf" || fileEntity.extension === ".otf")) {
            ios.registerFont(fileEntity.name);
        }
        return true;
    });
}
function registerCustomFonts() {
    var appDir = fs.knownFolders.currentApp().path;
    var fontsDir = fs.path.join(appDir, "fonts");
    if (fs.Folder.exists(fontsDir)) {
        registerFontsInFolder(fontsDir);
    }
}
registerCustomFonts();
//# sourceMappingURL=font.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/linear-gradient.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
var LinearGradient = (function () {
    function LinearGradient() {
    }
    LinearGradient.parse = function (value) {
        var result = new LinearGradient();
        result.angle = value.angle;
        result.colorStops = value.colors.map(function (color) {
            var offset = color.offset || null;
            var offsetUnit;
            if (offset && offset.unit === "%") {
                offsetUnit = {
                    unit: "%",
                    value: offset.value
                };
            }
            return {
                color: new color_1.Color(color.argb),
                offset: offsetUnit
            };
        });
        return result;
    };
    LinearGradient.equals = function (first, second) {
        if (!first && !second) {
            return true;
        }
        else if (!first || !second) {
            return false;
        }
        if (first.angle !== second.angle) {
            return false;
        }
        if (first.colorStops.length !== second.colorStops.length) {
            return false;
        }
        for (var i = 0; i < first.colorStops.length; i++) {
            var firstStop = first.colorStops[i];
            var secondStop = second.colorStops[i];
            if (firstStop.offset !== secondStop.offset) {
                return false;
            }
            if (!color_1.Color.equals(firstStop.color, secondStop.color)) {
                return false;
            }
        }
        return true;
    };
    return LinearGradient;
}());
exports.LinearGradient = LinearGradient;
//# sourceMappingURL=linear-gradient.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/style-properties.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var color_1 = __webpack_require__("../node_modules/tns-core-modules/color/color.js");
var font_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/font.js");
var utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils.js");
var background_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/background.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var number_utils_1 = __webpack_require__("../node_modules/tns-core-modules/utils/number-utils.js");
var matrix_1 = __webpack_require__("../node_modules/tns-core-modules/matrix/matrix.js");
var parser = __webpack_require__("../node_modules/tns-core-modules/css/parser.js");
var linear_gradient_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/linear-gradient.js");
function equalsCommon(a, b) {
    if (a == "auto") {
        return b == "auto";
    }
    if (typeof a === "number") {
        if (b == "auto") {
            return false;
        }
        if (typeof b === "number") {
            return a == b;
        }
        return b.unit == "dip" && a == b.value;
    }
    if (b == "auto") {
        return false;
    }
    if (typeof b === "number") {
        return a.unit == "dip" && a.value == b;
    }
    return a.value == b.value && a.unit == b.unit;
}
function convertToStringCommon(length) {
    if (length == "auto") {
        return "auto";
    }
    if (typeof length === "number") {
        return length.toString();
    }
    var val = length.value;
    if (length.unit === "%") {
        val *= 100;
    }
    return val + length.unit;
}
function toDevicePixelsCommon(length, auto, parentAvailableWidth) {
    if (auto === void 0) { auto = Number.NaN; }
    if (parentAvailableWidth === void 0) { parentAvailableWidth = Number.NaN; }
    if (length == "auto") {
        return auto;
    }
    if (typeof length === "number") {
        return utils_1.layout.round(utils_1.layout.toDevicePixels(length));
    }
    switch (length.unit) {
        case "px":
            return utils_1.layout.round(length.value);
        case "%":
            return utils_1.layout.round(parentAvailableWidth * length.value);
        case "dip":
        default:
            return utils_1.layout.round(utils_1.layout.toDevicePixels(length.value));
    }
}
var PercentLength;
(function (PercentLength) {
    function parse(fromValue) {
        if (fromValue == "auto") {
            return "auto";
        }
        if (typeof fromValue === "string") {
            var stringValue = fromValue.trim();
            var percentIndex = stringValue.indexOf("%");
            if (percentIndex !== -1) {
                var value = void 0;
                if (percentIndex !== (stringValue.length - 1) || percentIndex === 0) {
                    value = Number.NaN;
                }
                else {
                    value = parseFloat(stringValue.substring(0, stringValue.length - 1).trim()) / 100;
                }
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error("Invalid value: " + fromValue);
                }
                return { unit: "%", value: value };
            }
            else if (stringValue.indexOf("px") !== -1) {
                stringValue = stringValue.replace("px", "").trim();
                var value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error("Invalid value: " + fromValue);
                }
                return { unit: "px", value: value };
            }
            else {
                var value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error("Invalid value: " + fromValue);
                }
                return value;
            }
        }
        else {
            return fromValue;
        }
    }
    PercentLength.parse = parse;
    PercentLength.equals = equalsCommon;
    PercentLength.toDevicePixels = toDevicePixelsCommon;
    PercentLength.convertToString = convertToStringCommon;
})(PercentLength = exports.PercentLength || (exports.PercentLength = {}));
var Length;
(function (Length) {
    function parse(fromValue) {
        if (fromValue == "auto") {
            return "auto";
        }
        if (typeof fromValue === "string") {
            var stringValue = fromValue.trim();
            if (stringValue.indexOf("px") !== -1) {
                stringValue = stringValue.replace("px", "").trim();
                var value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error("Invalid value: " + stringValue);
                }
                return { unit: "px", value: value };
            }
            else {
                var value = parseFloat(stringValue);
                if (isNaN(value) || !isFinite(value)) {
                    throw new Error("Invalid value: " + stringValue);
                }
                return value;
            }
        }
        else {
            return fromValue;
        }
    }
    Length.parse = parse;
    Length.equals = equalsCommon;
    Length.toDevicePixels = toDevicePixelsCommon;
    Length.convertToString = convertToStringCommon;
})(Length = exports.Length || (exports.Length = {}));
exports.zeroLength = { value: 0, unit: "px" };
exports.minWidthProperty = new properties_1.CssProperty({
    name: "minWidth", cssName: "min-width", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectiveMinWidth = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.minWidthProperty.register(properties_1.Style);
exports.minHeightProperty = new properties_1.CssProperty({
    name: "minHeight", cssName: "min-height", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectiveMinHeight = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.minHeightProperty.register(properties_1.Style);
exports.widthProperty = new properties_1.CssProperty({ name: "width", cssName: "width", defaultValue: "auto", affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.widthProperty.register(properties_1.Style);
exports.heightProperty = new properties_1.CssProperty({ name: "height", cssName: "height", defaultValue: "auto", affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.heightProperty.register(properties_1.Style);
var marginProperty = new properties_1.ShorthandProperty({
    name: "margin", cssName: "margin",
    getter: function () {
        if (PercentLength.equals(this.marginTop, this.marginRight) &&
            PercentLength.equals(this.marginTop, this.marginBottom) &&
            PercentLength.equals(this.marginTop, this.marginLeft)) {
            return this.marginTop;
        }
        return PercentLength.convertToString(this.marginTop) + " " + PercentLength.convertToString(this.marginRight) + " " + PercentLength.convertToString(this.marginBottom) + " " + PercentLength.convertToString(this.marginLeft);
    },
    converter: convertToMargins
});
marginProperty.register(properties_1.Style);
exports.marginLeftProperty = new properties_1.CssProperty({ name: "marginLeft", cssName: "margin-left", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.marginLeftProperty.register(properties_1.Style);
exports.marginRightProperty = new properties_1.CssProperty({ name: "marginRight", cssName: "margin-right", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.marginRightProperty.register(properties_1.Style);
exports.marginTopProperty = new properties_1.CssProperty({ name: "marginTop", cssName: "margin-top", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.marginTopProperty.register(properties_1.Style);
exports.marginBottomProperty = new properties_1.CssProperty({ name: "marginBottom", cssName: "margin-bottom", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals, valueConverter: PercentLength.parse });
exports.marginBottomProperty.register(properties_1.Style);
var paddingProperty = new properties_1.ShorthandProperty({
    name: "padding", cssName: "padding",
    getter: function () {
        if (Length.equals(this.paddingTop, this.paddingRight) &&
            Length.equals(this.paddingTop, this.paddingBottom) &&
            Length.equals(this.paddingTop, this.paddingLeft)) {
            return this.paddingTop;
        }
        return Length.convertToString(this.paddingTop) + " " + Length.convertToString(this.paddingRight) + " " + Length.convertToString(this.paddingBottom) + " " + Length.convertToString(this.paddingLeft);
    },
    converter: convertToPaddings
});
paddingProperty.register(properties_1.Style);
exports.paddingLeftProperty = new properties_1.CssProperty({
    name: "paddingLeft", cssName: "padding-left", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectivePaddingLeft = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.paddingLeftProperty.register(properties_1.Style);
exports.paddingRightProperty = new properties_1.CssProperty({
    name: "paddingRight", cssName: "padding-right", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectivePaddingRight = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.paddingRightProperty.register(properties_1.Style);
exports.paddingTopProperty = new properties_1.CssProperty({
    name: "paddingTop", cssName: "padding-top", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectivePaddingTop = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.paddingTopProperty.register(properties_1.Style);
exports.paddingBottomProperty = new properties_1.CssProperty({
    name: "paddingBottom", cssName: "padding-bottom", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        target.view.effectivePaddingBottom = Length.toDevicePixels(newValue, 0);
    }, valueConverter: Length.parse
});
exports.paddingBottomProperty.register(properties_1.Style);
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment.LEFT = "left";
    HorizontalAlignment.CENTER = "center";
    HorizontalAlignment.RIGHT = "right";
    HorizontalAlignment.STRETCH = "stretch";
    HorizontalAlignment.isValid = properties_1.makeValidator(HorizontalAlignment.LEFT, HorizontalAlignment.CENTER, HorizontalAlignment.RIGHT, HorizontalAlignment.STRETCH);
    HorizontalAlignment.parse = properties_1.makeParser(HorizontalAlignment.isValid);
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
exports.horizontalAlignmentProperty = new properties_1.CssProperty({ name: "horizontalAlignment", cssName: "horizontal-align", defaultValue: HorizontalAlignment.STRETCH, affectsLayout: platform_1.isIOS, valueConverter: HorizontalAlignment.parse });
exports.horizontalAlignmentProperty.register(properties_1.Style);
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment.TOP = "top";
    VerticalAlignment.MIDDLE = "middle";
    VerticalAlignment.BOTTOM = "bottom";
    VerticalAlignment.STRETCH = "stretch";
    VerticalAlignment.isValid = properties_1.makeValidator(VerticalAlignment.TOP, VerticalAlignment.MIDDLE, VerticalAlignment.BOTTOM, VerticalAlignment.STRETCH);
    VerticalAlignment.parse = function (value) { return value.toLowerCase() === "center" ? VerticalAlignment.MIDDLE : parseStrict(value); };
    var parseStrict = properties_1.makeParser(VerticalAlignment.isValid);
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
exports.verticalAlignmentProperty = new properties_1.CssProperty({ name: "verticalAlignment", cssName: "vertical-align", defaultValue: VerticalAlignment.STRETCH, affectsLayout: platform_1.isIOS, valueConverter: VerticalAlignment.parse });
exports.verticalAlignmentProperty.register(properties_1.Style);
function parseThickness(value) {
    if (typeof value === "string") {
        var arr = value.split(/[ ,]+/);
        var top_1;
        var right = void 0;
        var bottom = void 0;
        var left = void 0;
        if (arr.length === 1) {
            top_1 = arr[0];
            right = arr[0];
            bottom = arr[0];
            left = arr[0];
        }
        else if (arr.length === 2) {
            top_1 = arr[0];
            bottom = arr[0];
            right = arr[1];
            left = arr[1];
        }
        else if (arr.length === 3) {
            top_1 = arr[0];
            right = arr[1];
            left = arr[1];
            bottom = arr[2];
        }
        else if (arr.length === 4) {
            top_1 = arr[0];
            right = arr[1];
            bottom = arr[2];
            left = arr[3];
        }
        else {
            throw new Error("Expected 1, 2, 3 or 4 parameters. Actual: " + value);
        }
        return {
            top: top_1,
            right: right,
            bottom: bottom,
            left: left
        };
    }
    else {
        return value;
    }
}
function convertToMargins(value) {
    if (typeof value === "string" && value !== "auto") {
        var thickness = parseThickness(value);
        return [
            [exports.marginTopProperty, PercentLength.parse(thickness.top)],
            [exports.marginRightProperty, PercentLength.parse(thickness.right)],
            [exports.marginBottomProperty, PercentLength.parse(thickness.bottom)],
            [exports.marginLeftProperty, PercentLength.parse(thickness.left)]
        ];
    }
    else {
        return [
            [exports.marginTopProperty, value],
            [exports.marginRightProperty, value],
            [exports.marginBottomProperty, value],
            [exports.marginLeftProperty, value]
        ];
    }
}
function convertToPaddings(value) {
    if (typeof value === "string" && value !== "auto") {
        var thickness = parseThickness(value);
        return [
            [exports.paddingTopProperty, Length.parse(thickness.top)],
            [exports.paddingRightProperty, Length.parse(thickness.right)],
            [exports.paddingBottomProperty, Length.parse(thickness.bottom)],
            [exports.paddingLeftProperty, Length.parse(thickness.left)]
        ];
    }
    else {
        return [
            [exports.paddingTopProperty, value],
            [exports.paddingRightProperty, value],
            [exports.paddingBottomProperty, value],
            [exports.paddingLeftProperty, value]
        ];
    }
}
exports.rotateProperty = new properties_1.CssAnimationProperty({ name: "rotate", cssName: "rotate", defaultValue: 0, valueConverter: parseFloat });
exports.rotateProperty.register(properties_1.Style);
exports.scaleXProperty = new properties_1.CssAnimationProperty({ name: "scaleX", cssName: "scaleX", defaultValue: 1, valueConverter: parseFloat });
exports.scaleXProperty.register(properties_1.Style);
exports.scaleYProperty = new properties_1.CssAnimationProperty({ name: "scaleY", cssName: "scaleY", defaultValue: 1, valueConverter: parseFloat });
exports.scaleYProperty.register(properties_1.Style);
function parseDIPs(value) {
    if (value.indexOf("px") !== -1) {
        return utils_1.layout.toDeviceIndependentPixels(parseFloat(value.replace("px", "").trim()));
    }
    else {
        return parseFloat(value.replace("dip", "").trim());
    }
}
exports.translateXProperty = new properties_1.CssAnimationProperty({ name: "translateX", cssName: "translateX", defaultValue: 0, valueConverter: parseDIPs });
exports.translateXProperty.register(properties_1.Style);
exports.translateYProperty = new properties_1.CssAnimationProperty({ name: "translateY", cssName: "translateY", defaultValue: 0, valueConverter: parseDIPs });
exports.translateYProperty.register(properties_1.Style);
var transformProperty = new properties_1.ShorthandProperty({
    name: "transform", cssName: "transform",
    getter: function () {
        var scaleX = this.scaleX;
        var scaleY = this.scaleY;
        var translateX = this.translateX;
        var translateY = this.translateY;
        var rotate = this.rotate;
        var result = "";
        if (translateX !== 0 || translateY !== 0) {
            result += "translate(" + translateX + ", " + translateY + ") ";
        }
        if (scaleX !== 1 || scaleY !== 1) {
            result += "scale(" + scaleX + ", " + scaleY + ") ";
        }
        if (rotate !== 0) {
            result += "rotate (" + rotate + ")";
        }
        return result.trim();
    },
    converter: convertToTransform
});
transformProperty.register(properties_1.Style);
var IDENTITY_TRANSFORMATION = {
    translate: { x: 0, y: 0 },
    rotate: 0,
    scale: { x: 1, y: 1 },
};
var TRANSFORM_SPLITTER = new RegExp(/\s*(.+?)\((.*?)\)/g);
var TRANSFORMATIONS = Object.freeze([
    "rotate",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
]);
var STYLE_TRANSFORMATION_MAP = Object.freeze({
    "scale": function (value) { return ({ property: "scale", value: value }); },
    "scale3d": function (value) { return ({ property: "scale", value: value }); },
    "scaleX": function (_a) {
        var x = _a.x;
        return ({ property: "scale", value: { x: x, y: IDENTITY_TRANSFORMATION.scale.y } });
    },
    "scaleY": function (_a) {
        var y = _a.y;
        return ({ property: "scale", value: { y: y, x: IDENTITY_TRANSFORMATION.scale.x } });
    },
    "translate": function (value) { return ({ property: "translate", value: value }); },
    "translate3d": function (value) { return ({ property: "translate", value: value }); },
    "translateX": function (_a) {
        var x = _a.x;
        return ({ property: "translate", value: { x: x, y: IDENTITY_TRANSFORMATION.translate.y } });
    },
    "translateY": function (_a) {
        var y = _a.y;
        return ({ property: "translate", value: { y: y, x: IDENTITY_TRANSFORMATION.translate.x } });
    },
    "rotate": function (value) { return ({ property: "rotate", value: value }); },
});
function convertToTransform(value) {
    if (value === properties_1.unsetValue) {
        value = "none";
    }
    var _a = transformConverter(value), translate = _a.translate, rotate = _a.rotate, scale = _a.scale;
    return [
        [exports.translateXProperty, translate.x],
        [exports.translateYProperty, translate.y],
        [exports.scaleXProperty, scale.x],
        [exports.scaleYProperty, scale.y],
        [exports.rotateProperty, rotate],
    ];
}
function transformConverter(text) {
    var transformations = parseTransformString(text);
    if (text === "none" || text === "" || !transformations.length) {
        return IDENTITY_TRANSFORMATION;
    }
    var usedTransforms = transformations.map(function (t) { return t.property; });
    if (!utils_1.hasDuplicates(usedTransforms)) {
        var fullTransformations_1 = __assign({}, IDENTITY_TRANSFORMATION);
        transformations.forEach(function (transform) {
            fullTransformations_1[transform.property] = transform.value;
        });
        return fullTransformations_1;
    }
    var affineMatrix = transformations
        .map(matrix_1.getTransformMatrix)
        .reduce(matrix_1.multiplyAffine2d);
    var cssMatrix = matrix_1.matrixArrayToCssMatrix(affineMatrix);
    return matrix_1.decompose2DTransformMatrix(cssMatrix);
}
exports.transformConverter = transformConverter;
function parseTransformString(text) {
    var matches = [];
    var match;
    while ((match = TRANSFORM_SPLITTER.exec(text)) !== null) {
        var property = match[1];
        var value = convertTransformValue(property, match[2]);
        if (TRANSFORMATIONS.indexOf(property) !== -1) {
            matches.push(normalizeTransformation({ property: property, value: value }));
        }
    }
    return matches;
}
function normalizeTransformation(_a) {
    var property = _a.property, value = _a.value;
    return STYLE_TRANSFORMATION_MAP[property](value);
}
function convertTransformValue(property, stringValue) {
    var _a = stringValue.split(",").map(parseFloat), x = _a[0], _b = _a[1], y = _b === void 0 ? x : _b;
    if (property === "rotate") {
        return stringValue.slice(-3) === "rad" ? number_utils_1.radiansToDegrees(x) : x;
    }
    return { x: x, y: y };
}
var backgroundProperty = new properties_1.ShorthandProperty({
    name: "background", cssName: "background",
    getter: function () {
        return this.backgroundColor + " " + this.backgroundImage + " " + this.backgroundRepeat + " " + this.backgroundPosition;
    },
    converter: convertToBackgrounds
});
backgroundProperty.register(properties_1.Style);
exports.backgroundInternalProperty = new properties_1.CssProperty({
    name: "backgroundInternal",
    cssName: "_backgroundInternal",
    defaultValue: background_1.Background.default
});
exports.backgroundInternalProperty.register(properties_1.Style);
exports.backgroundImageProperty = new properties_1.CssProperty({
    name: "backgroundImage", cssName: "background-image", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withImage(newValue);
        target.backgroundInternal = background;
    },
    equalityComparer: function (value1, value2) {
        if (value1 instanceof linear_gradient_1.LinearGradient && value2 instanceof linear_gradient_1.LinearGradient) {
            return linear_gradient_1.LinearGradient.equals(value1, value2);
        }
        else {
            return value1 === value2;
        }
    },
    valueConverter: function (value) {
        if (typeof value === "string") {
            var parsed = parser.parseBackground(value);
            if (parsed) {
                var background = parsed.value;
                value = (typeof background.image === "object") ? linear_gradient_1.LinearGradient.parse(background.image) : value;
            }
        }
        return value;
    }
});
exports.backgroundImageProperty.register(properties_1.Style);
exports.backgroundColorProperty = new properties_1.CssAnimationProperty({
    name: "backgroundColor", cssName: "background-color", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withColor(newValue);
        target.backgroundInternal = background;
    }, equalityComparer: color_1.Color.equals, valueConverter: function (value) { return new color_1.Color(value); }
});
exports.backgroundColorProperty.register(properties_1.Style);
var BackgroundRepeat;
(function (BackgroundRepeat) {
    BackgroundRepeat.REPEAT = "repeat";
    BackgroundRepeat.REPEAT_X = "repeat-x";
    BackgroundRepeat.REPEAT_Y = "repeat-y";
    BackgroundRepeat.NO_REPEAT = "no-repeat";
    BackgroundRepeat.isValid = properties_1.makeValidator(BackgroundRepeat.REPEAT, BackgroundRepeat.REPEAT_X, BackgroundRepeat.REPEAT_Y, BackgroundRepeat.NO_REPEAT);
    BackgroundRepeat.parse = properties_1.makeParser(BackgroundRepeat.isValid);
})(BackgroundRepeat = exports.BackgroundRepeat || (exports.BackgroundRepeat = {}));
exports.backgroundRepeatProperty = new properties_1.CssProperty({
    name: "backgroundRepeat", cssName: "background-repeat", valueConverter: BackgroundRepeat.parse,
    valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withRepeat(newValue);
        target.backgroundInternal = background;
    }
});
exports.backgroundRepeatProperty.register(properties_1.Style);
exports.backgroundSizeProperty = new properties_1.CssProperty({
    name: "backgroundSize", cssName: "background-size", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withSize(newValue);
        target.backgroundInternal = background;
    }
});
exports.backgroundSizeProperty.register(properties_1.Style);
exports.backgroundPositionProperty = new properties_1.CssProperty({
    name: "backgroundPosition", cssName: "background-position", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withPosition(newValue);
        target.backgroundInternal = background;
    }
});
exports.backgroundPositionProperty.register(properties_1.Style);
function convertToBackgrounds(value) {
    if (typeof value === "string") {
        var backgrounds = parser.parseBackground(value).value;
        var backgroundColor = backgrounds.color ? new color_1.Color(backgrounds.color) : properties_1.unsetValue;
        var backgroundImage = void 0;
        if (typeof backgrounds.image === "object" && backgrounds.image) {
            backgroundImage = linear_gradient_1.LinearGradient.parse(backgrounds.image);
        }
        else {
            backgroundImage = backgrounds.image || properties_1.unsetValue;
        }
        var backgroundRepeat = backgrounds.repeat || properties_1.unsetValue;
        var backgroundPosition = backgrounds.position ? backgrounds.position.text : properties_1.unsetValue;
        return [
            [exports.backgroundColorProperty, backgroundColor],
            [exports.backgroundImageProperty, backgroundImage],
            [exports.backgroundRepeatProperty, backgroundRepeat],
            [exports.backgroundPositionProperty, backgroundPosition]
        ];
    }
    else {
        return [
            [exports.backgroundColorProperty, properties_1.unsetValue],
            [exports.backgroundImageProperty, properties_1.unsetValue],
            [exports.backgroundRepeatProperty, properties_1.unsetValue],
            [exports.backgroundPositionProperty, properties_1.unsetValue]
        ];
    }
}
function parseBorderColor(value) {
    var result = { top: undefined, right: undefined, bottom: undefined, left: undefined };
    if (value.indexOf("rgb") === 0) {
        result.top = result.right = result.bottom = result.left = new color_1.Color(value);
        return result;
    }
    var arr = value.split(/[ ,]+/);
    if (arr.length === 1) {
        var arr0 = new color_1.Color(arr[0]);
        result.top = arr0;
        result.right = arr0;
        result.bottom = arr0;
        result.left = arr0;
    }
    else if (arr.length === 2) {
        var arr0 = new color_1.Color(arr[0]);
        var arr1 = new color_1.Color(arr[1]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr0;
        result.left = arr1;
    }
    else if (arr.length === 3) {
        var arr0 = new color_1.Color(arr[0]);
        var arr1 = new color_1.Color(arr[1]);
        var arr2 = new color_1.Color(arr[2]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr2;
        result.left = arr1;
    }
    else if (arr.length === 4) {
        var arr0 = new color_1.Color(arr[0]);
        var arr1 = new color_1.Color(arr[1]);
        var arr2 = new color_1.Color(arr[2]);
        var arr3 = new color_1.Color(arr[3]);
        result.top = arr0;
        result.right = arr1;
        result.bottom = arr2;
        result.left = arr3;
    }
    else {
        throw new Error("Expected 1, 2, 3 or 4 parameters. Actual: " + value);
    }
    return result;
}
var borderColorProperty = new properties_1.ShorthandProperty({
    name: "borderColor", cssName: "border-color",
    getter: function () {
        if (color_1.Color.equals(this.borderTopColor, this.borderRightColor) &&
            color_1.Color.equals(this.borderTopColor, this.borderBottomColor) &&
            color_1.Color.equals(this.borderTopColor, this.borderLeftColor)) {
            return this.borderTopColor;
        }
        else {
            return this.borderTopColor + " " + this.borderRightColor + " " + this.borderBottomColor + " " + this.borderLeftColor;
        }
    },
    converter: function (value) {
        if (typeof value === "string") {
            var fourColors = parseBorderColor(value);
            return [
                [exports.borderTopColorProperty, fourColors.top],
                [exports.borderRightColorProperty, fourColors.right],
                [exports.borderBottomColorProperty, fourColors.bottom],
                [exports.borderLeftColorProperty, fourColors.left]
            ];
        }
        else {
            return [
                [exports.borderTopColorProperty, value],
                [exports.borderRightColorProperty, value],
                [exports.borderBottomColorProperty, value],
                [exports.borderLeftColorProperty, value]
            ];
        }
    }
});
borderColorProperty.register(properties_1.Style);
exports.borderTopColorProperty = new properties_1.CssProperty({
    name: "borderTopColor", cssName: "border-top-color", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withBorderTopColor(newValue);
        target.backgroundInternal = background;
    }, equalityComparer: color_1.Color.equals, valueConverter: function (value) { return new color_1.Color(value); }
});
exports.borderTopColorProperty.register(properties_1.Style);
exports.borderRightColorProperty = new properties_1.CssProperty({
    name: "borderRightColor", cssName: "border-right-color", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withBorderRightColor(newValue);
        target.backgroundInternal = background;
    }, equalityComparer: color_1.Color.equals, valueConverter: function (value) { return new color_1.Color(value); }
});
exports.borderRightColorProperty.register(properties_1.Style);
exports.borderBottomColorProperty = new properties_1.CssProperty({
    name: "borderBottomColor", cssName: "border-bottom-color", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withBorderBottomColor(newValue);
        target.backgroundInternal = background;
    }, equalityComparer: color_1.Color.equals, valueConverter: function (value) { return new color_1.Color(value); }
});
exports.borderBottomColorProperty.register(properties_1.Style);
exports.borderLeftColorProperty = new properties_1.CssProperty({
    name: "borderLeftColor", cssName: "border-left-color", valueChanged: function (target, oldValue, newValue) {
        var background = target.backgroundInternal.withBorderLeftColor(newValue);
        target.backgroundInternal = background;
    }, equalityComparer: color_1.Color.equals, valueConverter: function (value) { return new color_1.Color(value); }
});
exports.borderLeftColorProperty.register(properties_1.Style);
var borderWidthProperty = new properties_1.ShorthandProperty({
    name: "borderWidth", cssName: "border-width",
    getter: function () {
        if (Length.equals(this.borderTopWidth, this.borderRightWidth) &&
            Length.equals(this.borderTopWidth, this.borderBottomWidth) &&
            Length.equals(this.borderTopWidth, this.borderLeftWidth)) {
            return this.borderTopWidth;
        }
        else {
            return Length.convertToString(this.borderTopWidth) + " " + Length.convertToString(this.borderRightWidth) + " " + Length.convertToString(this.borderBottomWidth) + " " + Length.convertToString(this.borderLeftWidth);
        }
    },
    converter: function (value) {
        if (typeof value === "string" && value !== "auto") {
            var borderWidths = parseThickness(value);
            return [
                [exports.borderTopWidthProperty, borderWidths.top],
                [exports.borderRightWidthProperty, borderWidths.right],
                [exports.borderBottomWidthProperty, borderWidths.bottom],
                [exports.borderLeftWidthProperty, borderWidths.left]
            ];
        }
        else {
            return [
                [exports.borderTopWidthProperty, value],
                [exports.borderRightWidthProperty, value],
                [exports.borderBottomWidthProperty, value],
                [exports.borderLeftWidthProperty, value]
            ];
        }
    }
});
borderWidthProperty.register(properties_1.Style);
exports.borderTopWidthProperty = new properties_1.CssProperty({
    name: "borderTopWidth", cssName: "border-top-width", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-top-width should be Non-Negative Finite number. Value: " + value);
        }
        target.view.effectiveBorderTopWidth = value;
        var background = target.backgroundInternal.withBorderTopWidth(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderTopWidthProperty.register(properties_1.Style);
exports.borderRightWidthProperty = new properties_1.CssProperty({
    name: "borderRightWidth", cssName: "border-right-width", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-right-width should be Non-Negative Finite number. Value: " + value);
        }
        target.view.effectiveBorderRightWidth = value;
        var background = target.backgroundInternal.withBorderRightWidth(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderRightWidthProperty.register(properties_1.Style);
exports.borderBottomWidthProperty = new properties_1.CssProperty({
    name: "borderBottomWidth", cssName: "border-bottom-width", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-bottom-width should be Non-Negative Finite number. Value: " + value);
        }
        target.view.effectiveBorderBottomWidth = value;
        var background = target.backgroundInternal.withBorderBottomWidth(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderBottomWidthProperty.register(properties_1.Style);
exports.borderLeftWidthProperty = new properties_1.CssProperty({
    name: "borderLeftWidth", cssName: "border-left-width", defaultValue: exports.zeroLength, affectsLayout: platform_1.isIOS, equalityComparer: Length.equals,
    valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-left-width should be Non-Negative Finite number. Value: " + value);
        }
        target.view.effectiveBorderLeftWidth = value;
        var background = target.backgroundInternal.withBorderLeftWidth(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderLeftWidthProperty.register(properties_1.Style);
var borderRadiusProperty = new properties_1.ShorthandProperty({
    name: "borderRadius", cssName: "border-radius",
    getter: function () {
        if (Length.equals(this.borderTopLeftRadius, this.borderTopRightRadius) &&
            Length.equals(this.borderTopLeftRadius, this.borderBottomRightRadius) &&
            Length.equals(this.borderTopLeftRadius, this.borderBottomLeftRadius)) {
            return this.borderTopLeftRadius;
        }
        return Length.convertToString(this.borderTopLeftRadius) + " " + Length.convertToString(this.borderTopRightRadius) + " " + Length.convertToString(this.borderBottomRightRadius) + " " + Length.convertToString(this.borderBottomLeftRadius);
    },
    converter: function (value) {
        if (typeof value === "string") {
            var borderRadius = parseThickness(value);
            return [
                [exports.borderTopLeftRadiusProperty, borderRadius.top],
                [exports.borderTopRightRadiusProperty, borderRadius.right],
                [exports.borderBottomRightRadiusProperty, borderRadius.bottom],
                [exports.borderBottomLeftRadiusProperty, borderRadius.left]
            ];
        }
        else {
            return [
                [exports.borderTopLeftRadiusProperty, value],
                [exports.borderTopRightRadiusProperty, value],
                [exports.borderBottomRightRadiusProperty, value],
                [exports.borderBottomLeftRadiusProperty, value]
            ];
        }
    }
});
borderRadiusProperty.register(properties_1.Style);
exports.borderTopLeftRadiusProperty = new properties_1.CssProperty({
    name: "borderTopLeftRadius", cssName: "border-top-left-radius", defaultValue: 0, affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-top-left-radius should be Non-Negative Finite number. Value: " + value);
        }
        var background = target.backgroundInternal.withBorderTopLeftRadius(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderTopLeftRadiusProperty.register(properties_1.Style);
exports.borderTopRightRadiusProperty = new properties_1.CssProperty({
    name: "borderTopRightRadius", cssName: "border-top-right-radius", defaultValue: 0, affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-top-right-radius should be Non-Negative Finite number. Value: " + value);
        }
        var background = target.backgroundInternal.withBorderTopRightRadius(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderTopRightRadiusProperty.register(properties_1.Style);
exports.borderBottomRightRadiusProperty = new properties_1.CssProperty({
    name: "borderBottomRightRadius", cssName: "border-bottom-right-radius", defaultValue: 0, affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-bottom-right-radius should be Non-Negative Finite number. Value: " + value);
        }
        var background = target.backgroundInternal.withBorderBottomRightRadius(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderBottomRightRadiusProperty.register(properties_1.Style);
exports.borderBottomLeftRadiusProperty = new properties_1.CssProperty({
    name: "borderBottomLeftRadius", cssName: "border-bottom-left-radius", defaultValue: 0, affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var value = Length.toDevicePixels(newValue, 0);
        if (!isNonNegativeFiniteNumber(value)) {
            throw new Error("border-bottom-left-radius should be Non-Negative Finite number. Value: " + value);
        }
        var background = target.backgroundInternal.withBorderBottomLeftRadius(value);
        target.backgroundInternal = background;
    }, valueConverter: Length.parse
});
exports.borderBottomLeftRadiusProperty.register(properties_1.Style);
function isNonNegativeFiniteNumber(value) {
    return isFinite(value) && !isNaN(value) && value >= 0;
}
var supportedPaths = ["rect", "circle", "ellipse", "polygon", "inset"];
function isClipPathValid(value) {
    if (!value) {
        return true;
    }
    var functionName = value.substring(0, value.indexOf("(")).trim();
    return supportedPaths.indexOf(functionName) !== -1;
}
exports.clipPathProperty = new properties_1.CssProperty({
    name: "clipPath", cssName: "clip-path", valueChanged: function (target, oldValue, newValue) {
        if (!isClipPathValid(newValue)) {
            throw new Error("clip-path is not valid.");
        }
        var background = target.backgroundInternal.withClipPath(newValue);
        target.backgroundInternal = background;
    }
});
exports.clipPathProperty.register(properties_1.Style);
function isFloatValueConverter(value) {
    var newValue = parseFloat(value);
    if (isNaN(newValue)) {
        throw new Error("Invalid value: " + newValue);
    }
    return newValue;
}
exports.zIndexProperty = new properties_1.CssProperty({ name: "zIndex", cssName: "z-index", valueConverter: isFloatValueConverter });
exports.zIndexProperty.register(properties_1.Style);
function opacityConverter(value) {
    var newValue = parseFloat(value);
    if (!isNaN(newValue) && 0 <= newValue && newValue <= 1) {
        return newValue;
    }
    throw new Error("Opacity should be between [0, 1]. Value: " + newValue);
}
exports.opacityProperty = new properties_1.CssAnimationProperty({ name: "opacity", cssName: "opacity", defaultValue: 1, valueConverter: opacityConverter });
exports.opacityProperty.register(properties_1.Style);
exports.colorProperty = new properties_1.InheritedCssProperty({ name: "color", cssName: "color", equalityComparer: color_1.Color.equals, valueConverter: function (v) { return new color_1.Color(v); } });
exports.colorProperty.register(properties_1.Style);
exports.fontInternalProperty = new properties_1.CssProperty({ name: "fontInternal", cssName: "_fontInternal", defaultValue: font_1.Font.default });
exports.fontInternalProperty.register(properties_1.Style);
exports.fontFamilyProperty = new properties_1.InheritedCssProperty({
    name: "fontFamily", cssName: "font-family", affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var currentFont = target.fontInternal;
        if (currentFont.fontFamily !== newValue) {
            var newFont = currentFont.withFontFamily(newValue);
            target.fontInternal = font_1.Font.equals(font_1.Font.default, newFont) ? properties_1.unsetValue : newFont;
        }
    }
});
exports.fontFamilyProperty.register(properties_1.Style);
exports.fontSizeProperty = new properties_1.InheritedCssProperty({
    name: "fontSize", cssName: "font-size", affectsLayout: platform_1.isIOS, valueChanged: function (target, oldValue, newValue) {
        var currentFont = target.fontInternal;
        if (currentFont.fontSize !== newValue) {
            var newFont = currentFont.withFontSize(newValue);
            target.fontInternal = font_1.Font.equals(font_1.Font.default, newFont) ? properties_1.unsetValue : newFont;
        }
    },
    valueConverter: function (v) { return parseFloat(v); }
});
exports.fontSizeProperty.register(properties_1.Style);
exports.fontStyleProperty = new properties_1.InheritedCssProperty({
    name: "fontStyle", cssName: "font-style", affectsLayout: platform_1.isIOS, defaultValue: font_1.FontStyle.NORMAL, valueConverter: font_1.FontStyle.parse, valueChanged: function (target, oldValue, newValue) {
        var currentFont = target.fontInternal;
        if (currentFont.fontStyle !== newValue) {
            var newFont = currentFont.withFontStyle(newValue);
            target.fontInternal = font_1.Font.equals(font_1.Font.default, newFont) ? properties_1.unsetValue : newFont;
        }
    }
});
exports.fontStyleProperty.register(properties_1.Style);
exports.fontWeightProperty = new properties_1.InheritedCssProperty({
    name: "fontWeight", cssName: "font-weight", affectsLayout: platform_1.isIOS, defaultValue: font_1.FontWeight.NORMAL, valueConverter: font_1.FontWeight.parse, valueChanged: function (target, oldValue, newValue) {
        var currentFont = target.fontInternal;
        if (currentFont.fontWeight !== newValue) {
            var newFont = currentFont.withFontWeight(newValue);
            target.fontInternal = font_1.Font.equals(font_1.Font.default, newFont) ? properties_1.unsetValue : newFont;
        }
    }
});
exports.fontWeightProperty.register(properties_1.Style);
var fontProperty = new properties_1.ShorthandProperty({
    name: "font", cssName: "font",
    getter: function () {
        return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + " " + this.fontFamily;
    },
    converter: function (value) {
        if (value === properties_1.unsetValue) {
            return [
                [exports.fontStyleProperty, properties_1.unsetValue],
                [exports.fontWeightProperty, properties_1.unsetValue],
                [exports.fontSizeProperty, properties_1.unsetValue],
                [exports.fontFamilyProperty, properties_1.unsetValue]
            ];
        }
        else {
            var font = font_1.parseFont(value);
            var fontSize = parseFloat(font.fontSize);
            return [
                [exports.fontStyleProperty, font.fontStyle],
                [exports.fontWeightProperty, font.fontWeight],
                [exports.fontSizeProperty, fontSize],
                [exports.fontFamilyProperty, font.fontFamily]
            ];
        }
    }
});
fontProperty.register(properties_1.Style);
var Visibility;
(function (Visibility) {
    Visibility.VISIBLE = "visible";
    Visibility.HIDDEN = "hidden";
    Visibility.COLLAPSE = "collapse";
    Visibility.isValid = properties_1.makeValidator(Visibility.VISIBLE, Visibility.HIDDEN, Visibility.COLLAPSE);
    Visibility.parse = function (value) { return value.toLowerCase() === "collapsed" ? Visibility.COLLAPSE : parseStrict(value); };
    var parseStrict = properties_1.makeParser(Visibility.isValid);
})(Visibility = exports.Visibility || (exports.Visibility = {}));
exports.visibilityProperty = new properties_1.CssProperty({
    name: "visibility", cssName: "visibility", defaultValue: Visibility.VISIBLE, affectsLayout: platform_1.isIOS, valueConverter: Visibility.parse, valueChanged: function (target, oldValue, newValue) {
        target.view.isCollapsed = (newValue === Visibility.COLLAPSE);
    }
});
exports.visibilityProperty.register(properties_1.Style);
exports.androidElevationProperty = new properties_1.CssProperty({ name: "androidElevation", cssName: "android-elevation", valueConverter: parseFloat });
exports.androidElevationProperty.register(properties_1.Style);
exports.androidDynamicElevationOffsetProperty = new properties_1.CssProperty({ name: "androidDynamicElevationOffset", cssName: "android-dynamic-elevation-offset", valueConverter: parseFloat });
exports.androidDynamicElevationOffsetProperty.register(properties_1.Style);
//# sourceMappingURL=style-properties.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/style-scope.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/properties/properties.js");
var css_1 = __webpack_require__("../node_modules/tns-core-modules/css/index.js");
var parser_1 = __webpack_require__("../node_modules/tns-core-modules/css/parser.js");
var css_selector_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/css-selector/css-selector.js");
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var applicationCommon = __webpack_require__("../node_modules/tns-core-modules/application/application-common.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
var keyframeAnimationModule;
function ensureKeyframeAnimationModule() {
    if (!keyframeAnimationModule) {
        keyframeAnimationModule = __webpack_require__("../node_modules/tns-core-modules/ui/animation/keyframe-animation.js");
    }
}
var cssAnimationParserModule;
function ensureCssAnimationParserModule() {
    if (!cssAnimationParserModule) {
        cssAnimationParserModule = __webpack_require__("../node_modules/tns-core-modules/ui/styling/css-animation-parser.js");
    }
}
var parser = "rework";
try {
    var appConfig = __webpack_require__("./package.json");
    if (appConfig && appConfig.cssParser === "nativescript") {
        parser = "nativescript";
    }
}
catch (e) {
}
function mergeCssSelectors() {
    applicationCssSelectors = applicationSelectors.slice();
    applicationCssSelectors.push.apply(applicationCssSelectors, applicationAdditionalSelectors);
    applicationCssSelectorVersion++;
}
exports.mergeCssSelectors = mergeCssSelectors;
var applicationCssSelectors = [];
var applicationCssSelectorVersion = 0;
var applicationSelectors = [];
var applicationAdditionalSelectors = [];
var applicationKeyframes = {};
var animationsSymbol = Symbol("animations");
var pattern = /('|")(.*?)\1/;
var CSSSource = (function () {
    function CSSSource(_ast, _url, _file, _keyframes, _source) {
        this._ast = _ast;
        this._url = _url;
        this._file = _file;
        this._keyframes = _keyframes;
        this._source = _source;
        this._selectors = [];
        this.parse();
    }
    CSSSource.fromURI = function (uri, keyframes) {
        var appRelativeUri = CSSSource.pathRelativeToApp(uri);
        try {
            var cssOrAst = global.loadModule(appRelativeUri);
            if (cssOrAst) {
                if (typeof cssOrAst === "string") {
                    return CSSSource.fromSource(cssOrAst, keyframes, appRelativeUri);
                }
                else if (typeof cssOrAst === "object" && cssOrAst.type === "stylesheet" && cssOrAst.stylesheet && cssOrAst.stylesheet.rules) {
                    return CSSSource.fromAST(cssOrAst, keyframes, appRelativeUri);
                }
                else {
                    return CSSSource.fromSource(cssOrAst.toString(), keyframes, appRelativeUri);
                }
            }
        }
        catch (e) {
        }
        return CSSSource.fromFile(appRelativeUri, keyframes);
    };
    CSSSource.pathRelativeToApp = function (uri) {
        if (!uri.startsWith("/")) {
            return uri;
        }
        var appPath = file_system_1.knownFolders.currentApp().path;
        if (!uri.startsWith(appPath)) {
            trace_1.write(uri + " does not start with " + appPath, trace_1.categories.Error, trace_1.messageType.error);
            return uri;
        }
        var relativeUri = "." + uri.substr(appPath.length);
        return relativeUri;
    };
    CSSSource.fromFile = function (url, keyframes) {
        var cssFileUrl = url.replace(/\..\w+$/, ".css");
        if (cssFileUrl !== url) {
            var cssFile = CSSSource.resolveCSSPathFromURL(cssFileUrl);
            if (cssFile) {
                return new CSSSource(undefined, url, cssFile, keyframes, undefined);
            }
        }
        var file = CSSSource.resolveCSSPathFromURL(url);
        return new CSSSource(undefined, url, file, keyframes, undefined);
    };
    CSSSource.fromFileImport = function (url, keyframes, importSource) {
        var file = CSSSource.resolveCSSPathFromURL(url, importSource);
        return new CSSSource(undefined, url, file, keyframes, undefined);
    };
    CSSSource.resolveCSSPathFromURL = function (url, importSource) {
        var app = file_system_1.knownFolders.currentApp().path;
        var file = resolveFileNameFromUrl(url, app, file_system_1.File.exists, importSource);
        return file;
    };
    CSSSource.fromSource = function (source, keyframes, url) {
        return new CSSSource(undefined, url, undefined, keyframes, source);
    };
    CSSSource.fromAST = function (ast, keyframes, url) {
        return new CSSSource(ast, url, undefined, keyframes, undefined);
    };
    Object.defineProperty(CSSSource.prototype, "selectors", {
        get: function () { return this._selectors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CSSSource.prototype, "source", {
        get: function () { return this._source; },
        enumerable: true,
        configurable: true
    });
    CSSSource.prototype.load = function () {
        var file = file_system_1.File.fromPath(this._file);
        this._source = file.readTextSync();
    };
    CSSSource.prototype.parse = function () {
        try {
            if (!this._ast) {
                if (!this._source && this._file) {
                    this.load();
                }
                if (this._source && this.source !== "[object Object]") {
                    this.parseCSSAst();
                }
            }
            if (this._ast) {
                this.createSelectors();
            }
            else {
                this._selectors = [];
            }
        }
        catch (e) {
            trace_1.write("Css styling failed: " + e, trace_1.categories.Error, trace_1.messageType.error);
            this._selectors = [];
        }
    };
    CSSSource.prototype.parseCSSAst = function () {
        if (this._source) {
            switch (parser) {
                case "nativescript":
                    var cssparser = new parser_1.CSS3Parser(this._source);
                    var stylesheet = cssparser.parseAStylesheet();
                    var cssNS = new parser_1.CSSNativeScript();
                    this._ast = cssNS.parseStylesheet(stylesheet);
                    return;
                case "rework":
                    this._ast = css_1.parse(this._source, { source: this._file });
                    return;
            }
        }
    };
    CSSSource.prototype.createSelectors = function () {
        if (this._ast) {
            this._selectors = this.createSelectorsFromImports().concat(this.createSelectorsFromSyntaxTree());
        }
    };
    CSSSource.prototype.createSelectorsFromImports = function () {
        var _this = this;
        var imports = this._ast["stylesheet"]["rules"].filter(function (r) { return r.type === "import"; });
        var urlFromImportObject = function (importObject) {
            var importItem = importObject["import"];
            var urlMatch = importItem && importItem.match(pattern);
            return urlMatch && urlMatch[2];
        };
        var sourceFromImportObject = function (importObject) {
            return importObject["position"] && importObject["position"]["source"];
        };
        var toUrlSourcePair = function (importObject) { return ({
            url: urlFromImportObject(importObject),
            source: sourceFromImportObject(importObject),
        }); };
        var getCssFile = function (_a) {
            var url = _a.url, source = _a.source;
            return source ?
                CSSSource.fromFileImport(url, _this._keyframes, source) :
                CSSSource.fromURI(url, _this._keyframes);
        };
        var cssFiles = imports
            .map(toUrlSourcePair)
            .filter(function (_a) {
            var url = _a.url;
            return !!url;
        })
            .map(getCssFile);
        var selectors = cssFiles.map(function (file) { return (file && file.selectors) || []; });
        return selectors.reduce(function (acc, val) { return acc.concat(val); }, []);
    };
    CSSSource.prototype.createSelectorsFromSyntaxTree = function () {
        var _this = this;
        var nodes = this._ast.stylesheet.rules;
        nodes.filter(isKeyframe).forEach(function (node) { return _this._keyframes[node.name] = node; });
        var rulesets = css_selector_1.fromAstNodes(nodes);
        if (rulesets && rulesets.length) {
            ensureCssAnimationParserModule();
            rulesets.forEach(function (rule) {
                rule[animationsSymbol] = cssAnimationParserModule.CssAnimationParser
                    .keyframeAnimationsFromCSSDeclarations(rule.declarations);
            });
        }
        return rulesets;
    };
    CSSSource.prototype.toString = function () {
        return this._file || this._url || "(in-memory)";
    };
    __decorate([
        profiling_1.profile
    ], CSSSource.prototype, "load", null);
    __decorate([
        profiling_1.profile
    ], CSSSource.prototype, "parse", null);
    __decorate([
        profiling_1.profile
    ], CSSSource.prototype, "parseCSSAst", null);
    __decorate([
        profiling_1.profile
    ], CSSSource.prototype, "createSelectors", null);
    __decorate([
        profiling_1.profile
    ], CSSSource, "resolveCSSPathFromURL", null);
    return CSSSource;
}());
function removeTaggedAdditionalCSS(tag) {
    var changed = false;
    for (var i = 0; i < applicationAdditionalSelectors.length; i++) {
        if (applicationAdditionalSelectors[i].tag === tag) {
            applicationAdditionalSelectors.splice(i, 1);
            i--;
            changed = true;
        }
    }
    if (changed) {
        mergeCssSelectors();
    }
    return changed;
}
exports.removeTaggedAdditionalCSS = removeTaggedAdditionalCSS;
function addTaggedAdditionalCSS(cssText, tag) {
    var parsed = CSSSource.fromSource(cssText, applicationKeyframes, undefined).selectors;
    var changed = false;
    if (parsed && parsed.length) {
        changed = true;
        if (tag != null) {
            for (var i = 0; i < parsed.length; i++) {
                parsed[i].tag = tag;
            }
        }
        applicationAdditionalSelectors.push.apply(applicationAdditionalSelectors, parsed);
        mergeCssSelectors();
    }
    return changed;
}
exports.addTaggedAdditionalCSS = addTaggedAdditionalCSS;
var onCssChanged = profiling_1.profile("\"style-scope\".onCssChanged", function (args) {
    if (args.cssText) {
        var parsed = CSSSource.fromSource(args.cssText, applicationKeyframes, args.cssFile).selectors;
        if (parsed) {
            applicationAdditionalSelectors.push.apply(applicationAdditionalSelectors, parsed);
            mergeCssSelectors();
        }
    }
    else if (args.cssFile) {
        loadCss(args.cssFile);
    }
});
function onLiveSync(args) {
    loadCss(applicationCommon.getCssFileName());
}
var loadCss = profiling_1.profile("\"style-scope\".loadCss", function (cssFile) {
    if (!cssFile) {
        return undefined;
    }
    var result = CSSSource.fromURI(cssFile, applicationKeyframes).selectors;
    if (result.length > 0) {
        applicationSelectors = result;
        mergeCssSelectors();
    }
});
applicationCommon.on("cssChanged", onCssChanged);
applicationCommon.on("livesync", onLiveSync);
exports.loadAppCSS = profiling_1.profile("\"style-scope\".loadAppCSS", function (args) {
    loadCss(args.cssFile);
    applicationCommon.off("loadAppCss", exports.loadAppCSS);
});
if (applicationCommon.hasLaunched()) {
    exports.loadAppCSS({ eventName: "loadAppCss", object: applicationCommon, cssFile: applicationCommon.getCssFileName() });
}
else {
    applicationCommon.on("loadAppCss", exports.loadAppCSS);
}
var CssState = (function () {
    function CssState(view) {
        var _this = this;
        this.view = view;
        this._onDynamicStateChangeHandler = function () { return _this.updateDynamicState(); };
    }
    CssState.prototype.onChange = function () {
        if (this.view && this.view.isLoaded) {
            this.unsubscribeFromDynamicUpdates();
            this.updateMatch();
            this.subscribeForDynamicUpdates();
            this.updateDynamicState();
        }
        else {
            this._matchInvalid = true;
        }
    };
    CssState.prototype.isSelectorsLatestVersionApplied = function () {
        return this.view._styleScope._getSelectorsVersion() === this._appliedSelectorsVersion;
    };
    CssState.prototype.onLoaded = function () {
        if (this._matchInvalid) {
            this.updateMatch();
        }
        this.subscribeForDynamicUpdates();
        this.updateDynamicState();
    };
    CssState.prototype.onUnloaded = function () {
        this.unsubscribeFromDynamicUpdates();
    };
    CssState.prototype.updateMatch = function () {
        if (this.view._styleScope) {
            this._appliedSelectorsVersion = this.view._styleScope._getSelectorsVersion();
            this._match = this.view._styleScope.matchSelectors(this.view);
        }
        else {
            this._match = CssState.emptyMatch;
        }
        this._matchInvalid = false;
    };
    CssState.prototype.updateDynamicState = function () {
        var _this = this;
        var matchingSelectors = this._match.selectors.filter(function (sel) { return sel.dynamic ? sel.match(_this.view) : true; });
        this.view._batchUpdate(function () {
            _this.stopKeyframeAnimations();
            _this.setPropertyValues(matchingSelectors);
            _this.playKeyframeAnimations(matchingSelectors);
        });
    };
    CssState.prototype.playKeyframeAnimations = function (matchingSelectors) {
        var _this = this;
        var animations = [];
        matchingSelectors.forEach(function (selector) {
            var ruleAnimations = selector.ruleset[animationsSymbol];
            if (ruleAnimations) {
                ensureKeyframeAnimationModule();
                for (var _i = 0, ruleAnimations_1 = ruleAnimations; _i < ruleAnimations_1.length; _i++) {
                    var animationInfo = ruleAnimations_1[_i];
                    var animation = keyframeAnimationModule.KeyframeAnimation.keyframeAnimationFromInfo(animationInfo);
                    if (animation) {
                        animations.push(animation);
                    }
                }
            }
        });
        if (this._playsKeyframeAnimations = animations.length > 0) {
            animations.map(function (animation) { return animation.play(_this.view); });
            Object.freeze(animations);
            this._appliedAnimations = animations;
        }
    };
    CssState.prototype.stopKeyframeAnimations = function () {
        if (!this._playsKeyframeAnimations) {
            return;
        }
        this._appliedAnimations
            .filter(function (animation) { return animation.isPlaying; })
            .forEach(function (animation) { return animation.cancel(); });
        this._appliedAnimations = CssState.emptyAnimationArray;
        this.view.style["keyframe:rotate"] = properties_1.unsetValue;
        this.view.style["keyframe:scaleX"] = properties_1.unsetValue;
        this.view.style["keyframe:scaleY"] = properties_1.unsetValue;
        this.view.style["keyframe:translateX"] = properties_1.unsetValue;
        this.view.style["keyframe:translateY"] = properties_1.unsetValue;
        this.view.style["keyframe:backgroundColor"] = properties_1.unsetValue;
        this.view.style["keyframe:opacity"] = properties_1.unsetValue;
        this._playsKeyframeAnimations = false;
    };
    CssState.prototype.setPropertyValues = function (matchingSelectors) {
        var newPropertyValues = new this.view.style.PropertyBag();
        matchingSelectors.forEach(function (selector) {
            return selector.ruleset.declarations.forEach(function (declaration) {
                return newPropertyValues[declaration.property] = declaration.value;
            });
        });
        Object.freeze(newPropertyValues);
        var oldProperties = this._appliedPropertyValues;
        for (var key in oldProperties) {
            if (!(key in newPropertyValues)) {
                if (key in this.view.style) {
                    this.view.style["css:" + key] = properties_1.unsetValue;
                }
                else {
                }
            }
        }
        for (var property in newPropertyValues) {
            if (oldProperties && property in oldProperties && oldProperties[property] === newPropertyValues[property]) {
                continue;
            }
            var value = newPropertyValues[property];
            try {
                if (property in this.view.style) {
                    this.view.style["css:" + property] = value;
                }
                else {
                    var camelCasedProperty = property.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
                    this.view[camelCasedProperty] = value;
                }
            }
            catch (e) {
                trace_1.write("Failed to apply property [" + property + "] with value [" + value + "] to " + this.view + ". " + e, trace_1.categories.Error, trace_1.messageType.error);
            }
        }
        this._appliedPropertyValues = newPropertyValues;
    };
    CssState.prototype.subscribeForDynamicUpdates = function () {
        var _this = this;
        var changeMap = this._match.changeMap;
        changeMap.forEach(function (changes, view) {
            if (changes.attributes) {
                changes.attributes.forEach(function (attribute) {
                    view.addEventListener(attribute + "Change", _this._onDynamicStateChangeHandler);
                });
            }
            if (changes.pseudoClasses) {
                changes.pseudoClasses.forEach(function (pseudoClass) {
                    var eventName = ":" + pseudoClass;
                    view.addEventListener(":" + pseudoClass, _this._onDynamicStateChangeHandler);
                    if (view[eventName]) {
                        view[eventName](+1);
                    }
                });
            }
        });
        this._appliedChangeMap = changeMap;
    };
    CssState.prototype.unsubscribeFromDynamicUpdates = function () {
        var _this = this;
        this._appliedChangeMap.forEach(function (changes, view) {
            if (changes.attributes) {
                changes.attributes.forEach(function (attribute) {
                    view.removeEventListener(attribute + "Change", _this._onDynamicStateChangeHandler);
                });
            }
            if (changes.pseudoClasses) {
                changes.pseudoClasses.forEach(function (pseudoClass) {
                    var eventName = ":" + pseudoClass;
                    view.removeEventListener(eventName, _this._onDynamicStateChangeHandler);
                    if (view[eventName]) {
                        view[eventName](-1);
                    }
                });
            }
        });
        this._appliedChangeMap = CssState.emptyChangeMap;
    };
    CssState.prototype.toString = function () {
        return this.view + "._cssState";
    };
    CssState.emptyChangeMap = Object.freeze(new Map());
    CssState.emptyPropertyBag = Object.freeze({});
    CssState.emptyAnimationArray = Object.freeze([]);
    CssState.emptyMatch = { selectors: [], changeMap: new Map() };
    __decorate([
        profiling_1.profile
    ], CssState.prototype, "updateMatch", null);
    __decorate([
        profiling_1.profile
    ], CssState.prototype, "updateDynamicState", null);
    return CssState;
}());
exports.CssState = CssState;
CssState.prototype._appliedChangeMap = CssState.emptyChangeMap;
CssState.prototype._appliedPropertyValues = CssState.emptyPropertyBag;
CssState.prototype._appliedAnimations = CssState.emptyAnimationArray;
CssState.prototype._matchInvalid = true;
var StyleScope = (function () {
    function StyleScope() {
        this._css = "";
        this._localCssSelectors = [];
        this._localCssSelectorVersion = 0;
        this._localCssSelectorsAppliedVersion = 0;
        this._applicationCssSelectorsAppliedVersion = 0;
        this._keyframes = new Map();
    }
    Object.defineProperty(StyleScope.prototype, "css", {
        get: function () {
            return this._css;
        },
        set: function (value) {
            this.setCss(value);
        },
        enumerable: true,
        configurable: true
    });
    StyleScope.prototype.addCss = function (cssString, cssFileName) {
        this.appendCss(cssString, cssFileName);
    };
    StyleScope.prototype.addCssFile = function (cssFileName) {
        this.appendCss(null, cssFileName);
    };
    StyleScope.prototype.changeCssFile = function (cssFileName) {
        if (!cssFileName) {
            return;
        }
        var cssSelectors = CSSSource.fromURI(cssFileName, this._keyframes);
        this._css = cssSelectors.source;
        this._localCssSelectors = cssSelectors.selectors;
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    };
    StyleScope.prototype.setCss = function (cssString, cssFileName) {
        this._css = cssString;
        var cssFile = CSSSource.fromSource(cssString, this._keyframes, cssFileName);
        this._localCssSelectors = cssFile.selectors;
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    };
    StyleScope.prototype.appendCss = function (cssString, cssFileName) {
        if (!cssString && !cssFileName) {
            return;
        }
        var parsedCssSelectors = cssString ? CSSSource.fromSource(cssString, this._keyframes, cssFileName) : CSSSource.fromURI(cssFileName, this._keyframes);
        this._css = this._css + parsedCssSelectors.source;
        this._localCssSelectors.push.apply(this._localCssSelectors, parsedCssSelectors.selectors);
        this._localCssSelectorVersion++;
        this.ensureSelectors();
    };
    StyleScope.prototype.getKeyframeAnimationWithName = function (animationName) {
        var cssKeyframes = this._keyframes[animationName];
        if (!cssKeyframes) {
            return;
        }
        ensureKeyframeAnimationModule();
        var animation = new keyframeAnimationModule.KeyframeAnimationInfo();
        ensureCssAnimationParserModule();
        animation.keyframes = cssAnimationParserModule
            .CssAnimationParser.keyframesArrayFromCSS(cssKeyframes.keyframes);
        return animation;
    };
    StyleScope.prototype.ensureSelectors = function () {
        if (!this.isApplicationCssSelectorsLatestVersionApplied() ||
            !this.isLocalCssSelectorsLatestVersionApplied() ||
            !this._mergedCssSelectors) {
            this._createSelectors();
        }
        return this._getSelectorsVersion();
    };
    StyleScope.prototype.isApplicationCssSelectorsLatestVersionApplied = function () {
        return this._applicationCssSelectorsAppliedVersion === applicationCssSelectorVersion;
    };
    StyleScope.prototype.isLocalCssSelectorsLatestVersionApplied = function () {
        return this._localCssSelectorsAppliedVersion === this._localCssSelectorVersion;
    };
    StyleScope.prototype._createSelectors = function () {
        var toMerge = [];
        toMerge.push(applicationCssSelectors);
        this._applicationCssSelectorsAppliedVersion = applicationCssSelectorVersion;
        toMerge.push(this._localCssSelectors);
        this._localCssSelectorsAppliedVersion = this._localCssSelectorVersion;
        for (var keyframe in applicationKeyframes) {
            this._keyframes[keyframe] = applicationKeyframes[keyframe];
        }
        if (toMerge.length > 0) {
            this._mergedCssSelectors = toMerge.filter(function (m) { return !!m; }).reduce(function (merged, next) { return merged.concat(next); }, []);
            this._applyKeyframesOnSelectors();
            this._selectors = new css_selector_1.SelectorsMap(this._mergedCssSelectors);
        }
    };
    StyleScope.prototype.matchSelectors = function (view) {
        this.ensureSelectors();
        return this._selectors.query(view);
    };
    StyleScope.prototype.query = function (node) {
        this.ensureSelectors();
        return this._selectors.query(node).selectors;
    };
    StyleScope.prototype._getSelectorsVersion = function () {
        return 100000 * this._applicationCssSelectorsAppliedVersion + this._localCssSelectorsAppliedVersion;
    };
    StyleScope.prototype._applyKeyframesOnSelectors = function () {
        for (var i = this._mergedCssSelectors.length - 1; i >= 0; i--) {
            var ruleset = this._mergedCssSelectors[i];
            var animations = ruleset[animationsSymbol];
            if (animations !== undefined && animations.length) {
                ensureCssAnimationParserModule();
                for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                    var animation = animations_1[_i];
                    var cssKeyframe = this._keyframes[animation.name];
                    if (cssKeyframe !== undefined) {
                        animation.keyframes = cssAnimationParserModule
                            .CssAnimationParser.keyframesArrayFromCSS(cssKeyframe.keyframes);
                    }
                }
            }
        }
    };
    StyleScope.prototype.getAnimations = function (ruleset) {
        return ruleset[animationsSymbol];
    };
    __decorate([
        profiling_1.profile
    ], StyleScope.prototype, "changeCssFile", null);
    __decorate([
        profiling_1.profile
    ], StyleScope.prototype, "setCss", null);
    __decorate([
        profiling_1.profile
    ], StyleScope.prototype, "appendCss", null);
    __decorate([
        profiling_1.profile
    ], StyleScope.prototype, "_createSelectors", null);
    __decorate([
        profiling_1.profile
    ], StyleScope.prototype, "matchSelectors", null);
    return StyleScope;
}());
exports.StyleScope = StyleScope;
function resolveFileNameFromUrl(url, appDirectory, fileExists, importSource) {
    var fileName = typeof url === "string" ? url.trim() : "";
    if (fileName.indexOf("~/") === 0) {
        fileName = fileName.replace("~/", "");
    }
    var isAbsolutePath = fileName.indexOf("/") === 0;
    var absolutePath = isAbsolutePath ? fileName : file_system_1.path.join(appDirectory, fileName);
    if (fileExists(absolutePath)) {
        return absolutePath;
    }
    if (!isAbsolutePath) {
        if (fileName[0] === "~" && fileName[1] !== "/" && fileName[1] !== "\"") {
            fileName = fileName.substr(1);
        }
        if (importSource) {
            var importFile = resolveFilePathFromImport(importSource, fileName);
            if (fileExists(importFile)) {
                return importFile;
            }
        }
        var external_1 = file_system_1.path.join(appDirectory, "tns_modules", fileName);
        if (fileExists(external_1)) {
            return external_1;
        }
    }
    return null;
}
exports.resolveFileNameFromUrl = resolveFileNameFromUrl;
function resolveFilePathFromImport(importSource, fileName) {
    var importSourceParts = importSource.split(file_system_1.path.separator);
    var fileNameParts = fileName.split(file_system_1.path.separator)
        .filter(function (p) { return !isCurrentDirectory(p); });
    importSourceParts.pop();
    fileNameParts.forEach(function (p) { return isParentDirectory(p) ? importSourceParts.pop() : importSourceParts.push(p); });
    return importSourceParts.join(file_system_1.path.separator);
}
exports.applyInlineStyle = profiling_1.profile(function applyInlineStyle(view, styleStr) {
    var localStyle = "local { " + styleStr + " }";
    var inlineRuleSet = CSSSource.fromSource(localStyle, new Map()).selectors;
    var style = view.style;
    inlineRuleSet[0].declarations.forEach(function (d) {
        var name = d.property;
        try {
            if (name in style) {
                style[name] = d.value;
            }
            else {
                view[name] = d.value;
            }
        }
        catch (e) {
            trace_1.write("Failed to apply property [" + d.property + "] with value [" + d.value + "] to " + view + ". " + e, trace_1.categories.Error, trace_1.messageType.error);
        }
    });
});
function isCurrentDirectory(uriPart) {
    return uriPart === ".";
}
function isParentDirectory(uriPart) {
    return uriPart === "..";
}
function isKeyframe(node) {
    return node.type === "keyframes";
}
//# sourceMappingURL=style-scope.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/styling/style/style.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = __webpack_require__("../node_modules/tns-core-modules/data/observable/observable.js");
var Style = (function (_super) {
    __extends(Style, _super);
    function Style(view) {
        var _this = _super.call(this) || this;
        _this.view = view;
        return _this;
    }
    Style.prototype.toString = function () {
        return this.view + ".style";
    };
    return Style;
}(observable_1.Observable));
exports.Style = Style;
Style.prototype.PropertyBag = (function () {
    function class_1() {
    }
    return class_1;
}());
//# sourceMappingURL=style.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/text-base/text-base-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var view_1 = __webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js");
var formatted_string_1 = __webpack_require__("../node_modules/tns-core-modules/text/formatted-string.js");
exports.FormattedString = formatted_string_1.FormattedString;
exports.Span = formatted_string_1.Span;
__export(__webpack_require__("../node_modules/tns-core-modules/ui/core/view/view.js"));
var CHILD_SPAN = "Span";
var CHILD_FORMATTED_TEXT = "formattedText";
var CHILD_FORMATTED_STRING = "FormattedString";
var TextBaseCommon = (function (_super) {
    __extends(TextBaseCommon, _super);
    function TextBaseCommon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TextBaseCommon.prototype, "nativeTextViewProtected", {
        get: function () {
            return this.nativeViewProtected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "fontFamily", {
        get: function () {
            return this.style.fontFamily;
        },
        set: function (value) {
            this.style.fontFamily = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "fontSize", {
        get: function () {
            return this.style.fontSize;
        },
        set: function (value) {
            this.style.fontSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "fontStyle", {
        get: function () {
            return this.style.fontStyle;
        },
        set: function (value) {
            this.style.fontStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "fontWeight", {
        get: function () {
            return this.style.fontWeight;
        },
        set: function (value) {
            this.style.fontWeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "letterSpacing", {
        get: function () {
            return this.style.letterSpacing;
        },
        set: function (value) {
            this.style.letterSpacing = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "lineHeight", {
        get: function () {
            return this.style.lineHeight;
        },
        set: function (value) {
            this.style.lineHeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "textAlignment", {
        get: function () {
            return this.style.textAlignment;
        },
        set: function (value) {
            this.style.textAlignment = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "textDecoration", {
        get: function () {
            return this.style.textDecoration;
        },
        set: function (value) {
            this.style.textDecoration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "textTransform", {
        get: function () {
            return this.style.textTransform;
        },
        set: function (value) {
            this.style.textTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "whiteSpace", {
        get: function () {
            return this.style.whiteSpace;
        },
        set: function (value) {
            this.style.whiteSpace = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "padding", {
        get: function () {
            return this.style.padding;
        },
        set: function (value) {
            this.style.padding = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "paddingTop", {
        get: function () {
            return this.style.paddingTop;
        },
        set: function (value) {
            this.style.paddingTop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "paddingRight", {
        get: function () {
            return this.style.paddingRight;
        },
        set: function (value) {
            this.style.paddingRight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "paddingBottom", {
        get: function () {
            return this.style.paddingBottom;
        },
        set: function (value) {
            this.style.paddingBottom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBaseCommon.prototype, "paddingLeft", {
        get: function () {
            return this.style.paddingLeft;
        },
        set: function (value) {
            this.style.paddingLeft = value;
        },
        enumerable: true,
        configurable: true
    });
    TextBaseCommon.prototype._onFormattedTextContentsChanged = function (data) {
        if (this.nativeViewProtected) {
            this[exports.formattedTextProperty.setNative](data.value);
        }
    };
    TextBaseCommon.prototype._addChildFromBuilder = function (name, value) {
        if (name === CHILD_SPAN) {
            if (!this.formattedText) {
                var formattedText = new formatted_string_1.FormattedString();
                formattedText.spans.push(value);
                this.formattedText = formattedText;
            }
            else {
                this.formattedText.spans.push(value);
            }
        }
        else if (name === CHILD_FORMATTED_TEXT || name === CHILD_FORMATTED_STRING) {
            this.formattedText = value;
        }
    };
    TextBaseCommon.prototype._requestLayoutOnTextChanged = function () {
        this.requestLayout();
    };
    TextBaseCommon.prototype.eachChild = function (callback) {
        var text = this.formattedText;
        if (text) {
            callback(text);
        }
    };
    TextBaseCommon.prototype._setNativeText = function (reset) {
        if (reset === void 0) { reset = false; }
    };
    return TextBaseCommon;
}(view_1.View));
exports.TextBaseCommon = TextBaseCommon;
TextBaseCommon.prototype._isSingleLine = false;
function isBold(fontWeight) {
    return fontWeight === "bold" || fontWeight === "700" || fontWeight === "800" || fontWeight === "900";
}
exports.isBold = isBold;
exports.textProperty = new view_1.Property({ name: "text", defaultValue: "", affectsLayout: view_1.isAndroid });
exports.textProperty.register(TextBaseCommon);
exports.formattedTextProperty = new view_1.Property({ name: "formattedText", affectsLayout: true, valueChanged: onFormattedTextPropertyChanged });
exports.formattedTextProperty.register(TextBaseCommon);
function onFormattedTextPropertyChanged(textBase, oldValue, newValue) {
    if (oldValue) {
        oldValue.off(view_1.Observable.propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
        textBase._removeView(oldValue);
    }
    if (newValue) {
        var oldParent = newValue.parent;
        if (oldParent) {
            oldParent._removeView(newValue);
        }
        textBase._addView(newValue);
        newValue.on(view_1.Observable.propertyChangeEvent, textBase._onFormattedTextContentsChanged, textBase);
    }
}
var textAlignmentConverter = view_1.makeParser(view_1.makeValidator("initial", "left", "center", "right"));
exports.textAlignmentProperty = new view_1.InheritedCssProperty({ name: "textAlignment", cssName: "text-align", defaultValue: "initial", valueConverter: textAlignmentConverter });
exports.textAlignmentProperty.register(view_1.Style);
var textTransformConverter = view_1.makeParser(view_1.makeValidator("initial", "none", "capitalize", "uppercase", "lowercase"));
exports.textTransformProperty = new view_1.CssProperty({ name: "textTransform", cssName: "text-transform", defaultValue: "initial", valueConverter: textTransformConverter });
exports.textTransformProperty.register(view_1.Style);
var whiteSpaceConverter = view_1.makeParser(view_1.makeValidator("initial", "normal", "nowrap"));
exports.whiteSpaceProperty = new view_1.CssProperty({ name: "whiteSpace", cssName: "white-space", defaultValue: "initial", affectsLayout: view_1.isIOS, valueConverter: whiteSpaceConverter });
exports.whiteSpaceProperty.register(view_1.Style);
var textDecorationConverter = view_1.makeParser(view_1.makeValidator("none", "underline", "line-through", "underline line-through"));
exports.textDecorationProperty = new view_1.CssProperty({ name: "textDecoration", cssName: "text-decoration", defaultValue: "none", valueConverter: textDecorationConverter });
exports.textDecorationProperty.register(view_1.Style);
exports.letterSpacingProperty = new view_1.CssProperty({ name: "letterSpacing", cssName: "letter-spacing", defaultValue: 0, affectsLayout: view_1.isIOS, valueConverter: function (v) { return parseFloat(v); } });
exports.letterSpacingProperty.register(view_1.Style);
exports.lineHeightProperty = new view_1.CssProperty({ name: "lineHeight", cssName: "line-height", affectsLayout: view_1.isIOS, valueConverter: function (v) { return parseFloat(v); } });
exports.lineHeightProperty.register(view_1.Style);
exports.resetSymbol = Symbol("textPropertyDefault");
//# sourceMappingURL=text-base-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/text-base/text-base.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var font_1 = __webpack_require__("../node_modules/tns-core-modules/ui/styling/font.js");
var text_base_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base-common.js");
var types_1 = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/text-base/text-base-common.js"));
var TextBase = (function (_super) {
    __extends(TextBase, _super);
    function TextBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextBase.prototype[text_base_common_1.textProperty.getDefault] = function () {
        return text_base_common_1.resetSymbol;
    };
    TextBase.prototype[text_base_common_1.textProperty.setNative] = function (value) {
        var reset = value === text_base_common_1.resetSymbol;
        if (!reset && this.formattedText) {
            return;
        }
        this._setNativeText(reset);
        this._requestLayoutOnTextChanged();
    };
    TextBase.prototype[text_base_common_1.formattedTextProperty.setNative] = function (value) {
        this._setNativeText();
        text_base_common_1.textProperty.nativeValueChange(this, !value ? "" : value.toString());
        this._requestLayoutOnTextChanged();
    };
    TextBase.prototype[text_base_common_1.colorProperty.getDefault] = function () {
        var nativeView = this.nativeTextViewProtected;
        if (nativeView instanceof UIButton) {
            return nativeView.titleColorForState(0);
        }
        else {
            return nativeView.textColor;
        }
    };
    TextBase.prototype[text_base_common_1.colorProperty.setNative] = function (value) {
        var color = value instanceof text_base_common_1.Color ? value.ios : value;
        var nativeView = this.nativeTextViewProtected;
        if (nativeView instanceof UIButton) {
            nativeView.setTitleColorForState(color, 0);
            nativeView.titleLabel.textColor = color;
        }
        else {
            nativeView.textColor = color;
        }
    };
    TextBase.prototype[text_base_common_1.fontInternalProperty.getDefault] = function () {
        var nativeView = this.nativeTextViewProtected;
        nativeView = nativeView instanceof UIButton ? nativeView.titleLabel : nativeView;
        return nativeView.font;
    };
    TextBase.prototype[text_base_common_1.fontInternalProperty.setNative] = function (value) {
        if (!(value instanceof font_1.Font) || !this.formattedText) {
            var nativeView = this.nativeTextViewProtected;
            nativeView = nativeView instanceof UIButton ? nativeView.titleLabel : nativeView;
            var font = value instanceof font_1.Font ? value.getUIFont(nativeView.font) : value;
            nativeView.font = font;
        }
    };
    TextBase.prototype[text_base_common_1.textAlignmentProperty.setNative] = function (value) {
        var nativeView = this.nativeTextViewProtected;
        switch (value) {
            case "initial":
            case "left":
                nativeView.textAlignment = 0;
                break;
            case "center":
                nativeView.textAlignment = 1;
                break;
            case "right":
                nativeView.textAlignment = 2;
                break;
        }
    };
    TextBase.prototype[text_base_common_1.textDecorationProperty.setNative] = function (value) {
        this._setNativeText();
    };
    TextBase.prototype[text_base_common_1.textTransformProperty.setNative] = function (value) {
        this._setNativeText();
    };
    TextBase.prototype[text_base_common_1.letterSpacingProperty.setNative] = function (value) {
        this._setNativeText();
    };
    TextBase.prototype[text_base_common_1.lineHeightProperty.setNative] = function (value) {
        this._setNativeText();
    };
    TextBase.prototype._setNativeText = function (reset) {
        if (reset === void 0) { reset = false; }
        if (reset) {
            var nativeView = this.nativeTextViewProtected;
            if (nativeView instanceof UIButton) {
                nativeView.setAttributedTitleForState(null, 0);
                nativeView.setTitleForState(null, 0);
            }
            else {
                nativeView.attributedText = null;
                nativeView.text = null;
            }
            return;
        }
        if (this.formattedText) {
            this.setFormattedTextDecorationAndTransform();
        }
        else {
            this.setTextDecorationAndTransform();
        }
    };
    TextBase.prototype.setFormattedTextDecorationAndTransform = function () {
        var attrText = this.createNSMutableAttributedString(this.formattedText);
        if (this.letterSpacing !== 0) {
            attrText.addAttributeValueRange(NSKernAttributeName, this.letterSpacing * this.nativeTextViewProtected.font.pointSize, { location: 0, length: attrText.length });
        }
        if (this.style.lineHeight) {
            var paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.lineSpacing = this.lineHeight;
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            if (this.nativeTextViewProtected instanceof UILabel) {
                paragraphStyle.lineBreakMode = this.nativeTextViewProtected.lineBreakMode;
            }
            attrText.addAttributeValueRange(NSParagraphStyleAttributeName, paragraphStyle, { location: 0, length: attrText.length });
        }
        else if (this.nativeTextViewProtected instanceof UITextView) {
            var paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            attrText.addAttributeValueRange(NSParagraphStyleAttributeName, paragraphStyle, { location: 0, length: attrText.length });
        }
        if (this.nativeTextViewProtected instanceof UIButton) {
            this.nativeTextViewProtected.setAttributedTitleForState(attrText, 0);
        }
        else {
            this.nativeTextViewProtected.attributedText = attrText;
        }
    };
    TextBase.prototype.setTextDecorationAndTransform = function () {
        var style = this.style;
        var dict = new Map();
        switch (style.textDecoration) {
            case "none":
                break;
            case "underline":
                dict.set(NSUnderlineStyleAttributeName, 1);
                break;
            case "line-through":
                dict.set(NSStrikethroughStyleAttributeName, 1);
                break;
            case "underline line-through":
                dict.set(NSUnderlineStyleAttributeName, 1);
                dict.set(NSStrikethroughStyleAttributeName, 1);
                break;
            default:
                throw new Error("Invalid text decoration value: " + style.textDecoration + ". Valid values are: 'none', 'underline', 'line-through', 'underline line-through'.");
        }
        if (style.letterSpacing !== 0) {
            dict.set(NSKernAttributeName, style.letterSpacing * this.nativeTextViewProtected.font.pointSize);
        }
        var isTextView = this.nativeTextViewProtected instanceof UITextView;
        if (style.lineHeight) {
            var paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.lineSpacing = style.lineHeight;
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            if (this.nativeTextViewProtected instanceof UILabel) {
                paragraphStyle.lineBreakMode = this.nativeTextViewProtected.lineBreakMode;
            }
            dict.set(NSParagraphStyleAttributeName, paragraphStyle);
        }
        else if (isTextView) {
            var paragraphStyle = NSMutableParagraphStyle.alloc().init();
            paragraphStyle.alignment = this.nativeTextViewProtected.textAlignment;
            dict.set(NSParagraphStyleAttributeName, paragraphStyle);
        }
        if (style.color && (dict.size > 0 || isTextView)) {
            dict.set(NSForegroundColorAttributeName, style.color.ios);
        }
        var text = this.text;
        var string = (text === undefined || text === null) ? "" : text.toString();
        var source = getTransformedText(string, this.textTransform);
        if (dict.size > 0 || isTextView) {
            if (isTextView) {
                dict.set(NSFontAttributeName, this.nativeTextViewProtected.font);
            }
            var result = NSMutableAttributedString.alloc().initWithString(source);
            result.setAttributesRange(dict, { location: 0, length: source.length });
            if (this.nativeTextViewProtected instanceof UIButton) {
                this.nativeTextViewProtected.setAttributedTitleForState(result, 0);
            }
            else {
                this.nativeTextViewProtected.attributedText = result;
            }
        }
        else {
            if (this.nativeTextViewProtected instanceof UIButton) {
                this.nativeTextViewProtected.setAttributedTitleForState(null, 0);
                this.nativeTextViewProtected.setTitleForState(source, 0);
            }
            else {
                this.nativeTextViewProtected.attributedText = undefined;
                this.nativeTextViewProtected.text = source;
            }
        }
    };
    TextBase.prototype.createNSMutableAttributedString = function (formattedString) {
        var mas = NSMutableAttributedString.alloc().init();
        if (formattedString && formattedString.parent) {
            for (var i = 0, spanStart = 0, length_1 = formattedString.spans.length; i < length_1; i++) {
                var span = formattedString.spans.getItem(i);
                var text = span.text;
                var textTransform = formattedString.parent.textTransform;
                var spanText = (text === null || text === undefined) ? "" : text.toString();
                if (textTransform !== "none" && textTransform !== "initial") {
                    spanText = getTransformedText(spanText, textTransform);
                }
                var nsAttributedString = this.createMutableStringForSpan(span, spanText);
                mas.insertAttributedStringAtIndex(nsAttributedString, spanStart);
                spanStart += spanText.length;
            }
        }
        return mas;
    };
    TextBase.prototype.createMutableStringForSpan = function (span, text) {
        var viewFont = this.nativeTextViewProtected.font;
        var attrDict = {};
        var style = span.style;
        var bold = text_base_common_1.isBold(style.fontWeight);
        var italic = style.fontStyle === "italic";
        var fontFamily = span.fontFamily;
        var fontSize = span.fontSize;
        if (bold || italic || fontFamily || fontSize) {
            var font = new font_1.Font(style.fontFamily, style.fontSize, style.fontStyle, style.fontWeight);
            var iosFont = font.getUIFont(viewFont);
            attrDict[NSFontAttributeName] = iosFont;
        }
        var color = span.color;
        if (color) {
            attrDict[NSForegroundColorAttributeName] = color.ios;
        }
        var backgroundColor = (style.backgroundColor
            || span.parent.backgroundColor
            || span.parent.parent.backgroundColor);
        if (backgroundColor) {
            attrDict[NSBackgroundColorAttributeName] = backgroundColor.ios;
        }
        var valueSource;
        if (text_base_common_1.textDecorationProperty.isSet(style)) {
            valueSource = style;
        }
        else if (text_base_common_1.textDecorationProperty.isSet(span.parent.style)) {
            valueSource = span.parent.style;
        }
        else if (text_base_common_1.textDecorationProperty.isSet(span.parent.parent.style)) {
            valueSource = span.parent.parent.style;
        }
        if (valueSource) {
            var textDecorations = valueSource.textDecoration;
            var underline_1 = textDecorations.indexOf("underline") !== -1;
            if (underline_1) {
                attrDict[NSUnderlineStyleAttributeName] = underline_1;
            }
            var strikethrough = textDecorations.indexOf("line-through") !== -1;
            if (strikethrough) {
                attrDict[NSStrikethroughStyleAttributeName] = strikethrough;
            }
        }
        return NSMutableAttributedString.alloc().initWithStringAttributes(text, attrDict);
    };
    return TextBase;
}(text_base_common_1.TextBaseCommon));
exports.TextBase = TextBase;
function getTransformedText(text, textTransform) {
    if (!text || !types_1.isString(text)) {
        return "";
    }
    switch (textTransform) {
        case "uppercase":
            return NSStringFromNSAttributedString(text).uppercaseString;
        case "lowercase":
            return NSStringFromNSAttributedString(text).lowercaseString;
        case "capitalize":
            return NSStringFromNSAttributedString(text).capitalizedString;
        default:
            return text;
    }
}
exports.getTransformedText = getTransformedText;
function NSStringFromNSAttributedString(source) {
    return NSString.stringWithString(source instanceof NSAttributedString && source.string || source);
}
//# sourceMappingURL=text-base.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/text-field/text-field-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var editable_text_base_1 = __webpack_require__("../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/editable-text-base/editable-text-base.js"));
var TextFieldBase = (function (_super) {
    __extends(TextFieldBase, _super);
    function TextFieldBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextFieldBase.returnPressEvent = "returnPress";
    TextFieldBase = __decorate([
        editable_text_base_1.CSSType("TextField")
    ], TextFieldBase);
    return TextFieldBase;
}(editable_text_base_1.EditableTextBase));
exports.TextFieldBase = TextFieldBase;
TextFieldBase.prototype.recycleNativeView = "auto";
exports.secureProperty = new editable_text_base_1.Property({ name: "secure", defaultValue: false, valueConverter: editable_text_base_1.booleanConverter });
exports.secureProperty.register(TextFieldBase);
//# sourceMappingURL=text-field-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/text-field/text-field.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var text_field_common_1 = __webpack_require__("../node_modules/tns-core-modules/ui/text-field/text-field-common.js");
var profiling_1 = __webpack_require__("../node_modules/tns-core-modules/profiling/profiling.js");
__export(__webpack_require__("../node_modules/tns-core-modules/ui/text-field/text-field-common.js"));
var zeroLength = {
    value: 0,
    unit: "px"
};
var UITextFieldDelegateImpl = (function (_super) {
    __extends(UITextFieldDelegateImpl, _super);
    function UITextFieldDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITextFieldDelegateImpl.initWithOwner = function (owner) {
        var delegate = UITextFieldDelegateImpl.new();
        delegate._owner = owner;
        return delegate;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldBeginEditing = function (textField) {
        this.firstEdit = true;
        var owner = this._owner.get();
        if (owner) {
            return owner.editable;
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldDidBeginEditing = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            owner.notify({ eventName: TextField.focusEvent, object: owner });
        }
    };
    UITextFieldDelegateImpl.prototype.textFieldDidEndEditing = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            if (owner.updateTextTrigger === "focusLost") {
                text_field_common_1.textProperty.nativeValueChange(owner, textField.text);
            }
            owner.dismissSoftInput();
        }
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldClear = function (textField) {
        this.firstEdit = false;
        var owner = this._owner.get();
        if (owner) {
            text_field_common_1.textProperty.nativeValueChange(owner, "");
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldReturn = function (textField) {
        var owner = this._owner.get();
        if (owner) {
            owner.dismissSoftInput();
            owner.notify({ eventName: TextField.returnPressEvent, object: owner });
        }
        return true;
    };
    UITextFieldDelegateImpl.prototype.textFieldShouldChangeCharactersInRangeReplacementString = function (textField, range, replacementString) {
        var owner = this._owner.get();
        if (owner) {
            var delta = replacementString.length - range.length;
            if (delta > 0) {
                if (textField.text.length + delta > owner.maxLength) {
                    return false;
                }
            }
            if (owner.updateTextTrigger === "textChanged") {
                if (textField.secureTextEntry && this.firstEdit) {
                    text_field_common_1.textProperty.nativeValueChange(owner, replacementString);
                }
                else {
                    if (range.location <= textField.text.length) {
                        var newText = NSString.stringWithString(textField.text).stringByReplacingCharactersInRangeWithString(range, replacementString);
                        text_field_common_1.textProperty.nativeValueChange(owner, newText);
                    }
                }
            }
            if (owner.formattedText) {
                text_field_common_1._updateCharactersInRangeReplacementString(owner.formattedText, range.location, range.length, replacementString);
            }
        }
        this.firstEdit = false;
        return true;
    };
    UITextFieldDelegateImpl.ObjCProtocols = [UITextFieldDelegate];
    return UITextFieldDelegateImpl;
}(NSObject));
var UITextFieldImpl = (function (_super) {
    __extends(UITextFieldImpl, _super);
    function UITextFieldImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UITextFieldImpl.initWithOwner = function (owner) {
        var handler = UITextFieldImpl.new();
        handler._owner = owner;
        return handler;
    };
    UITextFieldImpl.prototype._getTextRectForBounds = function (bounds) {
        var owner = this._owner ? this._owner.get() : null;
        if (!owner) {
            return bounds;
        }
        var size = bounds.size;
        var x = text_field_common_1.layout.toDeviceIndependentPixels(owner.effectiveBorderLeftWidth + owner.effectivePaddingLeft);
        var y = text_field_common_1.layout.toDeviceIndependentPixels(owner.effectiveBorderTopWidth + owner.effectivePaddingTop);
        var width = text_field_common_1.layout.toDeviceIndependentPixels(text_field_common_1.layout.toDevicePixels(size.width) - (owner.effectiveBorderLeftWidth + owner.effectivePaddingLeft + owner.effectivePaddingRight + owner.effectiveBorderRightWidth));
        var height = text_field_common_1.layout.toDeviceIndependentPixels(text_field_common_1.layout.toDevicePixels(size.height) - (owner.effectiveBorderTopWidth + owner.effectivePaddingTop + owner.effectivePaddingBottom + owner.effectiveBorderBottomWidth));
        return CGRectMake(x, y, width, height);
    };
    UITextFieldImpl.prototype.textRectForBounds = function (bounds) {
        return this._getTextRectForBounds(bounds);
    };
    UITextFieldImpl.prototype.editingRectForBounds = function (bounds) {
        return this._getTextRectForBounds(bounds);
    };
    return UITextFieldImpl;
}(UITextField));
var TextField = (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextField.prototype.createNativeView = function () {
        return UITextFieldImpl.initWithOwner(new WeakRef(this));
    };
    TextField.prototype.initNativeView = function () {
        _super.prototype.initNativeView.call(this);
        this._delegate = UITextFieldDelegateImpl.initWithOwner(new WeakRef(this));
    };
    TextField.prototype.disposeNativeView = function () {
        this._delegate = null;
        _super.prototype.disposeNativeView.call(this);
    };
    TextField.prototype.onLoaded = function () {
        _super.prototype.onLoaded.call(this);
        this.ios.delegate = this._delegate;
    };
    TextField.prototype.onUnloaded = function () {
        this.ios.delegate = null;
        _super.prototype.onUnloaded.call(this);
    };
    Object.defineProperty(TextField.prototype, "ios", {
        get: function () {
            return this.nativeViewProtected;
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype[text_field_common_1.hintProperty.getDefault] = function () {
        return this.nativeTextViewProtected.placeholder;
    };
    TextField.prototype[text_field_common_1.hintProperty.setNative] = function (value) {
        this._updateAttributedPlaceholder();
    };
    TextField.prototype[text_field_common_1.secureProperty.getDefault] = function () {
        return this.nativeTextViewProtected.secureTextEntry;
    };
    TextField.prototype[text_field_common_1.secureProperty.setNative] = function (value) {
        this.nativeTextViewProtected.secureTextEntry = value;
    };
    TextField.prototype[text_field_common_1.colorProperty.getDefault] = function () {
        return {
            textColor: this.nativeTextViewProtected.textColor,
            tintColor: this.nativeTextViewProtected.tintColor
        };
    };
    TextField.prototype[text_field_common_1.colorProperty.setNative] = function (value) {
        if (value instanceof text_field_common_1.Color) {
            var color = value instanceof text_field_common_1.Color ? value.ios : value;
            this.nativeTextViewProtected.textColor = color;
            this.nativeTextViewProtected.tintColor = color;
        }
        else {
            this.nativeTextViewProtected.textColor = value.textColor;
            this.nativeTextViewProtected.tintColor = value.tintColor;
        }
    };
    TextField.prototype[text_field_common_1.placeholderColorProperty.getDefault] = function () {
        return null;
    };
    TextField.prototype[text_field_common_1.placeholderColorProperty.setNative] = function (value) {
        this._updateAttributedPlaceholder();
    };
    TextField.prototype._updateAttributedPlaceholder = function () {
        var stringValue = this.hint;
        if (stringValue === null || stringValue === void 0) {
            stringValue = "";
        }
        else {
            stringValue = stringValue + "";
        }
        if (stringValue === "") {
            stringValue = " ";
        }
        var attributes = {};
        if (this.style.placeholderColor) {
            attributes[NSForegroundColorAttributeName] = this.style.placeholderColor.ios;
        }
        var attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(stringValue, attributes);
        this.nativeTextViewProtected.attributedPlaceholder = attributedPlaceholder;
    };
    TextField.prototype[text_field_common_1.paddingTopProperty.getDefault] = function () {
        return zeroLength;
    };
    TextField.prototype[text_field_common_1.paddingTopProperty.setNative] = function (value) {
    };
    TextField.prototype[text_field_common_1.paddingRightProperty.getDefault] = function () {
        return zeroLength;
    };
    TextField.prototype[text_field_common_1.paddingRightProperty.setNative] = function (value) {
    };
    TextField.prototype[text_field_common_1.paddingBottomProperty.getDefault] = function () {
        return zeroLength;
    };
    TextField.prototype[text_field_common_1.paddingBottomProperty.setNative] = function (value) {
    };
    TextField.prototype[text_field_common_1.paddingLeftProperty.getDefault] = function () {
        return zeroLength;
    };
    TextField.prototype[text_field_common_1.paddingLeftProperty.setNative] = function (value) {
    };
    __decorate([
        profiling_1.profile
    ], TextField.prototype, "onLoaded", null);
    return TextField;
}(text_field_common_1.TextFieldBase));
exports.TextField = TextField;
//# sourceMappingURL=text-field.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/transition/fade-transition.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var transition_1 = __webpack_require__("../node_modules/tns-core-modules/ui/transition/transition.js");
var FadeTransition = (function (_super) {
    __extends(FadeTransition, _super);
    function FadeTransition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FadeTransition.prototype.animateIOSTransition = function (containerView, fromView, toView, operation, completion) {
        var originalToViewAlpha = toView.alpha;
        var originalFromViewAlpha = fromView.alpha;
        toView.alpha = 0.0;
        fromView.alpha = 1.0;
        switch (operation) {
            case 1:
                containerView.insertSubviewAboveSubview(toView, fromView);
                break;
            case 2:
                containerView.insertSubviewBelowSubview(toView, fromView);
                break;
        }
        var duration = this.getDuration();
        var curve = this.getCurve();
        UIView.animateWithDurationAnimationsCompletion(duration, function () {
            UIView.setAnimationCurve(curve);
            toView.alpha = 1.0;
            fromView.alpha = 0.0;
        }, function (finished) {
            toView.alpha = originalToViewAlpha;
            fromView.alpha = originalFromViewAlpha;
            completion(finished);
        });
    };
    return FadeTransition;
}(transition_1.Transition));
exports.FadeTransition = FadeTransition;
//# sourceMappingURL=fade-transition.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/transition/slide-transition.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var transition_1 = __webpack_require__("../node_modules/tns-core-modules/ui/transition/transition.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
var screenWidth = platform_1.screen.mainScreen.widthDIPs;
var screenHeight = platform_1.screen.mainScreen.heightDIPs;
var leftEdge = CGAffineTransformMakeTranslation(-screenWidth, 0);
var rightEdge = CGAffineTransformMakeTranslation(screenWidth, 0);
var topEdge = CGAffineTransformMakeTranslation(0, -screenHeight);
var bottomEdge = CGAffineTransformMakeTranslation(0, screenHeight);
var SlideTransition = (function (_super) {
    __extends(SlideTransition, _super);
    function SlideTransition(direction, duration, curve) {
        var _this = _super.call(this, duration, curve) || this;
        _this._direction = direction;
        return _this;
    }
    SlideTransition.prototype.animateIOSTransition = function (containerView, fromView, toView, operation, completion) {
        var originalToViewTransform = toView.transform;
        var originalFromViewTransform = fromView.transform;
        var fromViewEndTransform;
        var toViewBeginTransform;
        var push = (operation === 1);
        switch (this._direction) {
            case "left":
                toViewBeginTransform = push ? rightEdge : leftEdge;
                fromViewEndTransform = push ? leftEdge : rightEdge;
                break;
            case "right":
                toViewBeginTransform = push ? leftEdge : rightEdge;
                fromViewEndTransform = push ? rightEdge : leftEdge;
                break;
            case "top":
                toViewBeginTransform = push ? bottomEdge : topEdge;
                fromViewEndTransform = push ? topEdge : bottomEdge;
                break;
            case "bottom":
                toViewBeginTransform = push ? topEdge : bottomEdge;
                fromViewEndTransform = push ? bottomEdge : topEdge;
                break;
        }
        toView.transform = toViewBeginTransform;
        fromView.transform = CGAffineTransformIdentity;
        switch (operation) {
            case 1:
                containerView.insertSubviewAboveSubview(toView, fromView);
                break;
            case 2:
                containerView.insertSubviewBelowSubview(toView, fromView);
                break;
        }
        var duration = this.getDuration();
        var curve = this.getCurve();
        UIView.animateWithDurationAnimationsCompletion(duration, function () {
            UIView.setAnimationCurve(curve);
            toView.transform = CGAffineTransformIdentity;
            fromView.transform = fromViewEndTransform;
        }, function (finished) {
            toView.transform = originalToViewTransform;
            fromView.transform = originalFromViewTransform;
            completion(finished);
        });
    };
    return SlideTransition;
}(transition_1.Transition));
exports.SlideTransition = SlideTransition;
//# sourceMappingURL=slide-transition.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/ui/transition/transition.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var transitionId = 0;
var Transition = (function () {
    function Transition(duration, curve) {
        if (curve === void 0) { curve = 0; }
        this._duration = duration ? (duration / 1000) : 0.35;
        this._curve = curve;
        this._id = transitionId++;
    }
    Transition.prototype.getDuration = function () {
        return this._duration;
    };
    Transition.prototype.getCurve = function () {
        return this._curve;
    };
    Transition.prototype.animateIOSTransition = function (containerView, fromView, toView, operation, completion) {
        throw new Error("Abstract method call");
    };
    Transition.prototype.createAndroidAnimator = function (transitionType) {
        throw new Error("Abstract method call");
    };
    Transition.prototype.toString = function () {
        return "Transition@" + this._id;
    };
    return Transition;
}());
exports.Transition = Transition;
//# sourceMappingURL=transition.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/debug.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var file_system_1 = __webpack_require__("../node_modules/tns-core-modules/file-system/file-system.js");
var platform_1 = __webpack_require__("../node_modules/tns-core-modules/platform/platform.js");
exports.debug = true;
var applicationRootPath;
function ensureAppRootPath() {
    if (!applicationRootPath) {
        applicationRootPath = file_system_1.knownFolders.currentApp().path;
        applicationRootPath = applicationRootPath.substr(0, applicationRootPath.length - "app/".length);
    }
}
var Source = (function () {
    function Source(uri, line, column) {
        ensureAppRootPath();
        if (uri.length > applicationRootPath.length && uri.substr(0, applicationRootPath.length) === applicationRootPath) {
            this._uri = "file://" + uri.substr(applicationRootPath.length);
        }
        else {
            this._uri = uri;
        }
        this._line = line;
        this._column = column;
    }
    Object.defineProperty(Source.prototype, "uri", {
        get: function () { return this._uri; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Source.prototype, "line", {
        get: function () { return this._line; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Source.prototype, "column", {
        get: function () { return this._column; },
        enumerable: true,
        configurable: true
    });
    Source.prototype.toString = function () {
        return this._uri + ":" + this._line + ":" + this._column;
    };
    Source.get = function (object) {
        return object[Source._source];
    };
    Source.set = function (object, src) {
        object[Source._source] = src;
    };
    Source._source = Symbol("source");
    return Source;
}());
exports.Source = Source;
var ScopeError = (function (_super) {
    __extends(ScopeError, _super);
    function ScopeError(inner, message) {
        var _this = this;
        var formattedMessage;
        if (message && inner.message) {
            formattedMessage = message + "\n > " + inner.message.replace("\n", "\n  ");
        }
        else {
            formattedMessage = message || inner.message || undefined;
        }
        _this = _super.call(this, formattedMessage) || this;
        _this.stack = platform_1.isAndroid ? "Error: " + _this.message + "\n" + inner.stack.substr(inner.stack.indexOf("\n") + 1) : inner.stack;
        _this.message = formattedMessage;
        return _this;
    }
    return ScopeError;
}(Error));
exports.ScopeError = ScopeError;
var SourceError = (function (_super) {
    __extends(SourceError, _super);
    function SourceError(child, source, message) {
        return _super.call(this, child, message ? message + " @" + source + "" : source + "") || this;
    }
    return SourceError;
}(ScopeError));
exports.SourceError = SourceError;
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/mainthread-helper.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
function dispatchToMainThread(func) {
    NSOperationQueue.mainQueue.addOperationWithBlock(func);
}
exports.dispatchToMainThread = dispatchToMainThread;
function isMainThread() {
    return NSThread.isMainThread;
}
exports.isMainThread = isMainThread;
//# sourceMappingURL=mainthread-helper.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/number-utils.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var epsilon = 1E-05;
function areClose(value1, value2) {
    return (Math.abs(value1 - value2) < epsilon);
}
exports.areClose = areClose;
function greaterThanOrClose(value1, value2) {
    return (value1 > value2) || areClose(value1, value2);
}
exports.greaterThanOrClose = greaterThanOrClose;
function greaterThan(value1, value2) {
    return (value1 > value2) && !areClose(value1, value2);
}
exports.greaterThan = greaterThan;
function lessThan(value1, value2) {
    return (value1 < value2) && !areClose(value1, value2);
}
exports.lessThan = lessThan;
function isZero(value) {
    return (Math.abs(value) < epsilon);
}
exports.isZero = isZero;
function greaterThanZero(value) {
    return value > 0;
}
exports.greaterThanZero = greaterThanZero;
function notNegative(value) {
    return value >= 0;
}
exports.notNegative = notNegative;
exports.radiansToDegrees = function (a) { return a * (180 / Math.PI); };
exports.degreesToRadians = function (a) { return a * (Math.PI / 180); };
//# sourceMappingURL=number-utils.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/types.js":
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
exports.isString = isString;
function isNumber(value) {
    return typeof value === "number" || value instanceof Number;
}
exports.isNumber = isNumber;
function isBoolean(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
exports.isBoolean = isBoolean;
function isFunction(value) {
    if (!value) {
        return false;
    }
    return typeof value === "function";
}
exports.isFunction = isFunction;
function isObject(value) {
    if (!value) {
        return false;
    }
    return typeof value === "object";
}
exports.isObject = isObject;
function isUndefined(value) {
    return value === undefined;
}
exports.isUndefined = isUndefined;
function isDefined(value) {
    return typeof value !== "undefined";
}
exports.isDefined = isDefined;
function isNullOrUndefined(value) {
    return value === undefined || value === null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function verifyCallback(value) {
    if (value && !isFunction(value)) {
        throw new TypeError("Callback must be a valid function.");
    }
}
exports.verifyCallback = verifyCallback;
var classInfosMap = new Map();
var funcNameRegex = /function ([_a-zA-Z0-9]{1,})\(/;
function getClass(object) {
    return getClassInfo(object).name;
}
exports.getClass = getClass;
function getClassInfo(object) {
    var constructor = object.constructor;
    var result = classInfosMap.get(constructor);
    if (!result) {
        result = new ClassInfo(constructor);
        classInfosMap.set(constructor, result);
    }
    return result;
}
exports.getClassInfo = getClassInfo;
function getBaseClasses(object) {
    var result = [];
    var info = getClassInfo(object);
    while (info) {
        result.push(info.name);
        info = info.baseClassInfo;
    }
    return result;
}
exports.getBaseClasses = getBaseClasses;
var ClassInfo = (function () {
    function ClassInfo(typeCosntructor) {
        this._typeCosntructor = typeCosntructor;
    }
    Object.defineProperty(ClassInfo.prototype, "name", {
        get: function () {
            if (!this._name) {
                var results = (funcNameRegex).exec(this._typeCosntructor.toString());
                this._name = (results && results.length > 1) ? results[1] : "";
            }
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClassInfo.prototype, "baseClassInfo", {
        get: function () {
            if (isUndefined(this._baseClassInfo)) {
                this._baseClassInfo = ClassInfo._getBase(this);
                if (this._baseClassInfo && this._baseClassInfo.name === this.name) {
                    this._baseClassInfo = ClassInfo._getBase(this._baseClassInfo);
                }
            }
            return this._baseClassInfo;
        },
        enumerable: true,
        configurable: true
    });
    ClassInfo._getBase = function (info) {
        var result = null;
        var constructorProto = info._typeCosntructor.prototype;
        if (constructorProto.__proto__) {
            result = getClassInfo(constructorProto.__proto__);
        }
        return result;
    };
    return ClassInfo;
}());
exports.ClassInfo = ClassInfo;
function toUIString(obj) {
    return isNullOrUndefined(obj) ? "" : obj + "";
}
exports.toUIString = toUIString;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/utils-common.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var mainthread_helper_1 = __webpack_require__("../node_modules/tns-core-modules/utils/mainthread-helper.js");
__export(__webpack_require__("../node_modules/tns-core-modules/utils/mainthread-helper.js"));
exports.RESOURCE_PREFIX = "res://";
exports.FILE_PREFIX = "file:///";
function escapeRegexSymbols(source) {
    var escapeRegex = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;
    return source.replace(escapeRegex, "\\$&");
}
exports.escapeRegexSymbols = escapeRegexSymbols;
function convertString(value) {
    var result;
    if (!types.isString(value) || value.trim() === "") {
        result = value;
    }
    else {
        var valueAsNumber = +value;
        if (!isNaN(valueAsNumber)) {
            result = valueAsNumber;
        }
        else if (value && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
            result = value.toLowerCase() === "true" ? true : false;
        }
        else {
            result = value;
        }
    }
    return result;
}
exports.convertString = convertString;
function getModuleName(path) {
    var moduleName = path.replace("./", "");
    return moduleName.substring(0, moduleName.lastIndexOf("."));
}
exports.getModuleName = getModuleName;
var layout;
(function (layout) {
    var MODE_SHIFT = 30;
    var MODE_MASK = 0x3 << MODE_SHIFT;
    layout.UNSPECIFIED = 0 << MODE_SHIFT;
    layout.EXACTLY = 1 << MODE_SHIFT;
    layout.AT_MOST = 2 << MODE_SHIFT;
    layout.MEASURED_HEIGHT_STATE_SHIFT = 0x00000010;
    layout.MEASURED_STATE_TOO_SMALL = 0x01000000;
    layout.MEASURED_STATE_MASK = 0xff000000;
    layout.MEASURED_SIZE_MASK = 0x00ffffff;
    function getMode(mode) {
        switch (mode) {
            case layout.EXACTLY:
                return "Exact";
            case layout.AT_MOST:
                return "AtMost";
            default:
                return "Unspecified";
        }
    }
    layout.getMode = getMode;
    function getMeasureSpecMode(spec) {
        return (spec & MODE_MASK);
    }
    layout.getMeasureSpecMode = getMeasureSpecMode;
    function getMeasureSpecSize(spec) {
        return (spec & ~MODE_MASK);
    }
    layout.getMeasureSpecSize = getMeasureSpecSize;
    function measureSpecToString(measureSpec) {
        var mode = getMeasureSpecMode(measureSpec);
        var size = getMeasureSpecSize(measureSpec);
        var text = "MeasureSpec: ";
        if (mode === layout.UNSPECIFIED) {
            text += "UNSPECIFIED ";
        }
        else if (mode === layout.EXACTLY) {
            text += "EXACTLY ";
        }
        else if (mode === layout.AT_MOST) {
            text += "AT_MOST ";
        }
        text += size;
        return text;
    }
    layout.measureSpecToString = measureSpecToString;
    function round(value) {
        var res = Math.floor(value + 0.5);
        if (res !== 0) {
            return res;
        }
        else if (value === 0) {
            return 0;
        }
        else if (value > 0) {
            return 1;
        }
        return -1;
    }
    layout.round = round;
})(layout = exports.layout || (exports.layout = {}));
function isFileOrResourcePath(path) {
    if (!types.isString(path)) {
        return false;
    }
    return path.indexOf("~/") === 0 ||
        path.indexOf("/") === 0 ||
        path.indexOf(exports.RESOURCE_PREFIX) === 0;
}
exports.isFileOrResourcePath = isFileOrResourcePath;
function isDataURI(uri) {
    if (!types.isString(uri)) {
        return false;
    }
    var firstSegment = uri.trim().split(",")[0];
    return firstSegment && firstSegment.indexOf("data:") === 0 && firstSegment.indexOf("base64") >= 0;
}
exports.isDataURI = isDataURI;
function mergeSort(arr, compareFunc) {
    if (arr.length < 2) {
        return arr;
    }
    var middle = arr.length / 2;
    var left = arr.slice(0, middle);
    var right = arr.slice(middle, arr.length);
    return merge(mergeSort(left, compareFunc), mergeSort(right, compareFunc), compareFunc);
}
exports.mergeSort = mergeSort;
function merge(left, right, compareFunc) {
    var result = [];
    while (left.length && right.length) {
        if (compareFunc(left[0], right[0]) <= 0) {
            result.push(left.shift());
        }
        else {
            result.push(right.shift());
        }
    }
    while (left.length) {
        result.push(left.shift());
    }
    while (right.length) {
        result.push(right.shift());
    }
    return result;
}
exports.merge = merge;
function hasDuplicates(arr) {
    return arr.length !== eliminateDuplicates(arr).length;
}
exports.hasDuplicates = hasDuplicates;
function eliminateDuplicates(arr) {
    return Array.from(new Set(arr));
}
exports.eliminateDuplicates = eliminateDuplicates;
function executeOnMainThread(func) {
    if (mainthread_helper_1.isMainThread()) {
        return func();
    }
    else {
        mainthread_helper_1.dispatchToMainThread(func);
    }
}
exports.executeOnMainThread = executeOnMainThread;
function mainThreadify(func) {
    return function () {
        var _this = this;
        var argsToPass = arguments;
        executeOnMainThread(function () { return func.apply(_this, argsToPass); });
    };
}
exports.mainThreadify = mainThreadify;
//# sourceMappingURL=utils-common.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/utils/utils.js":
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var trace_1 = __webpack_require__("../node_modules/tns-core-modules/trace/trace.js");
var utils_common_1 = __webpack_require__("../node_modules/tns-core-modules/utils/utils-common.js");
__export(__webpack_require__("../node_modules/tns-core-modules/utils/utils-common.js"));
var mainScreenScale;
function isOrientationLandscape(orientation) {
    return orientation === 3 || orientation === 4;
}
var layout;
(function (layout) {
    var MODE_SHIFT = 30;
    var MODE_MASK = 0x3 << MODE_SHIFT;
    function makeMeasureSpec(size, mode) {
        return (Math.round(Math.max(0, size)) & ~MODE_MASK) | (mode & MODE_MASK);
    }
    layout.makeMeasureSpec = makeMeasureSpec;
    function getDisplayDensity() {
        return mainScreenScale;
    }
    layout.getDisplayDensity = getDisplayDensity;
    function toDevicePixels(value) {
        return value * mainScreenScale;
    }
    layout.toDevicePixels = toDevicePixels;
    function toDeviceIndependentPixels(value) {
        return value / mainScreenScale;
    }
    layout.toDeviceIndependentPixels = toDeviceIndependentPixels;
    function measureNativeView(nativeView, width, widthMode, height, heightMode) {
        var view = nativeView;
        var nativeSize = view.sizeThatFits({
            width: widthMode === 0 ? Number.POSITIVE_INFINITY : toDeviceIndependentPixels(width),
            height: heightMode === 0 ? Number.POSITIVE_INFINITY : toDeviceIndependentPixels(height)
        });
        nativeSize.width = utils_common_1.layout.round(toDevicePixels(nativeSize.width));
        nativeSize.height = utils_common_1.layout.round(toDevicePixels(nativeSize.height));
        return nativeSize;
    }
    layout.measureNativeView = measureNativeView;
})(layout = exports.layout || (exports.layout = {}));
var ios;
(function (ios) {
    function getter(_this, property) {
        console.log("utils.ios.getter() is deprecated; use the respective native property instead");
        if (typeof property === "function") {
            return property.call(_this);
        }
        else {
            return property;
        }
    }
    ios.getter = getter;
    var collections;
    (function (collections) {
        function jsArrayToNSArray(str) {
            return NSArray.arrayWithArray(str);
        }
        collections.jsArrayToNSArray = jsArrayToNSArray;
        function nsArrayToJSArray(a) {
            var arr = [];
            if (a !== undefined) {
                var count = a.count;
                for (var i = 0; i < count; i++) {
                    arr.push(a.objectAtIndex(i));
                }
            }
            return arr;
        }
        collections.nsArrayToJSArray = nsArrayToJSArray;
    })(collections = ios.collections || (ios.collections = {}));
    function isLandscape() {
        var device = UIDevice.currentDevice;
        var statusBarOrientation = UIApplication.sharedApplication.statusBarOrientation;
        var isStatusBarOrientationLandscape = isOrientationLandscape(statusBarOrientation);
        return isOrientationLandscape(device.orientation) || isStatusBarOrientationLandscape;
    }
    ios.isLandscape = isLandscape;
    ios.MajorVersion = NSString.stringWithString(UIDevice.currentDevice.systemVersion).intValue;
    function openFile(filePath) {
        try {
            var appPath = getCurrentAppPath();
            var path = filePath.replace("~", appPath);
            var controller = UIDocumentInteractionController.interactionControllerWithURL(NSURL.fileURLWithPath(path));
            controller.delegate = new UIDocumentInteractionControllerDelegateImpl();
            return controller.presentPreviewAnimated(true);
        }
        catch (e) {
            trace_1.write("Error in openFile", trace_1.categories.Error, trace_1.messageType.error);
        }
        return false;
    }
    ios.openFile = openFile;
    function getCurrentAppPath() {
        var currentDir = __dirname;
        var tnsModulesIndex = currentDir.indexOf("/tns_modules");
        var appPath = currentDir;
        if (tnsModulesIndex !== -1) {
            appPath = currentDir.substring(0, tnsModulesIndex);
        }
        return appPath;
    }
    ios.getCurrentAppPath = getCurrentAppPath;
    function joinPaths() {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i] = arguments[_i];
        }
        if (!paths || paths.length === 0) {
            return "";
        }
        return NSString.stringWithString(NSString.pathWithComponents(paths)).stringByStandardizingPath;
    }
    ios.joinPaths = joinPaths;
    function getVisibleViewController(rootViewController) {
        if (rootViewController.presentedViewController) {
            return getVisibleViewController(rootViewController.presentedViewController);
        }
        if (rootViewController.isKindOfClass(UINavigationController.class())) {
            return getVisibleViewController(rootViewController.visibleViewController);
        }
        if (rootViewController.isKindOfClass(UITabBarController.class())) {
            return getVisibleViewController(rootViewController);
        }
        return rootViewController;
    }
    ios.getVisibleViewController = getVisibleViewController;
})(ios = exports.ios || (exports.ios = {}));
function GC() {
    __collect();
}
exports.GC = GC;
function releaseNativeObject(object) {
    __releaseNativeCounterpart(object);
}
exports.releaseNativeObject = releaseNativeObject;
function openUrl(location) {
    try {
        var url = NSURL.URLWithString(location.trim());
        if (UIApplication.sharedApplication.canOpenURL(url)) {
            return UIApplication.sharedApplication.openURL(url);
        }
    }
    catch (e) {
        trace_1.write("Error in OpenURL", trace_1.categories.Error, trace_1.messageType.error);
    }
    return false;
}
exports.openUrl = openUrl;
var UIDocumentInteractionControllerDelegateImpl = (function (_super) {
    __extends(UIDocumentInteractionControllerDelegateImpl, _super);
    function UIDocumentInteractionControllerDelegateImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIDocumentInteractionControllerDelegateImpl.prototype.getViewController = function () {
        var app = UIApplication.sharedApplication;
        return app.keyWindow.rootViewController;
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerViewControllerForPreview = function (controller) {
        return this.getViewController();
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerViewForPreview = function (controller) {
        return this.getViewController().view;
    };
    UIDocumentInteractionControllerDelegateImpl.prototype.documentInteractionControllerRectForPreview = function (controller) {
        return this.getViewController().view.frame;
    };
    UIDocumentInteractionControllerDelegateImpl.ObjCProtocols = [UIDocumentInteractionControllerDelegate];
    return UIDocumentInteractionControllerDelegateImpl;
}(NSObject));
mainScreenScale = UIScreen.mainScreen.scale;
//# sourceMappingURL=utils.ios.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/xhr/xhr.js":
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var http = __webpack_require__("../node_modules/tns-core-modules/http/http.js");
var types = __webpack_require__("../node_modules/tns-core-modules/utils/types.js");
var XMLHttpRequestResponseType;
(function (XMLHttpRequestResponseType) {
    XMLHttpRequestResponseType.empty = "";
    XMLHttpRequestResponseType.text = "text";
    XMLHttpRequestResponseType.json = "json";
})(XMLHttpRequestResponseType || (XMLHttpRequestResponseType = {}));
var XMLHttpRequest = (function () {
    function XMLHttpRequest() {
        this.UNSENT = 0;
        this.OPENED = 1;
        this.HEADERS_RECEIVED = 2;
        this.LOADING = 3;
        this.DONE = 4;
        this._responseType = "";
        this.textTypes = [
            "text/plain",
            "application/xml",
            "application/rss+xml",
            "text/html",
            "text/xml"
        ];
        this._listeners = new Map();
        this._readyState = this.UNSENT;
    }
    XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
        if (types.isString(method) && types.isString(url)) {
            this._options = { url: url, method: method };
            this._options.headers = {};
            if (types.isString(user)) {
                this._options.headers["user"] = user;
            }
            if (types.isString(password)) {
                this._options.headers["password"] = password;
            }
            this._setReadyState(this.OPENED);
        }
    };
    XMLHttpRequest.prototype.abort = function () {
        this._errorFlag = true;
        this._response = null;
        this._responseTextReader = null;
        this._headers = null;
        this._status = null;
        if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._readyState === this.DONE) {
            this._readyState = this.UNSENT;
        }
        else {
            this._setReadyState(this.DONE);
        }
    };
    XMLHttpRequest.prototype.send = function (data) {
        var _this = this;
        this._errorFlag = false;
        this._response = null;
        this._responseTextReader = null;
        this._headers = null;
        this._status = null;
        if (types.isDefined(this._options)) {
            if (types.isString(data) && this._options.method !== "GET") {
                this._options.content = data;
            }
            else if (data instanceof FormData) {
                this._options.content = data.toString();
            }
            http.request(this._options).then(function (r) {
                if (!_this._errorFlag) {
                    _this._loadResponse(r);
                }
            }).catch(function (e) {
                _this._errorFlag = true;
                _this._setReadyState(_this.DONE, e);
            });
        }
    };
    XMLHttpRequest.prototype._loadResponse = function (r) {
        this._status = r.statusCode;
        this._response = r.content.raw + "";
        this._headers = r.headers;
        this._setReadyState(this.HEADERS_RECEIVED);
        this._setReadyState(this.LOADING);
        this._setResponseType();
        this._responseTextReader = function () { return r.content.toString(); };
        this._addToStringOnResponse();
        if (this.responseType === XMLHttpRequestResponseType.json) {
            this._response = JSON.parse(this.responseText);
        }
        else if (this.responseType === XMLHttpRequestResponseType.text) {
            this._response = this.responseText;
        }
        this._setReadyState(this.DONE);
    };
    XMLHttpRequest.prototype._addToStringOnResponse = function () {
        var _this = this;
        if (types.isObject(this.response)) {
            Object.defineProperty(this._response, "toString", {
                configurable: true,
                enumerable: false,
                writable: true,
                value: function () { return _this.responseText; }
            });
        }
    };
    XMLHttpRequest.prototype.isTextContentType = function (contentType) {
        var result = false;
        for (var i = 0; i < this.textTypes.length; i++) {
            if (contentType.toLowerCase().indexOf(this.textTypes[i]) >= 0) {
                result = true;
                break;
            }
        }
        return result;
    };
    XMLHttpRequest.prototype._setResponseType = function () {
        var header = this.getResponseHeader("Content-Type");
        var contentType = header && header.toLowerCase();
        if (contentType) {
            if (contentType.indexOf("application/json") >= 0 || contentType.indexOf("+json") >= 0) {
                this.responseType = XMLHttpRequestResponseType.json;
            }
            else if (this.isTextContentType(contentType)) {
                this.responseType = XMLHttpRequestResponseType.text;
            }
        }
        else {
            this.responseType = XMLHttpRequestResponseType.text;
        }
    };
    XMLHttpRequest.prototype.addEventListener = function (eventName, handler) {
        if (eventName !== "load" && eventName !== "error" && eventName !== "progress") {
            throw new Error("Event not supported: " + eventName);
        }
        var handlers = this._listeners.get(eventName) || [];
        handlers.push(handler);
        this._listeners.set(eventName, handlers);
    };
    XMLHttpRequest.prototype.removeEventListener = function (eventName, toDetach) {
        var handlers = this._listeners.get(eventName) || [];
        handlers = handlers.filter(function (handler) { return handler !== toDetach; });
        this._listeners.set(eventName, handlers);
    };
    XMLHttpRequest.prototype.emitEvent = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var handlers = this._listeners.get(eventName) || [];
        handlers.forEach(function (handler) {
            handler.apply(void 0, args);
        });
    };
    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        if (types.isDefined(this._options) && types.isString(header) && types.isString(value)) {
            this._options.headers[header] = value;
        }
    };
    XMLHttpRequest.prototype.getAllResponseHeaders = function () {
        if (this._readyState < 2 || this._errorFlag) {
            return "";
        }
        var result = "";
        for (var i in this._headers) {
            result += i + ": " + this._headers[i] + "\r\n";
        }
        return result.substr(0, result.length - 2);
    };
    XMLHttpRequest.prototype.getResponseHeader = function (header) {
        if (types.isString(header) && this._readyState > 1
            && this._headers
            && !this._errorFlag) {
            header = header.toLowerCase();
            for (var i in this._headers) {
                if (i.toLowerCase() === header) {
                    return this._headers[i];
                }
            }
        }
        return null;
    };
    XMLHttpRequest.prototype.overrideMimeType = function (mime) {
    };
    Object.defineProperty(XMLHttpRequest.prototype, "readyState", {
        get: function () {
            return this._readyState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLHttpRequest.prototype, "responseType", {
        get: function () {
            return this._responseType;
        },
        set: function (value) {
            if (value === XMLHttpRequestResponseType.empty || value in XMLHttpRequestResponseType) {
                this._responseType = value;
            }
            else {
                throw new Error("Response type of '" + value + "' not supported.");
            }
        },
        enumerable: true,
        configurable: true
    });
    XMLHttpRequest.prototype._setReadyState = function (value, error) {
        if (this._readyState !== value) {
            this._readyState = value;
            if (types.isFunction(this.onreadystatechange)) {
                this.onreadystatechange();
            }
        }
        if (this._readyState === this.DONE) {
            if (this._errorFlag) {
                if (types.isFunction(this.onerror)) {
                    this.onerror(error);
                }
                this.emitEvent("error", error);
            }
            else {
                if (types.isFunction(this.onload)) {
                    this.onload();
                }
                this.emitEvent("load");
            }
        }
    };
    Object.defineProperty(XMLHttpRequest.prototype, "responseText", {
        get: function () {
            if (types.isFunction(this._responseTextReader)) {
                return this._responseTextReader();
            }
            return "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLHttpRequest.prototype, "response", {
        get: function () {
            return this._response;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLHttpRequest.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLHttpRequest.prototype, "statusText", {
        get: function () {
            if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._errorFlag) {
                return "";
            }
            return statuses[this._status];
        },
        enumerable: true,
        configurable: true
    });
    return XMLHttpRequest;
}());
exports.XMLHttpRequest = XMLHttpRequest;
var statuses = {
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non - Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Request Entity Too Large",
    414: "Request - URI Too Long",
    415: "Unsupported Media Type",
    416: "Requested Range Not Satisfiable",
    417: "Expectation Failed",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported"
};
var FormData = (function () {
    function FormData() {
        this._data = new Map();
    }
    FormData.prototype.append = function (name, value) {
        this._data.set(name, value);
    };
    FormData.prototype.toString = function () {
        var arr = new Array();
        this._data.forEach(function (value, name, map) {
            arr.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
        });
        return arr.join("&");
    };
    return FormData;
}());
exports.FormData = FormData;
//# sourceMappingURL=xhr.js.map

/***/ }),

/***/ "../node_modules/tns-core-modules/xml/xml.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });
var easysax = __webpack_require__("../node_modules/tns-core-modules/js-libs/easysax/easysax.js");
var ParserEventType = (function () {
    function ParserEventType() {
    }
    ParserEventType.StartElement = "StartElement";
    ParserEventType.EndElement = "EndElement";
    ParserEventType.Text = "Text";
    ParserEventType.CDATA = "CDATA";
    ParserEventType.Comment = "Comment";
    return ParserEventType;
}());
exports.ParserEventType = ParserEventType;
var ParserEvent = (function () {
    function ParserEvent(eventType, position, prefix, namespace, elementName, attributes, data) {
        this._eventType = eventType;
        this._position = position;
        this._prefix = prefix;
        this._namespace = namespace;
        this._elementName = elementName;
        this._attributes = attributes;
        this._data = data;
    }
    ParserEvent.prototype.toString = function () {
        return JSON.stringify({
            eventType: this.eventType,
            position: this.position,
            prefix: this.prefix,
            namespace: this.namespace,
            elementName: this.elementName,
            attributes: this.attributes,
            data: this.data
        });
    };
    Object.defineProperty(ParserEvent.prototype, "eventType", {
        get: function () {
            return this._eventType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "position", {
        get: function () {
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "prefix", {
        get: function () {
            return this._prefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "elementName", {
        get: function () {
            return this._elementName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "attributes", {
        get: function () {
            return this._attributes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserEvent.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    return ParserEvent;
}());
exports.ParserEvent = ParserEvent;
var _ampCodes;
var _entitySearchRegEx = /&#(\d+);|&#x([0123456789abcdef]+);|&(\w+);/ig;
function _generateAmpMap() {
    var objCodes = { Tab: 9, NewLine: 10, excl: 33, quot: 34, QUOT: 34, num: 35, dollar: 36, percent: 37, amp: 38, AMP: 38, apos: 39, lpar: 40, rpar: 41, ast: 42, midast: 42, plus: 43, comma: 44, period: 46, sol: 47, colon: 58, semi: 59, lt: 60, LT: 60, equals: 61, gt: 62, GT: 62, quest: 63, commat: 64, lsqb: 91, lbrack: 91, bsol: 92, rsqb: 92, rbrack: 92, Hat: 94, lowbar: 95, grave: 96, DiacriticalGrave: 96, lcub: 123, lbrace: 123, verbar: 124, vert: 124, VerticalLine: 124, rcub: 125, rbrace: 125, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, brkbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, hibar: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Dstrok: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, fnof: 402, imped: 437, gacute: 501, jmath: 567, circ: 710, caron: 711, Hacek: 711, breve: 728, Breve: 728, dot: 729, DiacriticalDot: 729, ring: 730, ogon: 731, tilde: 732, DiacriticalTilde: 732, dblac: 733, DiacriticalDoubleAcute: 733, DownBreve: 785, UnderBar: 818, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, epsiv: 949, varepsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigmav: 962, varsigma: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetav: 977, vartheta: 977, thetasym: 977, Upsi: 978, upsih: 978, straightphi: 981, piv: 982, varpi: 982, Gammad: 988, gammad: 989, digamma: 989, kappav: 1008, varkappa: 1008, rhov: 1009, varrho: 1009, epsi: 1013, straightepsilon: 1013, bepsi: 1014, backepsilon: 1014, euro: 8364, trade: 8482, TRADE: 8482, forall: 8704, part: 8706, larr: 8592, rarr: 8593, hyphen: 8208, dash: 8208, ndash: 8211, mdash: 8212, horbar: 8213, Vert: 8214, Verbar: 8214, lsquo: 8216, OpenCurlyQuote: 8216, rsquo: 8217, rsquor: 8217, CloseCurlyQuote: 8217, lsquor: 8218, sbquo: 8218, ldquo: 8220, OpenCurlyDoubleQuote: 8220, rdquo: 8221, rdquor: 8221, CloseCurlyDoubleQuote: 8221, ldquor: 8222, bdquo: 8222, dagger: 8224, Dagger: 8225, ddagger: 8225, bull: 8226, bullet: 8226, nldr: 8229, hellip: 8230, mldr: 8230, hybull: 8259, tdot: 8411, TripleDot: 8411, DotDot: 8412, star: 9734, phone: 9742, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830, female: 9792, male: 9794, check: 10003, checkmark: 10003, cross: 10007, VerticalSeparator: 10072, EmptySmallSquare: 9723, FilledSmallSquare: 9724, starf: 9733, bigstar: 9733, square: 9633, squ: 9633, Square: 9633 };
    var ampCodes = new Map();
    for (var key in objCodes) {
        if (objCodes.hasOwnProperty(key)) {
            ampCodes.set(key, objCodes[key]);
        }
    }
    return ampCodes;
}
if (global.__snapshot) {
    _ampCodes = _generateAmpMap();
}
function _HandleAmpEntities(found, decimalValue, hexValue, wordValue) {
    if (wordValue) {
        if (!_ampCodes) {
            _ampCodes = _generateAmpMap();
        }
        var res = _ampCodes.get(wordValue);
        if (res) {
            return String.fromCharCode(res);
        }
        return found;
    }
    if (decimalValue) {
        return String.fromCharCode(parseInt(decimalValue, 10));
    }
    return String.fromCharCode(parseInt(hexValue, 16));
}
;
var XmlParser = (function () {
    function XmlParser(onEvent, onError, processNamespaces) {
        this._processNamespaces = processNamespaces;
        this._parser = new easysax.EasySAXParser();
        var that = this;
        this._parser.on("startNode", function (elem, attr, uq, tagend, str, pos) {
            var attributes = attr();
            if (attributes === true) {
                attributes = undefined;
            }
            if (attributes) {
                for (var key in attributes) {
                    if (attributes.hasOwnProperty(key)) {
                        attributes[key] = XmlParser._dereferenceEntities(attributes[key]);
                    }
                }
            }
            var prefix = undefined;
            var namespace = undefined;
            var name = elem;
            if (that._processNamespaces) {
                var stackEntry = XmlParser._getNamespacesStackEntry(attributes);
                that._namespaceStack.push(stackEntry);
                var resolved = that._resolveNamespace(name);
                prefix = resolved.prefix;
                namespace = resolved.namespace;
                name = resolved.name;
            }
            onEvent(new ParserEvent(ParserEventType.StartElement, pos(), prefix, namespace, name, attributes, undefined));
        });
        this._parser.on("textNode", function (text, uq, pos) {
            var data = uq(XmlParser._dereferenceEntities(text));
            onEvent(new ParserEvent(ParserEventType.Text, pos(), undefined, undefined, undefined, undefined, data));
        });
        this._parser.on("endNode", function (elem, uq, tagstart, str, pos) {
            var prefix = undefined;
            var namespace = undefined;
            var name = elem;
            if (that._processNamespaces) {
                var resolved = that._resolveNamespace(name);
                prefix = resolved.prefix;
                namespace = resolved.namespace;
                name = resolved.name;
            }
            onEvent(new ParserEvent(ParserEventType.EndElement, pos(), prefix, namespace, name, undefined, undefined));
            if (that._processNamespaces) {
                that._namespaceStack.pop();
            }
        });
        this._parser.on("cdata", function (data, res, pos) {
            onEvent(new ParserEvent(ParserEventType.CDATA, pos(), undefined, undefined, undefined, undefined, data));
        });
        this._parser.on("comment", function (text, uq, pos) {
            onEvent(new ParserEvent(ParserEventType.Comment, pos(), undefined, undefined, undefined, undefined, text));
        });
        if (onError) {
            this._parser.on("error", function (msg, pos) {
                onError(new Error(msg), pos());
            });
        }
    }
    Object.defineProperty(XmlParser.prototype, "angularSyntax", {
        get: function () {
            return this._parser.angularSyntax;
        },
        set: function (value) {
            this._parser.angularSyntax = value;
        },
        enumerable: true,
        configurable: true
    });
    XmlParser.prototype.parse = function (xmlString) {
        if (this._processNamespaces) {
            this._namespaceStack = [];
        }
        this._parser.parse(xmlString);
    };
    XmlParser._getNamespacesStackEntry = function (attributes) {
        var stackEntry = {};
        if (!attributes) {
            return stackEntry;
        }
        var attributeName;
        var namespacePrefix;
        for (var key in attributes) {
            if (!attributes.hasOwnProperty(key)) {
                continue;
            }
            attributeName = key;
            if (attributeName.indexOf("xmlns") !== 0) {
                continue;
            }
            namespacePrefix = "";
            if (attributeName.indexOf(":") !== -1) {
                namespacePrefix = attributeName.split(":")[1];
            }
            stackEntry[namespacePrefix] = attributes[key];
        }
        return stackEntry;
    };
    XmlParser.prototype._resolveNamespace = function (fullName) {
        var result = { prefix: undefined, namespace: undefined, name: undefined };
        result.prefix = "";
        if (fullName.indexOf(":") !== -1) {
            var split = fullName.split(":");
            result.prefix = split[0];
            result.name = split[1];
        }
        else {
            result.name = fullName;
        }
        var stackEntry;
        for (var i = this._namespaceStack.length - 1; i >= 0; i--) {
            stackEntry = this._namespaceStack[i];
            for (var key in stackEntry) {
                if (!stackEntry.hasOwnProperty(key)) {
                    continue;
                }
                if (result.prefix === key) {
                    result.namespace = stackEntry[key];
                    return result;
                }
            }
        }
        return result;
    };
    XmlParser._dereferenceEntities = function (s) {
        s = String(s);
        if (s.length > 3 && s.indexOf("&") !== -1) {
            s = s.replace(_entitySearchRegEx, _HandleAmpEntities);
        }
        return s;
    };
    return XmlParser;
}());
exports.XmlParser = XmlParser;
//# sourceMappingURL=xml.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/tslib/tslib.es6.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

}]);